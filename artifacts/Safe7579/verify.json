{"language":"Solidity","sources":{"src/Safe7579.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport { IERC7579Account, Execution } from \"./interfaces/IERC7579Account.sol\";\nimport {\n    CallType,\n    ExecType,\n    ModeCode,\n    EXECTYPE_DEFAULT,\n    EXECTYPE_TRY,\n    CALLTYPE_SINGLE,\n    CALLTYPE_BATCH,\n    CALLTYPE_DELEGATECALL\n} from \"src/lib/ModeLib.sol\";\nimport { ExecutionLib } from \"./lib/ExecutionLib.sol\";\nimport {\n    IValidator,\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_HOOK,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_FALLBACK,\n    MODULE_TYPE_PREVALIDATION_HOOK_ERC1271,\n    MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n} from \"erc7579/interfaces/IERC7579Module.sol\";\nimport { ModuleInstallUtil } from \"./utils/DCUtil.sol\";\nimport { AccessControl } from \"./core/AccessControl.sol\";\nimport { Initializer } from \"./core/Initializer.sol\";\nimport { SafeOp } from \"./core/SafeOp.sol\";\nimport { ISafe } from \"./interfaces/ISafe.sol\";\nimport { ISafe7579 } from \"./ISafe7579.sol\";\nimport {\n    PackedUserOperation,\n    UserOperationLib\n} from \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\nimport { _packValidationData } from \"@ERC4337/account-abstraction/contracts/core/Helpers.sol\";\nimport { IEntryPoint } from \"@ERC4337/account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport { IERC1271 } from \"./interfaces/IERC1271.sol\";\nimport { SupportViewer } from \"./core/SupportViewer.sol\";\nimport { EmergencyUninstall } from \"./DataTypes.sol\";\nimport { EIP712 } from \"./lib/EIP712.sol\";\n\nuint256 constant MULTITYPE_MODULE = 0;\n\n/**\n * @title ERC7579 Adapter for Safe accounts.\n * creates full ERC7579 compliance to Safe accounts\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n * @dev This contract is a Safe account implementation that supports ERC7579 operations.\n *    In order to facilitate full ERC7579 compliance, the contract implements the IERC7579Account\n *    interface.\n * This contract is an implementation of a Safe account supporting ERC7579 operations and complying\n * with the IERC7579Account interface. It serves as a Safe FallbackHandler and module for Safe\n * accounts, incorporating complex hacks to ensure ERC7579 compliance and requiring interactions and\n * event emissions to be done via the SafeProxy as msg.sender using Safe's\n * \"executeTransactionFromModule\" features.\n */\ncontract Safe7579 is ISafe7579, SafeOp, SupportViewer, AccessControl, Initializer {\n    using ExecutionLib for bytes;\n\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\"safeSignature(bytes32,bytes32,bytes,bytes)\");\n    bytes4 private constant SAFE_SIGNATURE_MAGIC_VALUE = 0x5fd7e97d;\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function execute(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        withHook\n        onlyEntryPointOrSelf\n    {\n        CallType callType;\n        ExecType execType;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            callType := mode\n            execType := shl(8, mode)\n        }\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*                   REVERT ON FAILED EXEC                    */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n        ISafe safe = ISafe(msg.sender);\n        if (execType == EXECTYPE_DEFAULT) {\n            // DEFAULT EXEC & BATCH CALL\n            if (callType == CALLTYPE_BATCH) {\n                Execution[] calldata executions = executionCalldata.decodeBatch();\n                _exec(safe, executions);\n            }\n            // DEFAULT EXEC & SINGLE CALL\n            else if (callType == CALLTYPE_SINGLE) {\n                (address target, uint256 value, bytes calldata callData) =\n                    executionCalldata.decodeSingle();\n                _exec(safe, target, value, callData);\n            }\n            // DEFAULT EXEC & DELEGATECALL\n            else if (callType == CALLTYPE_DELEGATECALL) {\n                address target = address(bytes20(executionCalldata[:20]));\n                bytes calldata callData = executionCalldata[20:];\n                _delegatecall(safe, target, callData);\n            }\n            // handle unsupported calltype\n            else {\n                revert UnsupportedCallType(callType);\n            }\n        }\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*                           TRY EXEC                         */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n        else if (execType == EXECTYPE_TRY) {\n            // TRY EXEC & BATCH CALL\n            if (callType == CALLTYPE_BATCH) {\n                Execution[] calldata executions = executionCalldata.decodeBatch();\n                _tryExec(safe, executions);\n            }\n            // TRY EXEC & SINGLE CALL\n            else if (callType == CALLTYPE_SINGLE) {\n                (address target, uint256 value, bytes calldata callData) =\n                    executionCalldata.decodeSingle();\n                _tryExec(safe, target, value, callData);\n            }\n            // TRY EXEC & DELEGATECALL\n            else if (callType == CALLTYPE_DELEGATECALL) {\n                address target = address(bytes20(executionCalldata[:20]));\n                bytes calldata callData = executionCalldata[20:];\n                _tryDelegatecall(safe, target, callData);\n            }\n            // handle unsupported calltype\n            else {\n                revert UnsupportedCallType(callType);\n            }\n        }\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*               HANDLE UNSUPPORTED EXEC TYPE                 */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n        else {\n            revert UnsupportedExecType(execType);\n        }\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        override\n        onlyExecutorModule\n        withHook\n        withRegistry(_msgSender(), MODULE_TYPE_EXECUTOR)\n        returns (bytes[] memory returnDatas)\n    {\n        CallType callType;\n        ExecType execType;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            callType := mode\n            execType := shl(8, mode)\n        }\n        // using JUMPI to avoid stack too deep\n        return _executeReturn(execType, callType, executionCalldata);\n    }\n\n    /**\n     * Internal function that will be solely called by executeFromExecutor. Not super uniform code,\n     * but we need the JUMPI to avoid stack too deep, due to the modifiers in the\n     * executeFromExecutor function\n     */\n    function _executeReturn(\n        ExecType execType,\n        CallType callType,\n        bytes calldata executionCalldata\n    )\n        private\n        returns (bytes[] memory returnDatas)\n    {\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*                   REVERT ON FAILED EXEC                    */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n        if (execType == EXECTYPE_DEFAULT) {\n            // DEFAULT EXEC & BATCH CALL\n            if (callType == CALLTYPE_BATCH) {\n                Execution[] calldata executions = executionCalldata.decodeBatch();\n                returnDatas = _execReturn(ISafe(msg.sender), executions);\n            }\n            // DEFAULT EXEC & SINGLE CALL\n            else if (callType == CALLTYPE_SINGLE) {\n                (address target, uint256 value, bytes calldata callData) =\n                    executionCalldata.decodeSingle();\n                returnDatas = new bytes[](1);\n                returnDatas[0] = _execReturn(ISafe(msg.sender), target, value, callData);\n            }\n            // DEFAULT EXEC & DELEGATECALL\n            else if (callType == CALLTYPE_DELEGATECALL) {\n                address target = address(bytes20(executionCalldata[:20]));\n                bytes calldata callData = executionCalldata[20:];\n                returnDatas = new bytes[](1);\n                returnDatas[0] = _delegatecallReturn(ISafe(msg.sender), target, callData);\n            }\n            // handle unsupported calltype\n            else {\n                revert UnsupportedCallType(callType);\n            }\n        }\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*                           TRY EXEC                         */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n        else if (execType == EXECTYPE_TRY) {\n            // TRY EXEC & BATCH CALL\n            if (callType == CALLTYPE_BATCH) {\n                Execution[] calldata executions = executionCalldata.decodeBatch();\n                (, returnDatas) = _tryExecReturn(ISafe(msg.sender), executions);\n            }\n            // TRY EXEC & SINGLE CALL\n            else if (callType == CALLTYPE_SINGLE) {\n                (address target, uint256 value, bytes calldata callData) =\n                    executionCalldata.decodeSingle();\n                returnDatas = new bytes[](1);\n                returnDatas[0] = _tryExecReturn(ISafe(msg.sender), target, value, callData);\n            }\n            // TRY EXEC & DELEGATECALL\n            else if (callType == CALLTYPE_DELEGATECALL) {\n                address target = address(bytes20(executionCalldata[:20]));\n                bytes calldata callData = executionCalldata[20:];\n                returnDatas = new bytes[](1);\n                returnDatas[0] = _tryDelegatecallReturn(ISafe(msg.sender), target, callData);\n            }\n            // handle unsupported calltype\n            else {\n                revert UnsupportedCallType(callType);\n            }\n        }\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*               HANDLE UNSUPPORTED EXEC TYPE                 */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n        else {\n            revert UnsupportedExecType(execType);\n        }\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function validateUserOp(\n        PackedUserOperation memory userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        onlyEntryPoint\n        returns (uint256 validSignature)\n    {\n        address validator;\n        uint256 nonce = userOp.nonce;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            validator := shr(96, nonce)\n        }\n\n        // Call 4337 pre-validation hook, the prevalidation hook processes the userOpHash, userOp\n        // and missingAccountFunds which allows for the pre-validation hook to modify and validate\n        // the userOpHash and signature before the actual validation happens\n        (userOpHash, userOp.signature) =\n            _withPreValidationHook(userOpHash, userOp, missingAccountFunds);\n\n        // check if validator is enabled. If not, use Safe's checkSignatures()\n        if (validator == address(0) || !_isValidatorInstalled(validator)) {\n            validSignature = _validateSignatures(userOp);\n        } else {\n            // bubble up the return value of the validator module\n            bytes memory retData = _execReturn({\n                safe: ISafe(msg.sender),\n                target: validator,\n                value: 0,\n                callData: abi.encodeCall(IValidator.validateUserOp, (userOp, userOpHash))\n            });\n            validSignature = abi.decode(retData, (uint256));\n        }\n\n        // pay prefund\n        if (missingAccountFunds != 0) {\n            _exec({\n                safe: ISafe(msg.sender),\n                target: entryPoint(),\n                value: missingAccountFunds,\n                callData: \"\"\n            });\n        }\n    }\n\n    /**\n     * Function used as signature check fallback, if no valid validation module was selected.\n     * will use safe's ECDSA multisig. This code was copied of Safe's ERC4337 module\n     */\n    function _validateSignatures(PackedUserOperation memory userOp)\n        internal\n        view\n        returns (uint256 validationData)\n    {\n        (bytes memory operationData, uint48 validAfter, uint48 validUntil, bytes memory signatures)\n        = getSafeOp(userOp, entryPoint());\n        try ISafe((msg.sender)).checkSignatures(keccak256(operationData), operationData, signatures)\n        {\n            // The timestamps are validated by the entry point,\n            // therefore we will not check them again\n            validationData = _packValidationData({\n                sigFailed: false,\n                validUntil: validUntil,\n                validAfter: validAfter\n            });\n        } catch {\n            validationData = _packValidationData({\n                sigFailed: true,\n                validUntil: validUntil,\n                validAfter: validAfter\n            });\n        }\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function isValidSignature(\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4 magicValue)\n    {\n        ISafe safe = ISafe(msg.sender);\n\n        // If signature is empty, check for safe's approved hashes\n        if (data.length == 0) {\n            // Call 1271 pre-validation hook\n            (hash,) = _withPreValidationHook(_msgSender(), hash, data);\n            bytes32 messageHash =\n                keccak256(EIP712.encodeMessageData(safe.domainSeparator(), abi.encode(hash)));\n\n            require(safe.signedMessages(messageHash) != 0, \"Hash not approved\");\n            // return magic value\n            return IERC1271.isValidSignature.selector;\n        }\n        address validationModule = address(bytes20(data[:20]));\n        // Call 1271 pre-validation hook\n        bytes memory data_;\n        (hash, data_) = _withPreValidationHook(_msgSender(), hash, data[20:]);\n\n        // If validation module with address(0) or no valid validator was provided,\n        // The signature validation mechanism falls back to Safe's checkSignatures() function\n        if (validationModule == address(0) || !_isValidatorInstalled(validationModule)) {\n            bytes memory messageData =\n                EIP712.encodeMessageData(safe.domainSeparator(), abi.encode(hash));\n            bytes32 messageHash = keccak256(messageData);\n            safe.checkSignatures(messageHash, messageData, data_);\n            return IERC1271.isValidSignature.selector;\n        }\n\n        // if a installed validator module was selected, use 7579 validation module\n        bytes memory ret = _staticcallReturn({\n            safe: ISafe(msg.sender),\n            target: validationModule,\n            callData: abi.encodeCall(IValidator.isValidSignatureWithSender, (_msgSender(), hash, data_))\n        });\n        magicValue = abi.decode(ret, (bytes4));\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function installModule(\n        uint256 moduleType,\n        address module,\n        bytes calldata initData\n    )\n        external\n        override\n        withHook\n        onlyEntryPointOrSelf\n    {\n        // internal install functions will decode the initData param, and return sanitized\n        // moduleInitData. This is the initData that will be passed to Module.onInstall()\n        bytes memory moduleInitData;\n        if (moduleType == MODULE_TYPE_VALIDATOR) {\n            moduleInitData = _installValidator(module, initData);\n        } else if (moduleType == MODULE_TYPE_EXECUTOR) {\n            moduleInitData = _installExecutor(module, initData);\n        } else if (moduleType == MODULE_TYPE_FALLBACK) {\n            moduleInitData = _installFallbackHandler(module, initData);\n        } else if (moduleType == MODULE_TYPE_HOOK) {\n            moduleInitData = _installHook(module, initData);\n        } else if (moduleType == MULTITYPE_MODULE) {\n            moduleInitData = _multiTypeInstall(module, initData);\n        } else if (\n            moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n                || moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n        ) {\n            moduleInitData = _installPreValidationHook(module, initData);\n        } else {\n            revert UnsupportedModuleType(moduleType);\n        }\n\n        // Initialize Module via Safe\n        _delegatecall({\n            safe: ISafe(msg.sender),\n            target: UTIL,\n            callData: abi.encodeCall(\n                ModuleInstallUtil.installModule, (moduleType, module, moduleInitData)\n            )\n        });\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function uninstallModule(\n        uint256 moduleType,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        override\n        withHook\n        onlyEntryPointOrSelf\n    {\n        // internal uninstall functions will decode the deInitData param, and return sanitized\n        // moduleDeInitData. This is the initData that will be passed to Module.onUninstall()\n        bytes memory moduleDeInitData;\n        if (moduleType == MODULE_TYPE_VALIDATOR) {\n            moduleDeInitData = _uninstallValidator(module, deInitData);\n        } else if (moduleType == MODULE_TYPE_EXECUTOR) {\n            moduleDeInitData = _uninstallExecutor(module, deInitData);\n        } else if (moduleType == MODULE_TYPE_FALLBACK) {\n            moduleDeInitData = _uninstallFallbackHandler(module, deInitData);\n        } else if (moduleType == MODULE_TYPE_HOOK) {\n            moduleDeInitData = _uninstallHook(module, deInitData);\n        } else if (moduleType == MULTITYPE_MODULE) {\n            moduleDeInitData = _multiTypeUninstall(module, deInitData);\n        } else if (\n            moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n                || moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n        ) {\n            moduleDeInitData = _uninstallPreValidationHook(module, deInitData);\n        } else {\n            revert UnsupportedModuleType(moduleType);\n        }\n\n        // Deinitialize Module via Safe.\n        // We are using \"try\" here, to avoid DoS. A module could revert in 'onUninstall' and prevent\n        // the account from removing the module\n        _tryDelegatecall({\n            safe: ISafe(msg.sender),\n            target: UTIL,\n            callData: abi.encodeCall(\n                ModuleInstallUtil.unInstallModule, (moduleType, module, moduleDeInitData)\n            )\n        });\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function emergencyUninstallHook(\n        EmergencyUninstall calldata data,\n        bytes calldata signature\n    )\n        external\n    {\n        // Parse uninstall data\n        (uint256 hookType, address hook, bytes calldata deInitData) =\n            (data.hookType, data.hook, data.deInitData);\n\n        // Validate the hook is of a supported type and is installed\n        require(\n            hookType == MODULE_TYPE_HOOK || hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n                || hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337,\n            UnsupportedModuleType(hookType)\n        );\n        require(isModuleInstalled(hookType, hook, deInitData), ModuleNotInstalled(hook, hookType));\n\n        // Validate the signature\n        _checkEmergencyUninstallSignature(data, signature);\n\n        // Get the account storage\n        uint256 hookTimelock = $emergencyUninstallTime[hook][msg.sender];\n\n        if (hookTimelock == 0) {\n            // if the timelock hasnt been initiated, initiate it\n            $emergencyUninstallTime[hook][msg.sender] = block.timestamp;\n            emit EmergencyHookUninstallRequest(hook, block.timestamp);\n        } else if (block.timestamp >= hookTimelock + 3 * _EMERGENCY_TIMELOCK) {\n            // if the timelock has been left for too long, reset it\n            $emergencyUninstallTime[hook][msg.sender] = 0;\n            emit EmergencyHookUninstallRequestReset(hook, block.timestamp);\n        } else if (block.timestamp >= hookTimelock + _EMERGENCY_TIMELOCK) {\n            // if the timelock has passed, clear it and uninstall the hook\n            $emergencyUninstallTime[hook][msg.sender] = 0;\n            if (hookType == MODULE_TYPE_HOOK) {\n                _uninstallHook(hook, deInitData);\n            } else if (\n                hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n                    || hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n            ) {\n                _uninstallPreValidationHook(hook, deInitData);\n            }\n            // Deinitialize Module via Safe.\n            // We are using \"try\" here, to avoid DoS. A module could revert in 'onUninstall' and\n            // prevent\n            // the account from removing the module\n            _tryDelegatecall({\n                safe: ISafe(msg.sender),\n                target: UTIL,\n                callData: abi.encodeCall(\n                    ModuleInstallUtil.unInstallModule, (hookType, hook, deInitData)\n                )\n            });\n        } else {\n            // if the timelock is initiated but not expired, revert\n            revert EmergencyTimeLockNotExpired();\n        }\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function isModuleInstalled(\n        uint256 moduleType,\n        address module,\n        bytes calldata additionalContext\n    )\n        public\n        view\n        returns (bool)\n    {\n        if (moduleType == MODULE_TYPE_VALIDATOR) {\n            // Safe7579 adapter allows for validator fallback to Safe's checkSignatures().\n            // It can thus be considered a valid validator module\n            if (module == msg.sender) return true;\n            return _isValidatorInstalled(module);\n        } else if (moduleType == MODULE_TYPE_EXECUTOR) {\n            return _isExecutorInstalled(module);\n        } else if (moduleType == MODULE_TYPE_FALLBACK) {\n            return _isFallbackHandlerInstalled(module, additionalContext);\n        } else if (moduleType == MODULE_TYPE_HOOK) {\n            return _isHookInstalled(module);\n        } else if (\n            moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n                || moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n        ) {\n            return _isPreValidationHookInstalled(module, additionalContext);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function getNonce(address safe, address validator) external view returns (uint256 nonce) {\n        uint192 key = uint192(bytes24(bytes20(address(validator))));\n        nonce = IEntryPoint(entryPoint()).getNonce(safe, key);\n    }\n}\n"},"src/interfaces/IERC7579Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { CallType, ExecType, ModeCode } from \"../lib/ModeLib.sol\";\n\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n\ninterface IERC7579AccountEvents {\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n}\n\ninterface IERC7579AccountView {\n    /**\n     * @dev Returns the account id of the smart account\n     * @return accountImplementationId the account id of the smart account\n     * the accountId should be structured like so:\n     *        \"vendorname.accountname.semver\"\n     */\n    function accountId() external view returns (string memory accountImplementationId);\n\n    /**\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\n     * @param encodedMode the encoded mode\n     */\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\n\n    /**\n     * Function to check if the account supports installation of a certain module type Id\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     */\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\n}\n\ninterface IERC7579Account is IERC7579AccountEvents, IERC7579AccountView {\n    // Error thrown when an unsupported ModuleType is requested\n    error UnsupportedModuleType(uint256 moduleTypeId);\n    // Error thrown when an execution with an unsupported CallType was made\n    error UnsupportedCallType(CallType callType);\n    // Error thrown when an execution with an unsupported ExecType was made\n    error UnsupportedExecType(ExecType execType);\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n\n    function execute(ModeCode mode, bytes calldata executionCalldata) external;\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by Executor Modules\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        returns (bytes[] memory returnData);\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(bytes32 hash, bytes calldata data) external returns (bytes4);\n\n    /**\n     * @dev installs a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external;\n\n    /**\n     * @dev uninstalls a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external;\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool);\n}\n"},"src/lib/ModeLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title ModeLib\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n * encoding is used.\n *    Function Signature of execute function:\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n * context.\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n * implement\n * more complex execution modes may use the entire bytes32.\n *\n * |--------------------------------------------------------------------|\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n * |--------------------------------------------------------------------|\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n * |--------------------------------------------------------------------|\n *\n * CALLTYPE: 1 byte\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\n * decoded.\n * It can be either single, batch or delegatecall. In the future different calls could be added.\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n *\n * EXECTYPE: 1 byte\n * ExecType is used to determine how the account should handle the execution.\n * It can indicate if the execution should revert on failure or continue execution.\n * In the future more execution modes may be added.\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n * a batch fails, the entire batch is reverted\n *\n * UNUSED: 4 bytes\n * Unused bytes are reserved for future use.\n *\n * ModeSelector: bytes4\n * The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n * their accounts.\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n * this is to prevent collisions between different vendors, while allowing innovation and the\n * development of new features without coordination between ERC-7579 implementing accounts\n *\n * ModePayload: 22 bytes\n * Mode payload is used to pass additional data to the smart account execution, this may be\n * interpreted depending on the ModeSelector\n *\n * ExecutionCallData: n bytes\n * single, delegatecall or batch exec abi.encoded as bytes\n */\n\n// Custom type for improved developer experience\ntype ModeCode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/**\n * @dev ModeLib is a helper library to encode/decode ModeCodes\n */\nlibrary ModeLib {\n    function decode(ModeCode mode)\n        internal\n        pure\n        returns (\n            CallType _calltype,\n            ExecType _execType,\n            ModeSelector _modeSelector,\n            ModePayload _modePayload\n        )\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function encode(\n        CallType callType,\n        ExecType execType,\n        ModeSelector mode,\n        ModePayload payload\n    )\n        internal\n        pure\n        returns (ModeCode)\n    {\n        return ModeCode.wrap(\n            bytes32(\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\n            )\n        );\n    }\n\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { eqModeSelector as == } for ModeSelector global;\nusing { eqCallType as == } for CallType global;\nusing { neqCallType as != } for CallType global;\nusing { eqExecType as == } for ExecType global;\n\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction neqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) != CallType.unwrap(b);\n}\n\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n"},"src/lib/ExecutionLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\n\n/**\n * Helper Library for decoding Execution calldata\n * malloc for memory allocation is bad for gas. use this assembly instead\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\nlibrary ExecutionLib {\n    error ERC7579DecodingError();\n\n    /**\n     * @notice Decode a batch of `Execution` executionBatch from a `bytes` calldata.\n     * @dev code is copied from solady's LibERC7579.sol\n     * https://github.com/Vectorized/solady/blob/740812cedc9a1fc11e17cb3d4569744367dedf19/src/accounts/LibERC7579.sol#L146\n     *      Credits to Vectorized and the Solady Team\n     */\n    function decodeBatch(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (Execution[] calldata executionBatch)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let u := calldataload(executionCalldata.offset)\n            let s := add(executionCalldata.offset, u)\n            let e := sub(add(executionCalldata.offset, executionCalldata.length), 0x20)\n            executionBatch.offset := add(s, 0x20)\n            executionBatch.length := calldataload(s)\n            if or(shr(64, u), gt(add(s, shl(5, executionBatch.length)), e)) {\n                mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                revert(0x1c, 0x04)\n            }\n            if executionBatch.length {\n                // Perform bounds checks on the decoded `executionBatch`.\n                // Loop runs out-of-gas if `executionBatch.length` is big enough to cause overflows.\n                for { let i := executionBatch.length } 1 { } {\n                    i := sub(i, 1)\n                    let p := calldataload(add(executionBatch.offset, shl(5, i)))\n                    let c := add(executionBatch.offset, p)\n                    let q := calldataload(add(c, 0x40))\n                    let o := add(c, q)\n                    // forgefmt: disable-next-item\n                    if or(shr(64, or(calldataload(o), or(p, q))),\n                        or(gt(add(c, 0x40), e), gt(add(o, calldataload(o)), e))) {\n                        mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                        revert(0x1c, 0x04)\n                    }\n                    if iszero(i) { break }\n                }\n            }\n        }\n    }\n\n    function encodeBatch(Execution[] memory executions)\n        internal\n        pure\n        returns (bytes memory callData)\n    {\n        callData = abi.encode(executions);\n    }\n\n    function decodeSingle(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (address target, uint256 value, bytes calldata callData)\n    {\n        target = address(bytes20(executionCalldata[0:20]));\n        value = uint256(bytes32(executionCalldata[20:52]));\n        callData = executionCalldata[52:];\n    }\n\n    function encodeSingle(\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        pure\n        returns (bytes memory userOpCalldata)\n    {\n        userOpCalldata = abi.encodePacked(target, value, callData);\n    }\n}\n"},"node_modules/erc7579/src/interfaces/IERC7579Module.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\n\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC1271 = 8;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC4337 = 9;\n\ninterface IModule {\n    error AlreadyInitialized(address smartAccount);\n    error NotInitialized(address smartAccount);\n\n    /**\n     * @dev This function is called by the smart account during installation of the module\n     * @param data arbitrary data that may be required on the module during `onInstall`\n     * initialization\n     *\n     * MUST revert on error (i.e. if module is already enabled)\n     */\n    function onInstall(bytes calldata data) external;\n\n    /**\n     * @dev This function is called by the smart account during uninstallation of the module\n     * @param data arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization\n     *\n     * MUST revert on error\n     */\n    function onUninstall(bytes calldata data) external;\n\n    /**\n     * @dev Returns boolean value if module is a certain type\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *\n     * MUST return true if the module is of the given type and false otherwise\n     */\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * @dev Returns if the module was already initialized for a provided smartaccount\n     */\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n\ninterface IValidator is IModule {\n    error InvalidTargetAddress(address target);\n\n    /**\n     * @dev Validates a transaction on behalf of the account.\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\n     * The MSA MUST clean up the userOp before sending it to the validator.\n     * @param userOpHash The hash of the user operation to be validated\n     * @return return value according to ERC-4337\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        returns (uint256);\n\n    /**\n     * Validator can be used for ERC-1271 validation\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IExecutor is IModule { }\n\ninterface IHook is IModule {\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        returns (bytes memory hookData);\n\n    function postCheck(bytes calldata hookData) external;\n}\n\ninterface IFallback is IModule { }\n\ninterface IPreValidationHookERC1271 is IModule {\n    function preValidationHookERC1271(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes32 hookHash, bytes memory hookSignature);\n}\n\ninterface IPreValidationHookERC4337 is IModule {\n    function preValidationHookERC4337(\n        PackedUserOperation calldata userOp,\n        uint256 missingAccountFunds,\n        bytes32 userOpHash\n    )\n        external\n        returns (bytes32 hookHash, bytes memory hookSignature);\n}\n"},"src/utils/DCUtil.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\nimport { IModule as IERC7579Module } from \"../interfaces/IERC7579Module.sol\";\nimport { IERC7579AccountEvents } from \"../interfaces/IERC7579Account.sol\";\n\ncontract ModuleInstallUtil is IERC7579AccountEvents {\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n    {\n        IERC7579Module(module).onInstall(initData);\n        emit ModuleInstalled(moduleTypeId, address(module));\n    }\n\n    function unInstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n    {\n        IERC7579Module(module).onUninstall(initData);\n        emit ModuleUninstalled(moduleTypeId, address(module));\n    }\n}\n\ncontract BatchedExecUtil {\n    function tryExecute(Execution[] calldata executions) external {\n        uint256 length = executions.length;\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            _tryExecute(_exec.target, _exec.value, _exec.callData);\n        }\n    }\n\n    function execute(Execution[] calldata executions) external {\n        uint256 length = executions.length;\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            _execute(_exec.target, _exec.value, _exec.callData);\n        }\n    }\n\n    function executeReturn(Execution[] calldata executions)\n        external\n        returns (bytes[] memory result)\n    {\n        uint256 length = executions.length;\n        result = new bytes[](length);\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            result[i] = _execute(_exec.target, _exec.value, _exec.callData);\n        }\n    }\n\n    function tryExecuteReturn(Execution[] calldata executions)\n        external\n        returns (bool[] memory success, bytes[] memory result)\n    {\n        uint256 length = executions.length;\n        result = new bytes[](length);\n        success = new bool[](length);\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            (success[i], result[i]) = _tryExecute(_exec.target, _exec.value, _exec.callData);\n        }\n    }\n\n    function _execute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory result)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    function _tryExecute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bool success, bytes memory result)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            success := call(gas(), target, value, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n}\n\ncontract Safe7579DCUtil is ModuleInstallUtil, BatchedExecUtil {\n    function staticCall(address target, bytes memory data) external view {\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            let success := staticcall(gas(), target, add(data, 0x20), mload(data), 0x00, 0x00)\n            returndatacopy(ptr, 0x00, returndatasize())\n            if success { return(ptr, returndatasize()) }\n            revert(ptr, returndatasize())\n        }\n    }\n}\n"},"src/core/AccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { HandlerContext } from \"@safe-global/safe-contracts/contracts/handler/HandlerContext.sol\";\nimport { AccountBase } from \"erc7579/core/AccountBase.sol\";\n\n/**\n * Implements AccessControl for Safe7579 adapter.\n * Since Safe7579 Adapter is installed as a fallback handler on the safe account, we are making use\n * of handlercontext (ERC2771)\n * @author zeroknots.eth | rhinestone.wtf\n */\nabstract contract AccessControl is HandlerContext, AccountBase {\n    modifier onlyEntryPointOrSelf() virtual override {\n        if (!(_msgSender() == entryPoint() || msg.sender == _msgSender())) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    modifier onlyEntryPoint() virtual override {\n        if (_msgSender() != entryPoint()) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    modifier onlySelf() virtual {\n        if (msg.sender != _msgSender()) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    function entryPoint() public view virtual override returns (address) {\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n    }\n}\n"},"src/core/Initializer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ISafe7579 } from \"../ISafe7579.sol\";\nimport { ISafe } from \"../interfaces/ISafe.sol\";\nimport \"../DataTypes.sol\";\nimport { ModuleInstallUtil } from \"../utils/DCUtil.sol\";\nimport { ModuleManager } from \"./ModuleManager.sol\";\n\nimport {\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_HOOK,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_FALLBACK,\n    MODULE_TYPE_PREVALIDATION_HOOK_ERC1271,\n    MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n} from \"erc7579/interfaces/IERC7579Module.sol\";\nimport { IERC7484 } from \"../interfaces/IERC7484.sol\";\nimport { SentinelList4337Lib } from \"sentinellist/SentinelList4337.sol\";\nimport { SentinelListLib } from \"sentinellist/SentinelList.sol\";\n\n/**\n * Functions that can be used to initialze Safe7579 for a Safe Account\n * @author zeroknots.eth | rhinestone.wtf\n */\nabstract contract Initializer is ISafe7579, ModuleManager {\n    using SentinelList4337Lib for SentinelList4337Lib.SentinelList;\n\n    event Safe7579Initialized(address indexed safe);\n\n    error InvalidInitData(address safe);\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function initializeAccountWithValidators(ModuleInit[] calldata validators)\n        external\n        override\n        onlyEntryPointOrSelf\n    {\n        if (!$validators.alreadyInitialized({ account: msg.sender })) {\n            // this will revert if already initialized\n            $validators.init({ account: msg.sender });\n            uint256 length = validators.length;\n            for (uint256 i; i < length; i++) {\n                ModuleInit calldata validator = validators[i];\n                // Ensure the module type is validator\n                if (validator.moduleType != MODULE_TYPE_VALIDATOR) {\n                    revert InvalidModuleType(validator.module, validator.moduleType);\n                }\n                $validators.push({ account: msg.sender, newEntry: validator.module });\n                // @dev No events emitted here. Launchpad is expected to do this.\n                // at this point, the safeproxy singleton is not yet updated to the SafeSingleton\n                // calling execTransactionFromModule is not available yet.\n            }\n            emit Safe7579Initialized(msg.sender);\n        }\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function initializeAccount(\n        ModuleInit[] calldata modules,\n        RegistryInit calldata registryInit\n    )\n        external\n        onlyEntryPointOrSelf\n    {\n        _configureRegistry(registryInit.registry, registryInit.attesters, registryInit.threshold);\n        // this will revert if already initialized\n        _initModules(modules);\n    }\n\n    /**\n     * _initModules may be used via launchpad deploymet or directly by already deployed Safe\n     * accounts\n     */\n    function _initModules(ModuleInit[] calldata modules) internal {\n        bytes memory moduleInitData;\n        uint256 length = modules.length;\n        bool validatorsInitialized = $validators.alreadyInitialized({ account: msg.sender });\n\n        // Initialize validators list if needed\n        if (!validatorsInitialized) {\n            $validators.init({ account: msg.sender });\n        }\n\n        // This will revert if already initialized.\n        $executors.init({ account: msg.sender });\n\n        for (uint256 i; i < length; i++) {\n            ModuleInit calldata module = modules[i];\n            uint256 moduleType = module.moduleType;\n\n            if (module.moduleType == MODULE_TYPE_VALIDATOR) {\n                if (validatorsInitialized) {\n                    revert InvalidInitData(msg.sender);\n                }\n                // enable module on Safe7579, initialize module via Safe, emit events\n                moduleInitData = _installValidator(module.module, module.initData);\n            } else if (module.moduleType == MODULE_TYPE_EXECUTOR) {\n                // enable module on Safe7579, initialize module via Safe, emit events\n                moduleInitData = _installExecutor(module.module, module.initData);\n            } else if (module.moduleType == MODULE_TYPE_FALLBACK) {\n                // enable module on Safe7579, initialize module via Safe, emit events\n                moduleInitData = _installFallbackHandler(module.module, module.initData);\n            } else if (module.moduleType == MODULE_TYPE_HOOK) {\n                // enable module on Safe7579, initialize module via Safe, emit events\n                moduleInitData = _installHook(module.module, module.initData);\n            } else if (\n                module.moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n                    || module.moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n            ) {\n                // Handle pre-validation hooks or other module types\n                moduleInitData = _installPreValidationHook(module.module, module.initData);\n            } else {\n                revert InvalidModuleType(module.module, moduleType);\n            }\n\n            // Initialize Module via Safe for standard module types\n            _delegatecall({\n                safe: ISafe(msg.sender),\n                target: UTIL,\n                callData: abi.encodeCall(\n                    ModuleInstallUtil.installModule, (moduleType, module.module, moduleInitData)\n                )\n            });\n        }\n\n        emit Safe7579Initialized(msg.sender);\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function setRegistry(\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    )\n        external\n        onlySelf\n    {\n        _configureRegistry(registry, attesters, threshold);\n    }\n}\n"},"src/core/SafeOp.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport {\n    PackedUserOperation,\n    UserOperationLib\n} from \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\nimport { SAFE_OP_TYPEHASH, ISafeOp } from \"../interfaces/ISafeOp.sol\";\nimport { LibBytes } from \"solady/utils/LibBytes.sol\";\n\nabstract contract SafeOp is ISafeOp {\n    using UserOperationLib for PackedUserOperation;\n    using LibBytes for bytes;\n\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    /**\n     * @dev Decodes an ERC-4337 user operation into a Safe operation.\n     * @param userOp The ERC-4337 user operation.\n     * @return operationData Encoded EIP-712 Safe operation data bytes used for signature\n     * verification.\n     * @return validAfter The timestamp the user operation is valid from.\n     * @return validUntil The timestamp the user operation is valid until.\n     * @return signatures The Safe owner signatures extracted from the user operation.\n     */\n    function getSafeOp(\n        PackedUserOperation memory userOp,\n        address entryPoint\n    )\n        public\n        view\n        returns (\n            bytes memory operationData,\n            uint48 validAfter,\n            uint48 validUntil,\n            bytes memory signatures\n        )\n    {\n        // Extract additional Safe operation fields from the user operation signature which is\n        // encoded as:\n        // `abi.encodePacked(validAfter, validUntil, signatures)`\n        // This is how we can extract signature components from memory\n        {\n            bytes memory sig = userOp.signature;\n            validAfter = uint48(bytes6(sig.slice(0, 6)));\n            validUntil = uint48(bytes6(sig.slice(6, 12)));\n            signatures = sig.slice(12);\n        }\n\n        // It is important that **all** user operation fields are represented in the `SafeOp` data\n        // somehow, to prevent\n        // user operations from being submitted that do not fully respect the user preferences. The\n        // only exception is\n        // the `signature` bytes. Note that even `initCode` needs to be represented in the operation\n        // data, otherwise\n        // it can be replaced with a more expensive initialization that would charge the user\n        // additional fees.\n        {\n            // In order to work around Solidity \"stack too deep\" errors related to too many stack\n            // variables, manually\n            // encode the `SafeOp` fields into a memory `struct` for computing the EIP-712\n            // struct-hash. This works\n            // because the `EncodedSafeOpStruct` struct has no \"dynamic\" fields so its memory layout\n            // is identical to the\n            // result of `abi.encode`-ing the individual fields.\n            EncodedSafeOpStruct memory encodedSafeOp = EncodedSafeOpStruct({\n                typeHash: SAFE_OP_TYPEHASH,\n                safe: userOp.sender,\n                nonce: userOp.nonce,\n                initCodeHash: keccak256(userOp.initCode),\n                callDataHash: keccak256(userOp.callData),\n                verificationGasLimit: uint128(unpackVerificationGasLimit(userOp)),\n                callGasLimit: uint128(unpackCallGasLimit(userOp)),\n                preVerificationGas: userOp.preVerificationGas,\n                maxPriorityFeePerGas: uint128(unpackMaxPriorityFeePerGas(userOp)),\n                maxFeePerGas: uint128(unpackMaxFeePerGas(userOp)),\n                paymasterAndDataHash: keccak256(userOp.paymasterAndData),\n                validAfter: validAfter,\n                validUntil: validUntil,\n                entryPoint: entryPoint\n            });\n\n            bytes32 safeOpStructHash;\n            // solhint-disable-next-line no-inline-assembly\n            assembly (\"memory-safe\") {\n                // Since the `encodedSafeOp` value's memory layout is identical to the result of\n                // `abi.encode`-ing the\n                // individual `SafeOp` fields, we can pass it directly to `keccak256`. Additionally,\n                // there are 14\n                // 32-byte fields to hash, for a length of `14 * 32 = 448` bytes.\n                safeOpStructHash := keccak256(encodedSafeOp, 448)\n            }\n\n            operationData =\n                abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeOpStructHash);\n        }\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, block.chainid, this));\n    }\n\n    function unpackVerificationGasLimit(PackedUserOperation memory userOp)\n        private\n        pure\n        returns (uint256)\n    {\n        return UserOperationLib.unpackHigh128(userOp.accountGasLimits);\n    }\n\n    function unpackCallGasLimit(PackedUserOperation memory userOp) private pure returns (uint256) {\n        return UserOperationLib.unpackLow128(userOp.accountGasLimits);\n    }\n\n    function unpackMaxPriorityFeePerGas(PackedUserOperation memory userOp)\n        private\n        pure\n        returns (uint256)\n    {\n        return UserOperationLib.unpackHigh128(userOp.gasFees);\n    }\n\n    function unpackMaxFeePerGas(PackedUserOperation memory userOp) private pure returns (uint256) {\n        return UserOperationLib.unpackLow128(userOp.gasFees);\n    }\n}\n"},"src/interfaces/ISafe.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface ISafe {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    )\n        external;\n\n    /**\n     * @dev Allows a Module to execute a Safe transaction without any further confirmations.\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     */\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    )\n        external\n        returns (bool success);\n\n    /**\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)\n     * and return data\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     * @return success Boolean flag indicating if the call succeeded.\n     * @return returnData Data returned by the call.\n     */\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    )\n        external\n        returns (bool success, bytes memory returnData);\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert\n     * otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract\n     * signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    )\n        external\n        view;\n\n    function signedMessages(bytes32) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\n     * @return bytes32 The domain separator hash.\n     */\n    function domainSeparator() external view returns (bytes32);\n\n    function VERSION() external pure returns (string memory);\n\n    function getStorageAt(uint256 offset, uint256 length) external view returns (bytes memory);\n\n    /**\n     * @dev Returns array of modules.\n     * @param start Start of the page.\n     * @param pageSize Maximum number of modules that should be returned.\n     * @return array Array of modules.\n     * @return next Start of the next page.\n     */\n    function getModulesPaginated(\n        address start,\n        uint256 pageSize\n    )\n        external\n        view\n        returns (address[] memory array, address next);\n\n    /**\n     * @notice Enables the module `module` for the Safe.\n     * @dev This can only be done via a Safe transaction.\n     * @param module Module to be enabled.\n     */\n    function enableModule(address module) external;\n\n    function setFallbackHandler(address handler) external;\n\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external;\n}\n"},"src/ISafe7579.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./DataTypes.sol\";\nimport { IERC7579Account } from \"./interfaces/IERC7579Account.sol\";\nimport { ModeCode } from \"./lib/ModeLib.sol\";\nimport { PackedUserOperation } from\n    \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\nimport { ISafeOp } from \"./interfaces/ISafeOp.sol\";\n\n/**\n * @title ERC7579 Adapter for Safe accounts.\n * creates full ERC7579 compliance to Safe accounts\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\ninterface ISafe7579 is IERC7579Account, ISafeOp {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         Validation                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * ERC4337 v0.7 validation function\n     * @dev expects that a ERC7579 validator module is encoded within the UserOp nonce.\n     *         if no validator module is provided, it will fallback to validate the transaction with\n     *         Safe's signers\n     */\n    function validateUserOp(\n        PackedUserOperation memory userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        returns (uint256 packedValidSig);\n\n    /**\n     * Will use Safe's signed messages or checkSignatures features or ERC7579 validation modules\n     * if no signature is provided, it makes use of Safe's signedMessages\n     * if address(0) or a non-installed validator module is provided, it will use Safe's\n     * checkSignatures\n     * if a valid validator module is provided, it will use the module's validateUserOp function\n     *    @param hash message hash of ERC1271 request\n     *    @param data abi.encodePacked(address validationModule, bytes signatures)\n     */\n    function isValidSignature(\n        bytes32 hash,\n        bytes memory data\n    )\n        external\n        view\n        returns (bytes4 magicValue);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         Executions                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Executes a transaction on behalf of the Safe account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @dev AccessControl: only Self of Entrypoint can install modules\n     * Safe7579 supports the following feature set:\n     *    CallTypes:\n     *             - CALLTYPE_SINGLE\n     *             - CALLTYPE_BATCH\n     *             - CALLTYPE_DELEGATECALL\n     *    ExecTypes:\n     *             - EXECTYPE_DEFAULT (revert if not successful)\n     *             - EXECTYPE_TRY\n     *    If a different mode is selected, this function will revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function execute(ModeCode mode, bytes memory executionCalldata) external;\n\n    /**\n     * @dev Executes a transaction on behalf of the Safe account.\n     *         This function is intended to be called by executor modules\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @dev AccessControl: only enabled executor modules\n     * Safe7579 supports the following feature set:\n     *    CallTypes:\n     *             - CALLTYPE_SINGLE\n     *             - CALLTYPE_BATCH\n     *             - CALLTYPE_DELEGATECALL\n     *    ExecTypes:\n     *             - EXECTYPE_DEFAULT (revert if not successful)\n     *             - EXECTYPE_TRY\n     *    If a different mode is selected, this function will revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes memory executionCalldata\n    )\n        external\n        returns (bytes[] memory returnDatas);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      Manage Modules                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Installs a 7579 Module of a certain type on the smart account\n     * @dev The module has to be initialized from msg.sender == SafeProxy, we thus use a\n     *    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579\n     *    module and emits the ModuleInstall/ModuleUnintall events\n     * @dev AccessControl: only Self of Entrypoint can install modules\n     * @dev If the safe set a registry, ERC7484 registry will be queried before installing\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @param moduleType the module type ID according the ERC-7579 spec\n     *                   Note: MULTITYPE_MODULE (uint(0)) is a special type to install a module with\n     *                         multiple types\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(uint256 moduleType, address module, bytes memory initData) external;\n\n    /**\n     * Uninstalls a Module of a certain type on the smart account.\n     * @dev The module has to be initialized from msg.sender == SafeProxy, we thus use a\n     *    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579\n     *    module and emits the ModuleInstall/ModuleUnintall events\n     * @dev AccessControl: only Self of Entrypoint can install modules\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @param moduleType the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleType,\n        address module,\n        bytes memory deInitData\n    )\n        external;\n\n    /**\n     * Emergency uninstall a hook module\n     * @dev Allows uninstalling hooks without triggering hooks during the uninstall process,\n     *      secured by a timelock. Usable on regular hooks and prevalidation hooks\n     * @param data EmergencyUninstall struct\n     * @param signature signature of the data, to be validated on a validator module or by\n     *      safe.checkSignatures if no validator module is supplied/installed\n     */\n    function emergencyUninstallHook(\n        EmergencyUninstall calldata data,\n        bytes calldata signature\n    )\n        external;\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleType the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleType,\n        address module,\n        bytes memory additionalContext\n    )\n        external\n        view\n        returns (bool);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   Initialize Safe7579                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * This function can be called by the Launchpad.initSafe7579() or by already existing Safes that\n     * want to use Safe7579\n     * if this is called by the Launchpad, it is expected that launchpadValidators() was called\n     * previously, and the param validators is empty\n     * @param modules Array of modules to initialize with their respective types\n     * @param registryInit (OPTIONAL) registry, attesters and threshold for IERC7484 Registry\n     *                    If not provided, the registry will be set to the zero address, and no\n     *                    registry checks will be performed\n     */\n    function initializeAccount(\n        ModuleInit[] calldata modules,\n        RegistryInit calldata registryInit\n    )\n        external;\n\n    /**\n     * This function is intended to be called by Launchpad.validateUserOp()\n     * @dev it will initialize the SentinelList4337 list for validators, and sstore all\n     * validators\n     * @dev Since this function has to be 4337 compliant (storage access), only validator storage is  acccess\n     * @dev Note: this function DOES NOT call onInstall() on the validator modules or emit\n     * ModuleInstalled events. this has to be done by the launchpad\n     */\n    function initializeAccountWithValidators(ModuleInit[] memory validators) external;\n\n    /**\n     * Configure the Safe7579 with a IERC7484 registry\n     * @param registry IERC7484 registry\n     * @param attesters list of attesters\n     * @param threshold number of attesters required\n     */\n    function setRegistry(IERC7484 registry, address[] memory attesters, uint8 threshold) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   Query Account Details                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    function getValidatorsPaginated(\n        address cursor,\n        uint256 pageSize\n    )\n        external\n        view\n        returns (address[] memory array, address next);\n\n    /**\n     * Get the current active global hook\n     */\n    function getActiveHook() external view returns (address hook);\n\n    function getExecutorsPaginated(\n        address cursor,\n        uint256 size\n    )\n        external\n        view\n        returns (address[] memory array, address next);\n\n    /**\n     * Get the current active prevalidation hook for the given module type\n     * @param moduleType the prevalidation hook type\n     */\n    function getPrevalidationHook(uint256 moduleType) external view returns (address hook);\n\n    /**\n     * Get the current active fallback handler and call type for the given selector\n     * @param selector the function selector\n     */\n    function getFallbackHandlerBySelector(bytes4 selector)\n        external\n        view\n        returns (CallType, address);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        Query Misc                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Safe7579 is using validator selection encoding in the userop nonce.\n     * to make it easier for SDKs / devs to integrate, this function can be\n     * called to get the next nonce for a specific validator\n     * @param safe address of safe account\n     * @param validator ERC7579 validator to encode\n     */\n    function getNonce(address safe, address validator) external view returns (uint256 nonce);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       Custom Errors                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    error InvalidModule(address module);\n    error InvalidModuleType(address module, uint256 moduleType);\n    error ModuleNotInstalled(address module, uint256 moduleType);\n    error InvalidNonce();\n\n    // fallback handlers\n    error InvalidInput();\n    error InvalidCallType(CallType callType);\n    error NoFallbackHandler(bytes4 msgSig);\n    error InvalidFallbackHandler(bytes4 msgSig);\n    error FallbackInstalled(bytes4 msgSig);\n\n    // Hooks\n    error HookAlreadyInstalled(address currentHook);\n    error InvalidHookType();\n    error EmergencyTimeLockNotExpired();\n    error EmergencyUninstallSigError();\n\n    event EmergencyHookUninstallRequest(address hook, uint256 time);\n    event EmergencyHookUninstallRequestReset(address hook, uint256 time);\n\n    // PreValidation Hooks=\n    error PreValidationHookAlreadyInstalled(address currentHook, uint256 moduleType);\n\n    // Registry Adapter\n    event ERC7484RegistryConfigured(address indexed smartAccount, IERC7484 indexed registry);\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/PackedUserOperation.sol\";\nimport {calldataKeccak, min} from \"./Helpers.sol\";\n\n/**\n * Utility functions helpful when working with UserOperation structs.\n */\nlibrary UserOperationLib {\n\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\n    /**\n     * Get sender from user operation data.\n     * @param userOp - The user operation data.\n     */\n    function getSender(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {\n            data := calldataload(userOp)\n        }\n        return address(uint160(data));\n    }\n\n    /**\n     * Relayer/block builder might submit the TX with higher priorityFee,\n     * but the user should not pay above what he signed for.\n     * @param userOp - The user operation data.\n     */\n    function gasPrice(\n        PackedUserOperation calldata userOp\n    ) internal view returns (uint256) {\n        unchecked {\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    /**\n     * Pack the user operation data into bytes for hashing.\n     * @param userOp - The user operation data.\n     */\n    function encode(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes memory ret) {\n        address sender = getSender(userOp);\n        uint256 nonce = userOp.nonce;\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\n        bytes32 accountGasLimits = userOp.accountGasLimits;\n        uint256 preVerificationGas = userOp.preVerificationGas;\n        bytes32 gasFees = userOp.gasFees;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\n\n        return abi.encode(\n            sender, nonce,\n            hashInitCode, hashCallData,\n            accountGasLimits, preVerificationGas, gasFees,\n            hashPaymasterAndData\n        );\n    }\n\n    function unpackUints(\n        bytes32 packed\n    ) internal pure returns (uint256 high128, uint256 low128) {\n        return (uint128(bytes16(packed)), uint128(uint256(packed)));\n    }\n\n    //unpack just the high 128-bits from a packed value\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\n        return uint256(packed) >> 128;\n    }\n\n    // unpack just the low 128-bits from a packed value\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\n        return uint128(uint256(packed));\n    }\n\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.gasFees);\n    }\n\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.gasFees);\n    }\n\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.accountGasLimits);\n    }\n\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.accountGasLimits);\n    }\n\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\n    }\n\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\n    }\n\n    function unpackPaymasterStaticFields(\n        bytes calldata paymasterAndData\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\n        return (\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\n        );\n    }\n\n    /**\n     * Hash the user operation data.\n     * @param userOp - The user operation data.\n     */\n    function hash(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes32) {\n        return keccak256(encode(userOp));\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/Helpers.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\n\n /*\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n  * must return this value in case of signature failure, instead of revert.\n  */\nuint256 constant SIG_VALIDATION_FAILED = 1;\n\n\n/*\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n * return this value on success.\n */\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\n\n\n/**\n * Returned data from validateUserOp.\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\n * parsed by `_parseValidationData`.\n * @param aggregator  - address(0) - The account validated the signature by itself.\n *                      address(1) - The account failed to validate the signature.\n *                      otherwise - This is an address of a signature aggregator that must\n *                                  be used to validate the signature.\n * @param validAfter  - This UserOp is valid only after this timestamp.\n * @param validaUntil - This UserOp is valid only up to this timestamp.\n */\nstruct ValidationData {\n    address aggregator;\n    uint48 validAfter;\n    uint48 validUntil;\n}\n\n/**\n * Extract sigFailed, validAfter, validUntil.\n * Also convert zero validUntil to type(uint48).max.\n * @param validationData - The packed validation data.\n */\nfunction _parseValidationData(\n    uint256 validationData\n) pure returns (ValidationData memory data) {\n    address aggregator = address(uint160(validationData));\n    uint48 validUntil = uint48(validationData >> 160);\n    if (validUntil == 0) {\n        validUntil = type(uint48).max;\n    }\n    uint48 validAfter = uint48(validationData >> (48 + 160));\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * Helper to pack the return value for validateUserOp.\n * @param data - The ValidationData to pack.\n */\nfunction _packValidationData(\n    ValidationData memory data\n) pure returns (uint256) {\n    return\n        uint160(data.aggregator) |\n        (uint256(data.validUntil) << 160) |\n        (uint256(data.validAfter) << (160 + 48));\n}\n\n/**\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\n * @param sigFailed  - True for signature failure, false for success.\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\n * @param validAfter - First timestamp this UserOperation is valid.\n */\nfunction _packValidationData(\n    bool sigFailed,\n    uint48 validUntil,\n    uint48 validAfter\n) pure returns (uint256) {\n    return\n        (sigFailed ? 1 : 0) |\n        (uint256(validUntil) << 160) |\n        (uint256(validAfter) << (160 + 48));\n}\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n */\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let mem := mload(0x40)\n            let len := data.length\n            calldatacopy(mem, data.offset, len)\n            ret := keccak256(mem, len)\n        }\n    }\n\n\n/**\n * The minimum of two numbers.\n * @param a - First number.\n * @param b - Second number.\n */\n    function min(uint256 a, uint256 b) pure returns (uint256) {\n        return a < b ? a : b;\n    }\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IEntryPoint.sol":{"content":"/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request.\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\n     * @param sender        - The account that generates this request.\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\n     * @param nonce         - The nonce value from the request.\n     * @param success       - True if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\n     *                        validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * Account \"sender\" was deployed.\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender     - The account that is deployed\n     * @param factory    - The factory used to deploy this account (in the initCode)\n     * @param paymaster  - The paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * An event emitted if the UserOperation Paymaster's \"postOp\" call reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event PostOpRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     */\n    event UserOperationPrefundTooLow(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce\n    );\n\n    /**\n     * An event emitted by handleOps(), before starting the execution loop.\n     * Any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * A custom revert error of handleOps, to identify the offending op.\n     * Should be caught in off-chain handleOps simulation and not happen on-chain.\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. The string starts with a unique code \"AAmn\",\n     *                  where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *                  so a failure can be attributed to the correct entity.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * A custom revert error of handleOps, to report a revert by account or paymaster.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\n     * @param inner   - data from inner cought revert reason\n     * @dev note that inner is truncated to 2048 bytes\n     */\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\n\n    error PostOpReverted(bytes returnData);\n\n    /**\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\n     * @param aggregator The aggregator that failed to verify the signature\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    // Return value of getSenderAddress.\n    error SenderAddressResult(address sender);\n\n    // UserOps handled, per aggregator.\n    struct UserOpsPerAggregator {\n        PackedUserOperation[] userOps;\n        // Aggregator address\n        IAggregator aggregator;\n        // Aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * No signature aggregator is used.\n     * If any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops         - The operations to execute.\n     * @param beneficiary - The address to receive the fees.\n     */\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\n     * @param beneficiary      - The address to receive the fees.\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Generate a request Id - unique identifier for this request.\n     * The request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     * @param userOp - The user operation to generate the request ID for.\n     * @return hash the hash of this UserOperation\n     */\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Gas and return values during simulation.\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\n     * @param prefund          - The required prefund for this operation\n     * @param accountValidationData   - returned validationData from account.\n     * @param paymasterValidationData - return validationData from paymaster.\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bytes paymasterContext;\n    }\n\n    /**\n     * Returned aggregated signature info:\n     * The aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * This method always revert, and returns the address in SenderAddressResult error\n     * @param initCode - The constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    error DelegateAndRevert(bool success, bytes ret);\n\n    /**\n     * Helper method for dry-run testing.\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\n     *  actual EntryPoint code is less convenient.\n     * @param target a target contract to make a delegatecall from entrypoint\n     * @param data data to pass to target in a delegatecall\n     */\n    function delegateAndRevert(address target, bytes calldata data) external;\n}\n"},"src/interfaces/IERC1271.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.20;\n\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _dataHash Arbitrary length data signed on behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc >\n     * 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(\n        bytes32 _dataHash,\n        bytes calldata _signature\n    )\n        external\n        view\n        returns (bytes4);\n}\n"},"src/core/SupportViewer.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport {\n    CallType,\n    ExecType,\n    ModeCode,\n    EXECTYPE_DEFAULT,\n    EXECTYPE_TRY,\n    CALLTYPE_SINGLE,\n    CALLTYPE_BATCH,\n    CALLTYPE_DELEGATECALL\n} from \"../lib/ModeLib.sol\";\nimport {\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_HOOK,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_FALLBACK\n} from \"erc7579/interfaces/IERC7579Module.sol\";\nimport { IERC7579AccountView } from \"../interfaces/IERC7579Account.sol\";\n\nabstract contract SupportViewer is IERC7579AccountView {\n    function accountId() external pure returns (string memory accountImplementationId) {\n        return \"rhinestone.safe7579.v1.0.0\";\n    }\n\n    function supportsExecutionMode(ModeCode encodedMode) external pure returns (bool supported) {\n        CallType callType;\n        ExecType execType;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            callType := encodedMode\n            execType := shl(8, encodedMode)\n        }\n        if (callType == CALLTYPE_BATCH) supported = true;\n        else if (callType == CALLTYPE_SINGLE) supported = true;\n        else if (callType == CALLTYPE_DELEGATECALL) supported = true;\n        else return false;\n\n        if (supported && execType == EXECTYPE_DEFAULT) return supported;\n        else if (supported && execType == EXECTYPE_TRY) return supported;\n        else return false;\n    }\n\n    function supportsModule(uint256 moduleTypeId) external pure returns (bool) {\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) return true;\n        else if (moduleTypeId == MODULE_TYPE_EXECUTOR) return true;\n        else if (moduleTypeId == MODULE_TYPE_FALLBACK) return true;\n        else if (moduleTypeId == MODULE_TYPE_HOOK) return true;\n        else return false;\n    }\n}\n"},"src/DataTypes.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\nimport { IERC7484 } from \"./interfaces/IERC7484.sol\";\nimport { CallType } from \"./lib/ModeLib.sol\";\n\nstruct FallbackHandler {\n    address handler;\n    CallType calltype;\n}\n\nstruct ModuleInit {\n    address module;\n    bytes initData;\n    uint256 moduleType;\n}\n\nstruct RegistryInit {\n    IERC7484 registry;\n    address[] attesters;\n    uint8 threshold;\n}\n\nstruct EmergencyUninstall {\n    address hook;\n    uint256 hookType;\n    bytes deInitData;\n    uint256 nonce;\n}\n"},"src/lib/EIP712.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport { EmergencyUninstall } from \"../DataTypes.sol\";\n\nlibrary EIP712 {\n    // keccak256(\"SafeMessage(bytes message)\");\n    bytes32 internal constant SAFE_MSG_TYPEHASH =\n        0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;\n\n    // forgefmt: disable-next-line\n    // keccak256(\"EmergencyUninstall(address hook,uint256 hookType,bytes deInitData,uint256 nonce)\");\n    bytes32 internal constant EMERGENCY_UNINSTALL_TYPE_HASH =\n        0xd3ddfc12654178cc44d4a7b6b969cfdce7ffe6342326ba37825314cffa0fba9c;\n\n    function encodeMessageData(\n        bytes32 domainSeparator,\n        bytes memory message\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(\n            bytes1(0x19),\n            bytes1(0x01),\n            domainSeparator,\n            keccak256(abi.encode(SAFE_MSG_TYPEHASH, keccak256(message)))\n        );\n    }\n\n    function encodeEmergencyUninstallData(\n        bytes32 domainSeparator,\n        EmergencyUninstall calldata data\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(\n            bytes1(0x19),\n            bytes1(0x01),\n            domainSeparator,\n            keccak256(\n                abi.encode(\n                    EMERGENCY_UNINSTALL_TYPE_HASH,\n                    data.hook,\n                    data.hookType,\n                    keccak256(data.deInitData),\n                    data.nonce\n                )\n            )\n        );\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"src/interfaces/IERC7579Module.sol":{"content":"pragma solidity ^0.8.20;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\n\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC1271 = 8;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC4337 = 9;\n\ninterface IModule {\n    /**\n     * @dev This function is called by the smart account during installation of the module\n     * @param data arbitrary data that may be required on the module during `onInstall`\n     * initialization\n     *\n     * MUST revert on error (i.e. if module is already enabled)\n     */\n    function onInstall(bytes calldata data) external;\n\n    /**\n     * @dev This function is called by the smart account during uninstallation of the module\n     * @param data arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization\n     *\n     * MUST revert on error\n     */\n    function onUninstall(bytes calldata data) external;\n\n    /**\n     * @dev Returns boolean value if module is a certain type\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *\n     * MUST return true if the module is of the given type and false otherwise\n     */\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * @dev Returns if the module was already initialized for a provided smartaccount\n     */\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n\ninterface IValidator is IModule {\n    /**\n     * @dev Validates a transaction on behalf of the account.\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\n     * The MSA MUST clean up the userOp before sending it to the validator.\n     * @param userOpHash The hash of the user operation to be validated\n     * @return return value according to ERC-4337\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        returns (uint256);\n\n    /**\n     * Validator can be used for ERC-1271 validation\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IExecutor is IModule { }\n\ninterface IHook is IModule {\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        returns (bytes memory hookData);\n\n    function postCheck(bytes calldata hookData) external;\n}\n\ninterface IFallback is IModule { }\n"},"node_modules/@safe-global/safe-contracts/contracts/handler/HandlerContext.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Handler Context - Allows the fallback handler to extract addition context from the calldata\n * @dev The fallback manager appends the following context to the calldata:\n *      1. Fallback manager caller address (non-padded)\n * based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f8cc8b844a9f92f63dc55aa581f7d643a1bc5ac1/contracts/metatx/ERC2771Context.sol\n * @author Richard Meissner - @rmeissner\n */\nabstract contract HandlerContext {\n    /**\n     * @notice Allows fetching the original caller address.\n     * @dev This is only reliable in combination with a FallbackManager that supports this (e.g. Safe contract >=1.3.0).\n     *      When using this functionality make sure that the linked _manager (aka msg.sender) supports this.\n     *      This function does not rely on a trusted forwarder. Use the returned value only to\n     *      check information against the calling manager.\n     * @return sender Original caller address.\n     */\n    function _msgSender() internal pure returns (address sender) {\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\n        }\n    }\n\n    /**\n     * @notice Returns the FallbackManager address\n     * @return Fallback manager address\n     */\n    function _manager() internal view returns (address) {\n        return msg.sender;\n    }\n}\n"},"node_modules/erc7579/src/core/AccountBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/**\n * @title reference implementation of the minimal modular smart account with Hook Extension\n * @author zeroknots.eth | rhinestone.wtf\n */\ncontract AccountBase {\n    error AccountAccessUnauthorized();\n\n    /////////////////////////////////////////////////////\n    // Access Control\n    ////////////////////////////////////////////////////\n\n    modifier onlyEntryPointOrSelf() virtual {\n        if (!(msg.sender == entryPoint() || msg.sender == address(this))) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    modifier onlyEntryPoint() virtual {\n        if (msg.sender != entryPoint()) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    function entryPoint() public view virtual returns (address) {\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n    }\n\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\n    /// Subclass MAY override this modifier for better funds management.\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\n    /// it will not be required to send again)\n    ///\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if missingAccountFunds {\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\n            }\n        }\n    }\n}\n"},"src/core/ModuleManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { SentinelListLib } from \"sentinellist/SentinelList.sol\";\nimport { SentinelList4337Lib } from \"sentinellist/SentinelList4337.sol\";\nimport { IModule, IHook } from \"../interfaces/IERC7579Module.sol\";\nimport { ISafe } from \"../interfaces/ISafe.sol\";\nimport { ISafe7579 } from \"../ISafe7579.sol\";\nimport \"../DataTypes.sol\";\n\nimport { RegistryAdapter } from \"./RegistryAdapter.sol\";\nimport { AccessControl } from \"./AccessControl.sol\";\nimport { CallType, CALLTYPE_STATIC, CALLTYPE_SINGLE } from \"../lib/ModeLib.sol\";\nimport {\n    IValidator,\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_FALLBACK,\n    MODULE_TYPE_HOOK,\n    MODULE_TYPE_PREVALIDATION_HOOK_ERC1271,\n    MODULE_TYPE_PREVALIDATION_HOOK_ERC4337,\n    IPreValidationHookERC1271,\n    IPreValidationHookERC4337\n} from \"erc7579/interfaces/IERC7579Module.sol\";\nimport { PackedUserOperation } from\n    \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\nimport { EIP712 } from \"../lib/EIP712.sol\";\nimport { IERC1271 } from \"../interfaces/IERC1271.sol\";\n\n/**\n * @title ModuleManager\n * Contract that implements ERC7579 Module compatibility for Safe accounts\n * @author zeroknots.eth | rhinestone.wtf\n * @dev All Module types  are handled within this\n * contract. To make it a bit easier to read, the contract is split into different sections:\n * - Validator Modules\n * - Executor Modules\n * - Fallback Modules\n * - Hook Modules\n * Note: the Storage mappings for each section, are not listed on the very top, but in the\n * respective section\n */\nabstract contract ModuleManager is ISafe7579, AccessControl, RegistryAdapter {\n    using SentinelList4337Lib for SentinelList4337Lib.SentinelList;\n\n    /// @dev Nonces used for signature replay protection\n    mapping(uint256 nonce => mapping(address smartAccount => bool isUsed)) internal $nonces;\n\n    /// @dev The timelock period for emergency hook uninstallation.\n    uint256 internal constant _EMERGENCY_TIMELOCK = 1 days;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     VALIDATOR MODULES                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    // No mapping account => list necessary. this sentinellist flavour handles associated storage to\n    // smart account itself to comply with 4337 storage restrictions\n    SentinelList4337Lib.SentinelList internal $validators;\n\n    /**\n     * install and initialize validator module\n     * @dev This function will install a validator module and return the moduleInitData\n     * @param validator address of the validator module\n     * @param data initialization data for the validator module\n     */\n    function _installValidator(\n        address validator,\n        bytes calldata data\n    )\n        internal\n        withRegistry(validator, MODULE_TYPE_VALIDATOR)\n        withCorrectModuleType(validator, MODULE_TYPE_VALIDATOR)\n        returns (bytes memory moduleInitData)\n    {\n        $validators.push({ account: msg.sender, newEntry: validator });\n        return data;\n    }\n\n    /**\n     * Uninstall validator module\n     * @dev This function does not prevent the user from uninstalling all validator modules.\n     * Since the Safe7579 signature validation can fallback to Safe's checkSignature()\n     * function, it is okay, if all validator modules are removed.\n     * This does not brick the account\n     */\n    function _uninstallValidator(\n        address validator,\n        bytes calldata data\n    )\n        internal\n        returns (bytes memory moduleInitData)\n    {\n        address prev;\n        (prev, moduleInitData) = abi.decode(data, (address, bytes));\n        $validators.pop({ account: msg.sender, prevEntry: prev, popEntry: validator });\n    }\n\n    /**\n     * Helper function that will calculate storage slot for\n     * validator address within the linked list in ValidatorStorageHelper\n     * and use Safe's getStorageAt() to read 32bytes from Safe's storage\n     */\n    function _isValidatorInstalled(address validator)\n        internal\n        view\n        virtual\n        returns (bool isInstalled)\n    {\n        isInstalled = $validators.contains({ account: msg.sender, entry: validator });\n    }\n\n    /**\n     * Get paginated list of installed validators\n     */\n    function getValidatorsPaginated(\n        address cursor,\n        uint256 pageSize\n    )\n        external\n        view\n        virtual\n        returns (address[] memory array, address next)\n    {\n        return $validators.getEntriesPaginated({\n            account: msg.sender,\n            start: cursor,\n            pageSize: pageSize\n        });\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      EXECUTOR MODULES                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    SentinelList4337Lib.SentinelList internal $executors;\n\n    modifier onlyExecutorModule() {\n        if (!_isExecutorInstalled(_msgSender())) revert InvalidModule(_msgSender());\n        _;\n    }\n\n    /**\n     * Install and initialize executor module\n     * @dev This function will install an executor module and return the moduleInitData\n     * @param executor address of the executor module\n     * @param data initialization data for the executor module\n     */\n    function _installExecutor(\n        address executor,\n        bytes calldata data\n    )\n        internal\n        withRegistry(executor, MODULE_TYPE_EXECUTOR)\n        withCorrectModuleType(executor, MODULE_TYPE_EXECUTOR)\n        returns (bytes memory moduleInitData)\n    {\n        $executors.push({ account: msg.sender, newEntry: executor });\n        return data;\n    }\n\n    /**\n     * Uninstall executor module\n     * @dev This function will uninstall an executor module\n     * @param executor address of executor module to be uninstalled\n     * @param data abi encoded previous address and deinit data\n     */\n    function _uninstallExecutor(\n        address executor,\n        bytes calldata data\n    )\n        internal\n        returns (bytes memory moduleDeInitData)\n    {\n        address prev;\n        (prev, moduleDeInitData) = abi.decode(data, (address, bytes));\n        $executors.pop({ account: msg.sender, prevEntry: prev, popEntry: executor });\n    }\n\n    function _isExecutorInstalled(address executor)\n        internal\n        view\n        virtual\n        returns (bool isInstalled)\n    {\n        isInstalled = $executors.contains({ account: msg.sender, entry: executor });\n    }\n\n    /**\n     * Get paginated list of installed executors\n     */\n    function getExecutorsPaginated(\n        address cursor,\n        uint256 pageSize\n    )\n        external\n        view\n        virtual\n        returns (address[] memory array, address next)\n    {\n        return $executors.getEntriesPaginated({\n            account: msg.sender,\n            start: cursor,\n            pageSize: pageSize\n        });\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      FALLBACK MODULES                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    mapping(bytes4 selector => mapping(address smartAccount => FallbackHandler handlerConfig))\n        internal $fallbackStorage;\n\n    function _installFallbackHandler(\n        address handler,\n        bytes calldata params\n    )\n        internal\n        virtual\n        withRegistry(handler, MODULE_TYPE_FALLBACK)\n        withCorrectModuleType(handler, MODULE_TYPE_FALLBACK)\n        returns (bytes memory moduleInitData)\n    {\n        bytes4 functionSig;\n        CallType calltype;\n        (functionSig, calltype, moduleInitData) = abi.decode(params, (bytes4, CallType, bytes));\n\n        // disallow calls to onInstall or onUninstall.\n        // this could create a security issue\n        if (\n            functionSig == IModule.onInstall.selector || functionSig == IModule.onUninstall.selector\n        ) revert InvalidFallbackHandler(functionSig);\n\n        // disallow unsupported calltypes\n        if (calltype != CALLTYPE_SINGLE && calltype != CALLTYPE_STATIC) {\n            revert InvalidCallType(calltype);\n        }\n\n        if (_isFallbackHandlerInstalled(functionSig)) revert FallbackInstalled(functionSig);\n\n        FallbackHandler storage $fallbacks = $fallbackStorage[functionSig][msg.sender];\n        $fallbacks.calltype = calltype;\n        $fallbacks.handler = handler;\n    }\n\n    function _isFallbackHandlerInstalled(bytes4 functionSig) internal view virtual returns (bool) {\n        FallbackHandler storage $fallbacks = $fallbackStorage[functionSig][msg.sender];\n        return $fallbacks.handler != address(0);\n    }\n\n    function _uninstallFallbackHandler(\n        address module,\n        bytes calldata context\n    )\n        internal\n        virtual\n        returns (bytes memory moduleDeInitData)\n    {\n        bytes4 functionSig;\n        (functionSig, moduleDeInitData) = abi.decode(context, (bytes4, bytes));\n\n        FallbackHandler storage $fallbacks = $fallbackStorage[functionSig][msg.sender];\n        if ($fallbacks.handler != module) {\n            revert InvalidModuleType(module, MODULE_TYPE_FALLBACK);\n        }\n        delete $fallbacks.handler;\n    }\n\n    function _isFallbackHandlerInstalled(\n        address _handler,\n        bytes calldata additionalContext\n    )\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        bytes4 functionSig = abi.decode(additionalContext, (bytes4));\n\n        FallbackHandler storage $fallbacks = $fallbackStorage[functionSig][msg.sender];\n        return $fallbacks.handler == _handler;\n    }\n\n    function getFallbackHandlerBySelector(bytes4 selector)\n        external\n        view\n        returns (CallType, address)\n    {\n        FallbackHandler memory handler = $fallbackStorage[selector][msg.sender];\n        return (handler.calltype, handler.handler);\n    }\n\n    /**\n     * @dev AccessControl: any external contract / EOA may call this function\n     * Safe7579 Fallback supports the following feature set:\n     *    CallTypes:\n     *             - CALLTYPE_SINGLE\n     *             - CALLTYPE_BATCH\n     * @dev If a global hook and/or selector hook is set, it will be called\n     */\n    // solhint-disable-next-line no-complex-fallback\n    fallback(bytes calldata callData)\n        external\n        payable\n        virtual\n        withHook\n        returns (bytes memory fallbackRet)\n    {\n        // using JUMPI to avoid stack too deep\n        return _callFallbackHandler(callData);\n    }\n\n    receive() external payable { }\n\n    function _callFallbackHandler(bytes calldata callData)\n        private\n        returns (bytes memory fallbackRet)\n    {\n        // get handler for specific function selector\n        FallbackHandler storage $fallbacks = $fallbackStorage[msg.sig][msg.sender];\n        address handler = $fallbacks.handler;\n        CallType calltype = $fallbacks.calltype;\n        // if no handler is set for the msg.sig, return msg.sig for erc721/1155 selectors,\n        // otherwise revert\n        if (handler == address(0)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let s := shr(224, calldataload(0))\n                // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n                // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n                // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n                if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\n                    mstore(0x20, s) // Store `msg.sig`.\n                    return(0x3c, 0x20) // Return `msg.sig`.\n                }\n            }\n            revert NoFallbackHandler(msg.sig);\n        }\n        // according to ERC7579, when calling to fallback modules, ERC2771 msg.sender has to be\n        // appended to the calldata, this allows fallback modules to implement\n        // authorization control\n        if (calltype == CALLTYPE_STATIC) {\n            return _staticcallReturn({\n                safe: ISafe(msg.sender),\n                target: handler,\n                callData: abi.encodePacked(callData, _msgSender()) // append ERC2771\n             });\n        }\n        if (calltype == CALLTYPE_SINGLE) {\n            return _execReturn({\n                safe: ISafe(msg.sender),\n                target: handler,\n                value: 0,\n                callData: abi.encodePacked(callData, _msgSender()) // append ERC2771\n             });\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        HOOK MODULES                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    mapping(address smartAccount => address globalHook) internal $globalHook;\n    mapping(address hook => mapping(address smartAccount => uint256 emergencyUninstallTime))\n        internal $emergencyUninstallTime;\n\n    /**\n     * Run precheck for global hook\n     */\n    function _preHooks(address globalHook) internal returns (bytes memory global) {\n        if (globalHook != address(0)) {\n            global = _execReturn({\n                safe: ISafe(msg.sender),\n                target: globalHook,\n                value: 0,\n                callData: abi.encodeCall(IHook.preCheck, (_msgSender(), msg.value, msg.data))\n            });\n            global = abi.decode(global, (bytes));\n        }\n    }\n\n    /**\n     * Run post hooks\n     */\n    function _postHooks(address globalHook, bytes memory global) internal {\n        if (globalHook != address(0)) {\n            _exec({\n                safe: ISafe(msg.sender),\n                target: globalHook,\n                value: 0,\n                callData: abi.encodeCall(IHook.postCheck, (global))\n            });\n        }\n    }\n\n    /**\n     * modifier that executes global hook, and function signature specific hook if enabled\n     */\n    modifier withHook() {\n        address globalHook = $globalHook[msg.sender];\n        (bytes memory global) = _preHooks(globalHook);\n        _;\n        _postHooks(globalHook, global);\n    }\n\n    /**\n     * Install and initialize hook module\n     * @dev This function will install a hook module and return the moduleInitData\n     * @param hook address of the hook module\n     * @param data initialization data for the hook module\n     */\n    function _installHook(\n        address hook,\n        bytes calldata data\n    )\n        internal\n        virtual\n        withRegistry(hook, MODULE_TYPE_HOOK)\n        withCorrectModuleType(hook, MODULE_TYPE_HOOK)\n        returns (bytes memory moduleInitData)\n    {\n        // check if any hook is already installed\n        address currentHook = $globalHook[msg.sender];\n        // Dont allow hooks to be overwritten. If a hook is currently installed, it must be\n        // uninstalled first\n        if (currentHook != address(0)) {\n            revert HookAlreadyInstalled(currentHook);\n        }\n        $globalHook[msg.sender] = hook;\n        return data;\n    }\n\n    function _uninstallHook(\n        address module,\n        bytes calldata data\n    )\n        internal\n        virtual\n        returns (bytes memory moduleDeInitData)\n    {\n        if ($globalHook[msg.sender] != module) {\n            revert InvalidModuleType(module, MODULE_TYPE_HOOK);\n        }\n        delete $globalHook[msg.sender];\n        return data;\n    }\n\n    function _isHookInstalled(address module) internal view returns (bool) {\n        address hook = getActiveHook();\n        return module != address(0) && hook == module;\n    }\n\n    function getActiveHook() public view returns (address hook) {\n        return $globalHook[msg.sender];\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                 PREVALIDATION HOOK MODULES                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    mapping(address smartAccount => address preValidationHook4337) internal $preValidationHook4337;\n    mapping(address smartAccount => address preValidationHook1271) internal $preValidationHook1271;\n\n    function _withPreValidationHook(\n        address sender,\n        bytes32 hash,\n        bytes calldata signature\n    )\n        internal\n        view\n        returns (bytes32 postHash, bytes memory postSig)\n    {\n        address preValidationHook = getPrevalidationHook(MODULE_TYPE_PREVALIDATION_HOOK_ERC1271);\n        if (preValidationHook == address(0)) {\n            return (hash, signature);\n        } else {\n            bytes memory ret = _staticcallReturn({\n                safe: ISafe(msg.sender),\n                target: preValidationHook,\n                callData: abi.encodeCall(\n                    IPreValidationHookERC1271.preValidationHookERC1271, (sender, hash, signature)\n                )\n            });\n            return abi.decode(ret, (bytes32, bytes));\n        }\n    }\n\n    function _withPreValidationHook(\n        bytes32 hash,\n        PackedUserOperation memory userOp,\n        uint256 missingAccountFunds\n    )\n        internal\n        returns (bytes32 postHash, bytes memory postSig)\n    {\n        address preValidationHook = getPrevalidationHook(MODULE_TYPE_PREVALIDATION_HOOK_ERC4337);\n        if (preValidationHook == address(0)) {\n            return (hash, userOp.signature);\n        } else {\n            bytes memory ret = _execReturn({\n                safe: ISafe(msg.sender),\n                target: preValidationHook,\n                value: 0,\n                callData: abi.encodeCall(\n                    IPreValidationHookERC4337.preValidationHookERC4337,\n                    (userOp, missingAccountFunds, hash)\n                )\n            });\n            return abi.decode(ret, (bytes32, bytes));\n        }\n    }\n\n    function _installPreValidationHook(\n        address hook,\n        bytes calldata data\n    )\n        internal\n        returns (bytes memory moduleInitData)\n    {\n        uint256 moduleType;\n        (moduleType, moduleInitData) = abi.decode(data, (uint256, bytes));\n        if (moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337) {\n            _installPreValidationHook4337(hook);\n        } else if (moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271) {\n            _installPreValidationHook1271(hook);\n        }\n    }\n\n    function _installPreValidationHook4337(address hook)\n        internal\n        virtual\n        withRegistry(hook, MODULE_TYPE_PREVALIDATION_HOOK_ERC4337)\n        withCorrectModuleType(hook, MODULE_TYPE_PREVALIDATION_HOOK_ERC4337)\n    {\n        address currentHook = $preValidationHook4337[msg.sender];\n        if (currentHook != address(0)) {\n            revert PreValidationHookAlreadyInstalled(\n                currentHook, MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n            );\n        }\n        $preValidationHook4337[msg.sender] = hook;\n    }\n\n    function _installPreValidationHook1271(address hook)\n        internal\n        virtual\n        withRegistry(hook, MODULE_TYPE_PREVALIDATION_HOOK_ERC1271)\n        withCorrectModuleType(hook, MODULE_TYPE_PREVALIDATION_HOOK_ERC1271)\n    {\n        address currentHook = $preValidationHook1271[msg.sender];\n        if (currentHook != address(0)) {\n            revert PreValidationHookAlreadyInstalled(\n                currentHook, MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n            );\n        }\n        $preValidationHook1271[msg.sender] = hook;\n    }\n\n    function _uninstallPreValidationHook(\n        address module,\n        bytes calldata data\n    )\n        internal\n        returns (bytes memory moduleDeInitData)\n    {\n        uint256 moduleType;\n        (moduleType, moduleDeInitData) = abi.decode(data, (uint256, bytes));\n        if (moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337) {\n            if ($preValidationHook4337[msg.sender] != module) {\n                revert InvalidModuleType(module, moduleType);\n            } else {\n                delete $preValidationHook4337[msg.sender];\n            }\n        } else if (moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271) {\n            if ($preValidationHook1271[msg.sender] != module) {\n                revert InvalidModuleType(module, moduleType);\n            } else {\n                delete $preValidationHook1271[msg.sender];\n            }\n        }\n    }\n\n    /**\n     * @dev Check if the emergency uninstall signature is valid, if no validator module is\n     *      supplied/installed, the Safe's checkSignatures() function will be used. Otherwise the\n     *      validator module's isValidSignatureWithSender() function will be used.\n     * @param data emergency uninstall data\n     * @param signature signature of the data\n     */\n    function _checkEmergencyUninstallSignature(\n        EmergencyUninstall calldata data,\n        bytes calldata signature\n    )\n        internal\n    {\n        address validator = address(bytes20(signature[0:20]));\n        ISafe safe = ISafe(msg.sender);\n        bytes32 domainSeparator = safe.domainSeparator();\n        // Hash the data\n        bytes32 hash = _getEmergencyUninstallDataHash(domainSeparator, data);\n        // Check if nonce is valid\n        require(!$nonces[data.nonce][msg.sender], InvalidNonce());\n        // Mark nonce as used\n        $nonces[data.nonce][msg.sender] = true;\n\n        // check if validator is enabled. If not, use Safe's checkSignatures()\n        if (validator == address(0) || !_isValidatorInstalled(validator)) {\n            bytes memory messageData = EIP712.encodeMessageData(domainSeparator, abi.encode(hash));\n            bytes32 messageHash = keccak256(messageData);\n            safe.checkSignatures(messageHash, messageData, signature[20:]);\n        }\n        // if a installed validator module was selected, use 7579 validation module\n        else {\n            bytes memory ret = _staticcallReturn({\n                safe: ISafe(msg.sender),\n                target: validator,\n                callData: abi.encodeCall(\n                    IValidator.isValidSignatureWithSender, (_msgSender(), hash, signature[20:])\n                )\n            });\n            require(\n                abi.decode(ret, (bytes4)) == IERC1271.isValidSignature.selector,\n                EmergencyUninstallSigError()\n            );\n        }\n    }\n\n    /**\n     * @dev Get the hash of the emergency uninstall data\n     * @param domainSeparator EIP712 domain separator\n     * @param data emergency uninstall data\n     * @return hash of the emergency uninstall data\n     */\n    function _getEmergencyUninstallDataHash(\n        bytes32 domainSeparator,\n        EmergencyUninstall calldata data\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(EIP712.encodeEmergencyUninstallData(domainSeparator, data));\n    }\n\n    function getPrevalidationHook(uint256 moduleType) public view returns (address hook) {\n        if (moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337) {\n            return $preValidationHook4337[msg.sender];\n        } else if (moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271) {\n            return $preValidationHook1271[msg.sender];\n        } else {\n            revert InvalidHookType();\n        }\n    }\n\n    function _isPreValidationHookInstalled(\n        address module,\n        bytes calldata context\n    )\n        internal\n        view\n        returns (bool isInstalled)\n    {\n        uint256 moduleType = abi.decode(context, (uint256));\n        if (moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337) {\n            return $preValidationHook4337[msg.sender] == module;\n        } else if (moduleType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271) {\n            return $preValidationHook1271[msg.sender] == module;\n        }\n    }\n\n    // solhint-disable-next-line code-complexity\n    /**\n     * To make it easier to install multiple modules at once, this function will\n     * install multiple modules at once. The init data is expected to be a abi encoded tuple\n     * of (uint[] types, bytes[] contexts, bytes moduleInitData)\n     * @dev Install multiple modules at once\n     * @param module address of the module\n     * @param initData initialization data for the module\n     */\n    function _multiTypeInstall(\n        address module,\n        bytes calldata initData\n    )\n        internal\n        returns (bytes memory _moduleInitData)\n    {\n        uint256[] calldata types;\n        bytes[] calldata contexts;\n        bytes calldata moduleInitData;\n\n        // equivalent of:\n        // (types, contexs, moduleInitData) = abi.decode(initData,(uint[],bytes[],bytes)\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            let offset := initData.offset\n            let baseOffset := offset\n            let dataPointer := add(baseOffset, calldataload(offset))\n\n            types.offset := add(dataPointer, 32)\n            types.length := calldataload(dataPointer)\n            offset := add(offset, 32)\n\n            dataPointer := add(baseOffset, calldataload(offset))\n            contexts.offset := add(dataPointer, 32)\n            contexts.length := calldataload(dataPointer)\n            offset := add(offset, 32)\n\n            dataPointer := add(baseOffset, calldataload(offset))\n            moduleInitData.offset := add(dataPointer, 32)\n            moduleInitData.length := calldataload(dataPointer)\n        }\n\n        uint256 length = types.length;\n        if (contexts.length != length) revert InvalidInput();\n\n        // iterate over all module types and install the module as a type accordingly\n        for (uint256 i; i < length; i++) {\n            uint256 _type = types[i];\n\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                      INSTALL VALIDATORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            if (_type == MODULE_TYPE_VALIDATOR) {\n                _installValidator(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL EXECUTORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (_type == MODULE_TYPE_EXECUTOR) {\n                _installExecutor(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL FALLBACK                     */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (_type == MODULE_TYPE_FALLBACK) {\n                _installFallbackHandler(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*          INSTALL HOOK            */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (_type == MODULE_TYPE_HOOK) {\n                _installHook(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*      INSTALL PREVALIDATION HOOK (ERC1271 or ERC4337)       */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (\n                _type == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n                    || _type == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n            ) {\n                _installPreValidationHook(module, contexts[i]);\n            } else {\n                revert InvalidModuleType(module, _type);\n            }\n        }\n        // memory allocate the moduleInitData to return. This data should be used by the caller to\n        // initialize the module\n        _moduleInitData = moduleInitData;\n    }\n\n    function _multiTypeUninstall(\n        address module,\n        bytes calldata initData\n    )\n        internal\n        returns (bytes memory _moduleDeInitData)\n    {\n        uint256[] calldata types;\n        bytes[] calldata contexts;\n        bytes calldata moduleDeInitData;\n\n        // equivalent of:\n        // (types, contexs, moduleInitData) = abi.decode(initData,(uint[],bytes[],bytes)\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            let offset := initData.offset\n            let baseOffset := offset\n            let dataPointer := add(baseOffset, calldataload(offset))\n\n            types.offset := add(dataPointer, 32)\n            types.length := calldataload(dataPointer)\n            offset := add(offset, 32)\n\n            dataPointer := add(baseOffset, calldataload(offset))\n            contexts.offset := add(dataPointer, 32)\n            contexts.length := calldataload(dataPointer)\n            offset := add(offset, 32)\n\n            dataPointer := add(baseOffset, calldataload(offset))\n            moduleDeInitData.offset := add(dataPointer, 32)\n            moduleDeInitData.length := calldataload(dataPointer)\n        }\n\n        uint256 length = types.length;\n        if (contexts.length != length) revert InvalidInput();\n\n        // iterate over all module types and install the module as a type accordingly\n        for (uint256 i; i < length; i++) {\n            uint256 _type = types[i];\n\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                      INSTALL VALIDATORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            if (_type == MODULE_TYPE_VALIDATOR) {\n                _uninstallValidator(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL EXECUTORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (_type == MODULE_TYPE_EXECUTOR) {\n                _uninstallExecutor(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL FALLBACK                     */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (_type == MODULE_TYPE_FALLBACK) {\n                _uninstallFallbackHandler(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*          INSTALL HOOK            */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (_type == MODULE_TYPE_HOOK) {\n                _uninstallHook(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*      INSTALL PREVALIDATION HOOK (ERC1271 or ERC4337)       */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (\n                _type == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n                    || _type == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n            ) {\n                _uninstallPreValidationHook(module, contexts[i]);\n            } else {\n                revert InvalidModuleType(module, _type);\n            }\n        }\n        // memory allocate the moduleInitData to return. This data should be used by the caller to\n        // initialize the module\n        _moduleDeInitData = moduleDeInitData;\n    }\n\n    /*\n     * @Dev Check's if a module is of a specific type, reverts if not\n     */\n    modifier withCorrectModuleType(address module, uint256 moduleType) {\n        if (!IModule(module).isModuleType(moduleType)) {\n            revert InvalidModuleType(module, moduleType);\n        }\n        _;\n    }\n}\n"},"src/interfaces/IERC7484.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC7484 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, uint256 moduleType) external view;\n\n    function checkForAccount(\n        address smartAccount,\n        address module,\n        uint256 moduleType\n    )\n        external\n        view;\n\n    /**\n     * Allows Smart Accounts - the end users of the registry - to appoint\n     * one or many attesters as trusted.\n     * @dev this function reverts, if address(0), or duplicates are provided in attesters[]\n     *\n     * @param threshold The minimum number of attestations required for a module\n     *                  to be considered secure.\n     * @param attesters The addresses of the attesters to be trusted.\n     */\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              Check with external attester(s)               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module, address[] calldata attesters, uint256 threshold) external view;\n\n    function check(\n        address module,\n        uint256 moduleType,\n        address[] calldata attesters,\n        uint256 threshold\n    )\n        external\n        view;\n}\n"},"node_modules/@rhinestone/sentinellist/src/SentinelList4337.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Sentinel address\naddress constant SENTINEL = address(0x1);\n// Zero address\naddress constant ZERO_ADDRESS = address(0x0);\n\n/**\n * @title SentinelListLib\n * @dev Library for managing a linked list of addresses that is compliant with the ERC-4337\n * validation rules\n * @author Rhinestone\n */\nlibrary SentinelList4337Lib {\n    // Struct to hold the linked list\n    // This linked list has the account address as the inner key so it is ERC-4337 compliant\n    struct SentinelList {\n        mapping(address key => mapping(address account => address entry)) entries;\n    }\n\n    error LinkedList_AlreadyInitialized();\n    error LinkedList_InvalidPage();\n    error LinkedList_InvalidEntry(address entry);\n    error LinkedList_EntryAlreadyInList(address entry);\n\n    /**\n     * Initialize the linked list\n     *\n     * @param self The linked list\n     * @param account The account to initialize the linked list for\n     */\n    function init(SentinelList storage self, address account) internal {\n        if (alreadyInitialized(self, account)) revert LinkedList_AlreadyInitialized();\n        self.entries[SENTINEL][account] = SENTINEL;\n    }\n\n    /**\n     * Check if the linked list is already initialized\n     *\n     * @param self The linked list\n     * @param account The account to check if the linked list is initialized for\n     *\n     * @return bool True if the linked list is already initialized\n     */\n    function alreadyInitialized(\n        SentinelList storage self,\n        address account\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return self.entries[SENTINEL][account] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get the next entry in the linked list\n     *\n     * @param self The linked list\n     * @param account The account to get the next entry for\n     * @param entry The current entry\n     *\n     * @return address The next entry\n     */\n    function getNext(\n        SentinelList storage self,\n        address account,\n        address entry\n    )\n        internal\n        view\n        returns (address)\n    {\n        if (entry == ZERO_ADDRESS) {\n            revert LinkedList_InvalidEntry(entry);\n        }\n        return self.entries[entry][account];\n    }\n\n    /**\n     * Push a new entry to the linked list\n     *\n     * @param self The linked list\n     * @param account The account to push the new entry for\n     * @param newEntry The new entry\n     */\n    function push(SentinelList storage self, address account, address newEntry) internal {\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(newEntry);\n        }\n        if (self.entries[newEntry][account] != ZERO_ADDRESS) {\n            revert LinkedList_EntryAlreadyInList(newEntry);\n        }\n        self.entries[newEntry][account] = self.entries[SENTINEL][account];\n        self.entries[SENTINEL][account] = newEntry;\n    }\n\n    /**\n     * Safe push a new entry to the linked list\n     * @dev This ensures that the linked list is initialized and initializes it if it is not\n     *\n     * @param self The linked list\n     * @param account The account to push the new entry for\n     * @param newEntry The new entry\n     */\n    function safePush(SentinelList storage self, address account, address newEntry) internal {\n        if (!alreadyInitialized(self, account)) {\n            init({ self: self, account: account });\n        }\n        push({ self: self, account: account, newEntry: newEntry });\n    }\n\n    /**\n     * Pop an entry from the linked list\n     *\n     * @param self The linked list\n     * @param account The account to pop the entry for\n     * @param prevEntry The entry before the entry to pop\n     * @param popEntry The entry to pop\n     */\n    function pop(\n        SentinelList storage self,\n        address account,\n        address prevEntry,\n        address popEntry\n    )\n        internal\n    {\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(prevEntry);\n        }\n        if (self.entries[prevEntry][account] != popEntry) {\n            revert LinkedList_InvalidEntry(popEntry);\n        }\n        self.entries[prevEntry][account] = self.entries[popEntry][account];\n        self.entries[popEntry][account] = ZERO_ADDRESS;\n    }\n\n    /**\n     * Pop all entries from the linked list\n     *\n     * @param self The linked list\n     * @param account The account to pop all entries for\n     */\n    function popAll(SentinelList storage self, address account) internal {\n        address next = self.entries[SENTINEL][account];\n        while (next != ZERO_ADDRESS) {\n            address current = next;\n            next = self.entries[next][account];\n            self.entries[current][account] = ZERO_ADDRESS;\n        }\n    }\n\n    /**\n     * Check if the linked list contains an entry\n     *\n     * @param self The linked list\n     * @param account The account to check if the entry is in the linked list for\n     * @param entry The entry to check for\n     *\n     * @return bool True if the linked list contains the entry\n     */\n    function contains(\n        SentinelList storage self,\n        address account,\n        address entry\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return SENTINEL != entry && self.entries[entry][account] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get all entries in the linked list\n     *\n     * @param self The linked list\n     * @param account The account to get the entries for\n     * @param start The start entry\n     * @param pageSize The page size\n     *\n     * @return array All entries in the linked list\n     * @return next The next entry\n     */\n    function getEntriesPaginated(\n        SentinelList storage self,\n        address account,\n        address start,\n        uint256 pageSize\n    )\n        internal\n        view\n        returns (address[] memory array, address next)\n    {\n        if (start != SENTINEL && !contains(self, account, start)) {\n            revert LinkedList_InvalidEntry(start);\n        }\n        if (pageSize == 0) revert LinkedList_InvalidPage();\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 entryCount = 0;\n        next = self.entries[start][account];\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\n            array[entryCount] = next;\n            next = self.entries[next][account];\n            entryCount++;\n        }\n\n        /**\n         * Because of the argument validation, we can assume that the loop will always iterate over\n         * the valid entry list values\n         *       and the `next` variable will either be an enabled entry or a sentinel address\n         * (signalling the end).\n         *\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\n         * the last element of the entry array\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\n         * start of the next page is neither\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\n         * start.\n         */\n        if (next != SENTINEL && entryCount > 0) {\n            next = array[entryCount - 1];\n        }\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, entryCount)\n        }\n    }\n}\n"},"node_modules/@rhinestone/sentinellist/src/SentinelList.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Sentinel address\naddress constant SENTINEL = address(0x1);\n// Zero address\naddress constant ZERO_ADDRESS = address(0x0);\n\n/**\n * @title SentinelListLib\n * @dev Library for managing a linked list of addresses\n * @author Rhinestone\n */\nlibrary SentinelListLib {\n    // Struct to hold the linked list\n    struct SentinelList {\n        mapping(address => address) entries;\n    }\n\n    error LinkedList_AlreadyInitialized();\n    error LinkedList_InvalidPage();\n    error LinkedList_InvalidEntry(address entry);\n    error LinkedList_EntryAlreadyInList(address entry);\n\n    /**\n     * Initialize the linked list\n     *\n     * @param self The linked list\n     */\n    function init(SentinelList storage self) internal {\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\n        self.entries[SENTINEL] = SENTINEL;\n    }\n\n    /**\n     * Check if the linked list is already initialized\n     *\n     * @param self The linked list\n     *\n     * @return bool True if the linked list is already initialized\n     */\n    function alreadyInitialized(SentinelList storage self) internal view returns (bool) {\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get the next entry in the linked list\n     *\n     * @param self The linked list\n     * @param entry The current entry\n     *\n     * @return address The next entry\n     */\n    function getNext(SentinelList storage self, address entry) internal view returns (address) {\n        if (entry == ZERO_ADDRESS) {\n            revert LinkedList_InvalidEntry(entry);\n        }\n        return self.entries[entry];\n    }\n\n    /**\n     * Push a new entry to the linked list\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function push(SentinelList storage self, address newEntry) internal {\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(newEntry);\n        }\n        if (self.entries[newEntry] != ZERO_ADDRESS) revert LinkedList_EntryAlreadyInList(newEntry);\n        self.entries[newEntry] = self.entries[SENTINEL];\n        self.entries[SENTINEL] = newEntry;\n    }\n\n    /**\n     * Safe push a new entry to the linked list\n     * @dev This ensures that the linked list is initialized and initializes it if it is not\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function safePush(SentinelList storage self, address newEntry) internal {\n        if (!alreadyInitialized({ self: self })) {\n            init({ self: self });\n        }\n        push({ self: self, newEntry: newEntry });\n    }\n\n    /**\n     * Pop an entry from the linked list\n     *\n     * @param self The linked list\n     * @param prevEntry The entry before the entry to pop\n     * @param popEntry The entry to pop\n     */\n    function pop(SentinelList storage self, address prevEntry, address popEntry) internal {\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(prevEntry);\n        }\n        if (self.entries[prevEntry] != popEntry) revert LinkedList_InvalidEntry(popEntry);\n        self.entries[prevEntry] = self.entries[popEntry];\n        self.entries[popEntry] = ZERO_ADDRESS;\n    }\n\n    /**\n     * Pop all entries from the linked list\n     *\n     * @param self The linked list\n     */\n    function popAll(SentinelList storage self) internal {\n        address next = self.entries[SENTINEL];\n        while (next != ZERO_ADDRESS) {\n            address current = next;\n            next = self.entries[next];\n            self.entries[current] = ZERO_ADDRESS;\n        }\n    }\n\n    /**\n     * Check if the linked list contains an entry\n     *\n     * @param self The linked list\n     * @param entry The entry to check\n     *\n     * @return bool True if the linked list contains the entry\n     */\n    function contains(SentinelList storage self, address entry) internal view returns (bool) {\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get all entries in the linked list\n     *\n     * @param self The linked list\n     * @param start The start entry\n     * @param pageSize The page size\n     *\n     * @return array All entries in the linked list\n     * @return next The next entry\n     */\n    function getEntriesPaginated(\n        SentinelList storage self,\n        address start,\n        uint256 pageSize\n    )\n        internal\n        view\n        returns (address[] memory array, address next)\n    {\n        if (start != SENTINEL && !contains(self, start)) revert LinkedList_InvalidEntry(start);\n        if (pageSize == 0) revert LinkedList_InvalidPage();\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 entryCount = 0;\n        next = self.entries[start];\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\n            array[entryCount] = next;\n            next = self.entries[next];\n            entryCount++;\n        }\n\n        /**\n         * Because of the argument validation, we can assume that the loop will always iterate over\n         * the valid entry list values\n         *       and the `next` variable will either be an enabled entry or a sentinel address\n         * (signalling the end).\n         *\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\n         * the last element of the entry array\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\n         * start of the next page is neither\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\n         * start.\n         */\n        if (next != SENTINEL && entryCount > 0) {\n            next = array[entryCount - 1];\n        }\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, entryCount)\n        }\n    }\n}\n"},"src/interfaces/ISafeOp.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nbytes32 constant SAFE_OP_TYPEHASH =\n    0xc03dfc11d8b10bf9cf703d558958c8c42777f785d998c62060d85a4f0ef6ea7f;\n\ninterface ISafeOp {\n    /**\n     * @notice The EIP-712 type-hash for a SafeOp, representing the structure of a User Operation\n     * for\n     * the Safe.\n     *  {address} safe - The address of the safe on which the operation is performed.\n     *  {uint256} nonce - A unique number associated with the user operation, preventing replay\n     * attacks\n     * by ensuring each operation is unique.\n     *  {bytes} initCode - The packed encoding of a factory address and its factory-specific data\n     * for\n     * creating a new Safe account.\n     *  {bytes} callData - The bytes representing the data of the function call to be executed.\n     *  {uint128} verificationGasLimit - The maximum amount of gas allowed for the verification\n     * process.\n     *  {uint128} callGasLimit - The maximum amount of gas allowed for executing the function call.\n     *  {uint256} preVerificationGas - The amount of gas allocated for pre-verification steps before\n     * executing the main operation.\n     *  {uint128} maxPriorityFeePerGas - The maximum priority fee per gas that the user is willing\n     * to\n     * pay for the transaction.\n     *  {uint128} maxFeePerGas - The maximum fee per gas that the user is willing to pay for the\n     * transaction.\n     *  {bytes} paymasterAndData - The packed encoding of a paymaster address and its\n     * paymaster-specific\n     * data for sponsoring the user operation.\n     *  {uint48} validAfter - A timestamp representing from when the user operation is valid.\n     *  {uint48} validUntil - A timestamp representing until when the user operation is valid, or 0\n     * to\n     * indicated \"forever\".\n     *  {address} entryPoint - The address of the entry point that will execute the user operation.\n     * @dev When validating the user operation, the signature timestamps are pre-pended to the\n     * signature\n     * bytes. Equal to:\n     * keccak256(\n     *     \"SafeOp(address safe,uint256 nonce,bytes initCode,bytes callData,uint128\n     * verificationGasLimit,uint128 callGasLimit,uint256 preVerificationGas,uint128\n     * maxPriorityFeePerGas,uint128 maxFeePerGas,bytes paymasterAndData,uint48 validAfter,uint48\n     * validUntil,address entryPoint)\"\n     * ) = 0xc03dfc11d8b10bf9cf703d558958c8c42777f785d998c62060d85a4f0ef6ea7f\n     */\n    struct EncodedSafeOpStruct {\n        bytes32 typeHash;\n        address safe;\n        uint256 nonce;\n        bytes32 initCodeHash;\n        bytes32 callDataHash;\n        uint128 verificationGasLimit;\n        uint128 callGasLimit;\n        uint256 preVerificationGas;\n        uint128 maxPriorityFeePerGas;\n        uint128 maxFeePerGas;\n        bytes32 paymasterAndDataHash;\n        uint48 validAfter;\n        uint48 validUntil;\n        address entryPoint;\n    }\n\n    function domainSeparator() external view returns (bytes32);\n\n    function getSafeOp(\n        PackedUserOperation calldata userOp,\n        address entryPoint\n    )\n        external\n        view\n        returns (\n            bytes memory operationData,\n            uint48 validAfter,\n            uint48 validUntil,\n            bytes calldata signatures\n        );\n}\n"},"node_modules/solady/src/utils/LibBytes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for byte related operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBytes.sol)\nlibrary LibBytes {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Goated bytes storage struct that totally MOGs, no cap, fr.\n    /// Uses less gas and bytecode than Solidity's native bytes storage. It's meta af.\n    /// Packs length with the first 31 bytes if <255 bytes, so it’s mad tight.\n    struct BytesStorage {\n        bytes32 _spacer;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the bytes.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  BYTE STORAGE OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function set(BytesStorage storage $, bytes memory s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let packed := or(0xff, shl(8, n))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(n, 0xfe)) {\n                    i := 0x1f\n                    packed := or(n, shl(8, mload(add(s, i))))\n                    if iszero(gt(n, i)) { break }\n                }\n                let o := add(s, 0x20)\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), mload(add(o, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function setCalldata(BytesStorage storage $, bytes calldata s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := or(0xff, shl(8, s.length))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(s.length, 0xfe)) {\n                    i := 0x1f\n                    packed := or(s.length, shl(8, shr(8, calldataload(s.offset))))\n                    if iszero(gt(s.length, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), calldataload(add(s.offset, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, s.length)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to the empty bytes.\n    function clear(BytesStorage storage $) internal {\n        delete $._spacer;\n    }\n\n    /// @dev Returns whether the value stored is `$` is the empty bytes \"\".\n    function isEmpty(BytesStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }\n\n    /// @dev Returns the length of the value stored in `$`.\n    function length(BytesStorage storage $) internal view returns (uint256 result) {\n        result = uint256($._spacer);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := and(0xff, result)\n            result := or(mul(shr(8, result), eq(0xff, n)), mul(n, iszero(eq(0xff, n))))\n        }\n    }\n\n    /// @dev Returns the value stored in `$`.\n    function get(BytesStorage storage $) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let packed := sload($.slot)\n            let n := shr(8, packed)\n            for { let i := 0 } 1 {} {\n                if iszero(eq(or(packed, 0xff), packed)) {\n                    mstore(o, packed)\n                    n := and(0xff, packed)\n                    i := 0x1f\n                    if iszero(gt(n, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    mstore(add(o, i), sload(add(p, shr(5, i))))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            mstore(result, n) // Store the length of the memory.\n            mstore(add(o, n), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      BYTES OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\n    function replace(bytes memory subject, bytes memory needle, bytes memory replacement)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let needleLen := mload(needle)\n            let replacementLen := mload(replacement)\n            let d := sub(result, subject) // Memory difference.\n            let i := add(subject, 0x20) // Subject bytes pointer.\n            mstore(0x00, add(i, mload(subject))) // End of subject.\n            if iszero(gt(needleLen, mload(subject))) {\n                let subjectSearchEnd := add(sub(mload(0x00), needleLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(needleLen, 0x20)) { h := keccak256(add(needle, 0x20), needleLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(needleLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `needleLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, needleLen), h)) {\n                                mstore(add(i, d), t)\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let j := 0 } 1 {} {\n                            mstore(add(add(i, d), j), mload(add(add(replacement, 0x20), j)))\n                            j := add(j, 0x20)\n                            if iszero(lt(j, replacementLen)) { break }\n                        }\n                        d := sub(add(d, replacementLen), needleLen)\n                        if needleLen {\n                            i := add(i, needleLen)\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(add(i, d), t)\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n            }\n            let end := mload(0x00)\n            let n := add(sub(d, add(result, 0x20)), end)\n            // Copy the rest of the bytes one word at a time.\n            for {} lt(i, end) { i := add(i, 0x20) } { mstore(add(i, d), mload(i)) }\n            let o := add(i, d)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0) // Initialize to `NOT_FOUND`.\n            for { let subjectLen := mload(subject) } 1 {} {\n                if iszero(mload(needle)) {\n                    result := from\n                    if iszero(gt(from, subjectLen)) { break }\n                    result := subjectLen\n                    break\n                }\n                let needleLen := mload(needle)\n                let subjectStart := add(subject, 0x20)\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLen), needleLen), 1)\n                let m := shl(3, sub(0x20, and(needleLen, 0x1f)))\n                let s := mload(add(needle, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLen))) { break }\n\n                if iszero(lt(needleLen, 0x20)) {\n                    for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, needleLen), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle) internal pure returns (uint256) {\n        return indexOf(subject, needle, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let needleLen := mload(needle)\n                if gt(needleLen, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), needleLen)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                    if eq(keccak256(subject, needleLen), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(subject, needle, type(uint256).max);\n    }\n\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\n    function contains(bytes memory subject, bytes memory needle) internal pure returns (bool) {\n        return indexOf(subject, needle) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `needle`.\n    function startsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            // Just using keccak256 directly is actually cheaper.\n            let t := eq(keccak256(add(subject, 0x20), n), keccak256(add(needle, 0x20), n))\n            result := lt(gt(n, mload(subject)), t)\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `needle`.\n    function endsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            let notInRange := gt(n, mload(subject))\n            // `subject + 0x20 + max(subject.length - needle.length, 0)`.\n            let t := add(add(subject, 0x20), mul(iszero(notInRange), sub(mload(subject), n)))\n            // Just using keccak256 directly is actually cheaper.\n            result := gt(eq(keccak256(t, n), keccak256(add(needle, 0x20), n)), notInRange)\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(bytes memory subject, uint256 times)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(or(iszero(times), iszero(l))) {\n                result := mload(0x40)\n                subject := add(subject, 0x20)\n                let o := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let j := 0 } 1 {} {\n                        mstore(add(o, j), mload(add(subject, j)))\n                        j := add(j, 0x20)\n                        if iszero(lt(j, l)) { break }\n                    }\n                    o := add(o, l)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(bytes memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(gt(l, end)) { end := l }\n            if iszero(gt(l, start)) { start := l }\n            if lt(start, end) {\n                result := mload(0x40)\n                let n := sub(end, start)\n                let i := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let j := and(add(n, 0x1f), w) } 1 {} {\n                    mstore(add(result, j), mload(add(i, j)))\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    if iszero(j) { break }\n                }\n                let o := add(add(result, 0x20), n)\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, n) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\n    /// `start` is a byte offset.\n    function slice(bytes memory subject, uint256 start)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        result = slice(subject, start, type(uint256).max);\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets. Faster than Solidity's native slicing.\n    function sliceCalldata(bytes calldata subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, subject.length), lt(subject.length, end)))\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, end), sub(end, start))\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\n    /// `start` is a byte offset. Faster than Solidity's native slicing.\n    function sliceCalldata(bytes calldata subject, uint256 start)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, subject.length), sub(subject.length, start))\n        }\n    }\n\n    /// @dev Reduces the size of `subject` to `n`.\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\n    function truncate(bytes memory subject, uint256 n)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := subject\n            mstore(mul(lt(n, mload(result)), result), n)\n        }\n    }\n\n    /// @dev Returns a copy of `subject`, with the length reduced to `n`.\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\n    function truncatedCalldata(bytes calldata subject, uint256 n)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.offset := subject.offset\n            result.length := xor(n, mul(xor(n, subject.length), lt(subject.length, n)))\n        }\n    }\n\n    /// @dev Returns all the indices of `needle` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLen := mload(needle)\n            if iszero(gt(searchLen, mload(subject))) {\n                result := mload(0x40)\n                let i := add(subject, 0x20)\n                let o := add(result, 0x20)\n                let subjectSearchEnd := add(sub(add(i, mload(subject)), searchLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(searchLen, 0x20)) { h := keccak256(add(needle, 0x20), searchLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(searchLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `searchLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, searchLen), h)) {\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        mstore(o, sub(i, add(subject, 0x20))) // Append to `result`.\n                        o := add(o, 0x20)\n                        i := add(i, searchLen) // Advance `i` by `searchLen`.\n                        if searchLen {\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n                mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store the length of `result`.\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(o, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of bytess based on the `delimiter` inside of the `subject` bytes.\n    function split(bytes memory subject, bytes memory delimiter)\n        internal\n        pure\n        returns (bytes[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            for { let prevIndex := 0 } 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let l := sub(index, prevIndex)\n                    mstore(element, l) // Store the length of the element.\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(l, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    mstore(add(add(element, 0x20), l), 0) // Zeroize the slot after the bytes.\n                    // Allocate memory for the length and the bytes, rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(l, 0x3f), w)))\n                    mstore(indexPtr, element) // Store the `element` into the array.\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated bytes of `a` and `b`.\n    /// Cheaper than `bytes.concat()` and does not de-align the free memory pointer.\n    function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let w := not(0x1f)\n            let aLen := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLen, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLen := mload(b)\n            let output := add(result, aLen)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLen, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLen := add(aLen, bLen)\n            let last := add(add(result, 0x20), totalLen)\n            mstore(last, 0) // Zeroize the slot after the bytes.\n            mstore(result, totalLen) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(bytes memory a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small bytes.\n    function eqs(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Returns 0 if `a == b`, -1 if `a < b`, +1 if `a > b`.\n    /// If `a` == b[:a.length]`, and `a.length < b.length`, returns -1.\n    function cmp(bytes memory a, bytes memory b) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            let bLen := mload(b)\n            let n := and(xor(aLen, mul(xor(aLen, bLen), lt(bLen, aLen))), not(0x1f))\n            if n {\n                for { let i := 0x20 } 1 {} {\n                    let x := mload(add(a, i))\n                    let y := mload(add(b, i))\n                    if iszero(or(xor(x, y), eq(i, n))) {\n                        i := add(i, 0x20)\n                        continue\n                    }\n                    result := sub(gt(x, y), lt(x, y))\n                    break\n                }\n            }\n            // forgefmt: disable-next-item\n            if iszero(result) {\n                let l := 0x201f1e1d1c1b1a191817161514131211100f0e0d0c0b0a090807060504030201\n                let x := and(mload(add(add(a, 0x20), n)), shl(shl(3, byte(sub(aLen, n), l)), not(0)))\n                let y := and(mload(add(add(b, 0x20), n)), shl(shl(3, byte(sub(bLen, n), l)), not(0)))\n                result := sub(gt(x, y), lt(x, y))\n                if iszero(result) { result := sub(gt(aLen, bLen), lt(aLen, bLen)) }\n            }\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(bytes memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Assumes that the bytes does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the bytes is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the bytes.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n\n    /// @dev Directly returns `a` with minimal copying.\n    function directReturn(bytes[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a) // `a.length`.\n            let o := add(a, 0x20) // Start of elements in `a`.\n            let u := a // Highest memory slot.\n            let w := not(0x1f)\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                let c := add(o, shl(5, i)) // Location of pointer to `a[i]`.\n                let s := mload(c) // `a[i]`.\n                let l := mload(s) // `a[i].length`.\n                let r := and(l, 0x1f) // `a[i].length % 32`.\n                let z := add(0x20, and(l, w)) // Offset of last word in `a[i]` from `s`.\n                // If `s` comes before `o`, or `s` is not zero right padded.\n                if iszero(lt(lt(s, o), or(iszero(r), iszero(shl(shl(3, r), mload(add(s, z))))))) {\n                    let m := mload(0x40)\n                    mstore(m, l) // Copy `a[i].length`.\n                    for {} 1 {} {\n                        mstore(add(m, z), mload(add(s, z))) // Copy `a[i]`, backwards.\n                        z := add(z, w) // `sub(z, 0x20)`.\n                        if iszero(z) { break }\n                    }\n                    let e := add(add(m, 0x20), l)\n                    mstore(e, 0) // Zeroize the slot after the copied bytes.\n                    mstore(0x40, add(e, 0x20)) // Allocate memory.\n                    s := m\n                }\n                mstore(c, sub(s, o)) // Convert to calldata offset.\n                let t := add(l, add(s, 0x20))\n                if iszero(lt(t, u)) { u := t }\n            }\n            let retStart := add(a, w) // Assumes `a` doesn't start from scratch space.\n            mstore(retStart, 0x20) // Store the return offset.\n            return(retStart, add(0x40, sub(u, retStart))) // End the transaction.\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    function load(bytes memory a, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), offset))\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    function loadCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := calldataload(add(a.offset, offset))\n        }\n    }\n\n    /// @dev Returns a slice representing a static struct in the calldata. Performs bounds checks.\n    function staticStructInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            result.offset := add(a.offset, offset)\n            result.length := sub(a.length, offset)\n            if or(shr(64, or(l, a.offset)), gt(offset, l)) { revert(l, 0x00) }\n        }\n    }\n\n    /// @dev Returns a slice representing a dynamic struct in the calldata. Performs bounds checks.\n    function dynamicStructInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.\n            result.offset := add(a.offset, s)\n            result.length := sub(a.length, s)\n            if or(shr(64, or(s, or(l, a.offset))), gt(offset, l)) { revert(l, 0x00) }\n        }\n    }\n\n    /// @dev Returns bytes in calldata. Performs bounds checks.\n    function bytesInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.\n            result.offset := add(add(a.offset, s), 0x20)\n            result.length := calldataload(add(a.offset, s))\n            // forgefmt: disable-next-item\n            if or(shr(64, or(result.length, or(s, or(l, a.offset)))),\n                or(gt(add(s, result.length), l), gt(offset, l))) { revert(l, 0x00) }\n        }\n    }\n\n    /// @dev Returns empty calldata bytes. For silencing the compiler.\n    function emptyCalldata() internal pure returns (bytes calldata result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.length := 0\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IStakeManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.5;\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    // Emitted when stake or unstake delay are modified.\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    // Emitted once a stake is scheduled for withdrawal.\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit         - The entity's deposit.\n     * @param staked          - True if this entity is staked.\n     * @param stake           - Actual amount of ether staked for this entity.\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\n     *      - 112 bit allows for 10^15 eth\n     *      - 48 bit for full timestamp\n     *      - 32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint256 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    // API struct used by getStakeInfo and simulateValidation.\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /**\n     * Get deposit info.\n     * @param account - The account to query.\n     * @return info   - Full deposit information of given account.\n     */\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /**\n     * Get account balance.\n     * @param account - The account to query.\n     * @return        - The deposit (for gas payment) of the account.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IAggregator.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * Validate aggregated signature.\n     * Revert if the aggregated signature does not match the given list of operations.\n     * @param userOps   - Array of UserOperations to validate the signature for.\n     * @param signature - The aggregated signature.\n     */\n    function validateSignatures(\n        PackedUserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * Validate signature of a single userOp.\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\n     * the aggregator this account uses.\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp        - The userOperation received from the user.\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * Aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation.\n     * @param userOps              - Array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature - The aggregated signature.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/INonceManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\ninterface INonceManager {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"},"src/core/RegistryAdapter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC7484 } from \"../interfaces/IERC7484.sol\";\nimport { ExecutionHelper } from \"./ExecutionHelper.sol\";\nimport { ISafe } from \"../interfaces/ISafe.sol\";\nimport { ISafe7579 } from \"../ISafe7579.sol\";\n\n/**\n * IERC7484 Registry adapter.\n * this feature is opt-in. The smart account owner can choose to use the registry and which\n * attesters to trust.\n * @author zeroknots.eth | rhinestone.wtf\n */\nabstract contract RegistryAdapter is ISafe7579, ExecutionHelper {\n    mapping(address smartAccount => IERC7484 registry) internal $registry;\n\n    modifier withRegistry(address module, uint256 moduleType) {\n        _checkRegistry(module, moduleType);\n        _;\n    }\n\n    /**\n     * Check on ERC7484 Registry, if suffcient attestations were made\n     * This will revert, if not succicient valid attestations are on the registry\n     */\n    function _checkRegistry(address module, uint256 moduleType) internal view {\n        IERC7484 registry = $registry[msg.sender];\n        if (address(registry) != address(0)) {\n            // this will revert if attestations / threshold are not met\n            registry.checkForAccount(msg.sender, module, moduleType);\n        }\n    }\n\n    /**\n     * Configure ERC7484 Registry for Safe\n     */\n    function _configureRegistry(\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    )\n        internal\n    {\n        // sstore value in any case, as this function may be used to disable the use of registry\n        $registry[msg.sender] = registry;\n        // registry is an opt in feature for Safe7579. if set, configure trusted attesters\n        if (registry != IERC7484(address(0))) {\n            _exec({\n                safe: ISafe(msg.sender),\n                target: address(registry),\n                value: 0,\n                callData: abi.encodeCall(IERC7484.trustAttesters, (threshold, attesters))\n            });\n        }\n        emit ERC7484RegistryConfigured(msg.sender, registry);\n    }\n}\n"},"src/core/ExecutionHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { Safe7579DCUtil, Safe7579DCUtilSetup } from \"./SetupDCUtil.sol\";\nimport { BatchedExecUtil } from \"../utils/DCUtil.sol\";\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\nimport { ISafe } from \"../interfaces/ISafe.sol\";\n\n/**\n * Abstraction layer for executions.\n * @dev All interactions with modules must originate from msg.sender == SafeProxy. This entails\n * avoiding direct calls by the Safe7579 Adapter for actions like onInstall on modules or\n * validateUserOp on validator modules, and utilizing the Safe's execTransactionFromModule feature\n * instead.\n * @dev Since Safe7579 offers features like TryExecute for batched executions, rewriting and\n * verifying execution success across the codebase can be challenging and error-prone. These\n * functions serve to interact with modules and external contracts.\n */\nabstract contract ExecutionHelper is Safe7579DCUtilSetup {\n    event TryExecutionFailed(ISafe safe, uint256 numberInBatch);\n    event TryExecutionsFailed(ISafe safe, bool[] success);\n\n    error ExecutionFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EXEC - REVERT ON FAIL                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    function _exec(ISafe safe, Execution[] calldata executions) internal {\n        _delegatecall({\n            safe: safe,\n            target: UTIL,\n            callData: abi.encodeCall(BatchedExecUtil.execute, executions)\n        });\n    }\n\n    function _exec(ISafe safe, address target, uint256 value, bytes memory callData) internal {\n        bool success = safe.execTransactionFromModule(target, value, callData, ISafe.Operation.Call);\n        if (!success) revert ExecutionFailed();\n    }\n\n    function _delegatecall(ISafe safe, address target, bytes memory callData) internal {\n        bool success =\n            safe.execTransactionFromModule(target, 0, callData, ISafe.Operation.DelegateCall);\n        if (!success) revert ExecutionFailed();\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*             EXEC - REVERT ON FAIL & Return Values          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    /**\n     * Helper function to facilitate batched executions. Since Safe accounts do not support batched\n     * executions natively, we nudge the safe to delegatecall to ./utils/DCUTIL.sol, which then\n     * makes a multicall. This is to save on gas\n     */\n    function _execReturn(\n        ISafe safe,\n        Execution[] calldata executions\n    )\n        internal\n        returns (bytes[] memory retDatas)\n    {\n        retDatas = abi.decode(\n            _delegatecallReturn({\n                safe: safe,\n                target: UTIL,\n                callData: abi.encodeCall(BatchedExecUtil.executeReturn, executions)\n            }),\n            (bytes[])\n        );\n    }\n\n    function _execReturn(\n        ISafe safe,\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        returns (bytes memory retData)\n    {\n        bool success;\n        (success, retData) =\n            safe.execTransactionFromModuleReturnData(target, value, callData, ISafe.Operation.Call);\n        if (!success) revert ExecutionFailed();\n    }\n\n    function _delegatecallReturn(\n        ISafe safe,\n        address target,\n        bytes memory callData\n    )\n        internal\n        returns (bytes memory retData)\n    {\n        bool success;\n        (success, retData) = safe.execTransactionFromModuleReturnData(\n            target, 0, callData, ISafe.Operation.DelegateCall\n        );\n        if (!success) revert ExecutionFailed();\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        EXEC - TRY                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    /**\n     * Helper function to facilitate batched executions. Since Safe accounts do not support batched\n     * executions natively, we nudge the safe to delegatecall to ./utils/DCUTIL.sol, which then\n     * makes a multicall. This is to save on gas\n     */\n    function _tryExec(ISafe safe, Execution[] calldata executions) internal {\n        _tryDelegatecall({\n            safe: safe,\n            target: UTIL,\n            callData: abi.encodeCall(BatchedExecUtil.tryExecute, executions)\n        });\n    }\n\n    function _tryExec(ISafe safe, address target, uint256 value, bytes memory callData) internal {\n        bool success = safe.execTransactionFromModule(target, value, callData, ISafe.Operation.Call);\n        if (!success) emit TryExecutionFailed(safe, 0);\n    }\n\n    function _tryDelegatecall(ISafe safe, address target, bytes memory callData) internal {\n        bool success =\n            safe.execTransactionFromModule(target, 0, callData, ISafe.Operation.DelegateCall);\n        if (!success) emit TryExecutionFailed(safe, 0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              EXEC - TRY & Return Values                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Helper function to facilitate batched executions. Since Safe accounts do not support batched\n     * executions natively, we nudge the safe to delegatecall to ./utils/DCUTIL.sol, which then\n     * makes a multicall. This is to save on gas\n     */\n    function _tryExecReturn(\n        ISafe safe,\n        Execution[] calldata executions\n    )\n        internal\n        returns (bool[] memory success, bytes[] memory retDatas)\n    {\n        bytes memory tmp = _tryDelegatecallReturn({\n            safe: safe,\n            target: UTIL,\n            callData: abi.encodeCall(BatchedExecUtil.tryExecuteReturn, executions)\n        });\n        (success, retDatas) = abi.decode(tmp, (bool[], bytes[]));\n\n        uint256 length = success.length;\n        for (uint256 i; i < length; i++) {\n            if (!success[i]) emit TryExecutionFailed(safe, i);\n        }\n    }\n\n    function _tryExecReturn(\n        ISafe safe,\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        returns (bytes memory retData)\n    {\n        bool success;\n        (success, retData) =\n            safe.execTransactionFromModuleReturnData(target, value, callData, ISafe.Operation.Call);\n        if (!success) emit TryExecutionFailed(safe, 0);\n    }\n\n    function _tryDelegatecallReturn(\n        ISafe safe,\n        address target,\n        bytes memory callData\n    )\n        internal\n        returns (bytes memory retData)\n    {\n        bool success;\n        (success, retData) = safe.execTransactionFromModuleReturnData(\n            target, 0, callData, ISafe.Operation.DelegateCall\n        );\n\n        if (!success) emit TryExecutionFailed(safe, 0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     STATICCALL TRICK                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Safe account does not natively implement Enum.Operation.StaticCall,\n     * using a trick with simulateAndRevert to execute a staticcall.\n     * @param safe Safe account to execute the staticcall\n     * @param target Target contract to staticcall\n     * @param callData Data to be passed to the target contract\n     */\n    function _staticcallReturn(\n        ISafe safe,\n        address target,\n        bytes memory callData\n    )\n        internal\n        view\n        returns (bytes memory result)\n    {\n        bytes memory staticCallData = abi.encodeCall(Safe7579DCUtil.staticCall, (target, callData));\n        bytes memory simulationCallData =\n            abi.encodeCall(ISafe.simulateAndRevert, (address(UTIL), staticCallData));\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            pop(\n                staticcall(\n                    gas(),\n                    safe,\n                    add(simulationCallData, 0x20),\n                    mload(simulationCallData),\n                    0x00,\n                    0x20\n                )\n            )\n\n            let responseSize := sub(returndatasize(), 0x20)\n            result := mload(0x40)\n            mstore(0x40, add(result, responseSize))\n            returndatacopy(result, 0x20, responseSize)\n\n            if iszero(mload(0x00)) { revert(add(result, 0x20), mload(result)) }\n        }\n    }\n}\n"},"src/core/SetupDCUtil.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { Safe7579DCUtil } from \"../utils/DCUtil.sol\";\n\n/**\n * Deployes Safe7579DCUtil\n */\nabstract contract Safe7579DCUtilSetup {\n    address internal immutable UTIL;\n\n    constructor() {\n        UTIL = address(new Safe7579DCUtil());\n    }\n}\n"}},"settings":{"remappings":["@rhinestone/=node_modules/@rhinestone/","sentinellist/=node_modules/@rhinestone/sentinellist/src/","erc4337-validation/=node_modules/@rhinestone/erc4337-validation/src/","modulekit/=node_modules/@rhinestone/modulekit/src/","module-bases/=node_modules/@rhinestone/module-bases/src/","@ERC4337/=node_modules/@ERC4337/","account-abstraction/=node_modules/@ERC4337/account-abstraction/contracts/","account-abstraction-v0.6/=node_modules/@ERC4337/account-abstraction-v0.6/contracts/","@openzeppelin/=node_modules/@openzeppelin/","@safe-global/=node_modules/@safe-global/","ds-test/=node_modules/ds-test/src/","erc7579/=node_modules/erc7579/src/","forge-std/=node_modules/forge-std/src/","solady/=node_modules/solady/src/","solarray/=node_modules/solarray/src/","@prb/math/=node_modules/@prb/math/src/","@gnosis.pm/=node_modules/@gnosis.pm/","hardhat-deploy/=node_modules/hardhat-deploy/","hardhat/=node_modules/hardhat/"],"optimizer":{"enabled":true,"runs":3000},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
