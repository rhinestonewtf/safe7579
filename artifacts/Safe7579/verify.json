{
  "language": "Solidity",
  "sources": {
    "src/Safe7579.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport { IERC7579Account, Execution } from \"./interfaces/IERC7579Account.sol\";\nimport {\n    CallType,\n    ExecType,\n    ModeCode,\n    EXECTYPE_DEFAULT,\n    EXECTYPE_TRY,\n    CALLTYPE_SINGLE,\n    CALLTYPE_BATCH,\n    CALLTYPE_DELEGATECALL\n} from \"./lib/ModeLib.sol\";\nimport { ExecutionLib } from \"./lib/ExecutionLib.sol\";\nimport {\n    IValidator,\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_HOOK,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_FALLBACK\n} from \"erc7579/interfaces/IERC7579Module.sol\";\nimport { ModuleInstallUtil } from \"./utils/DCUtil.sol\";\nimport { AccessControl } from \"./core/AccessControl.sol\";\nimport { Initializer } from \"./core/Initializer.sol\";\nimport { SafeOp } from \"./core/SafeOp.sol\";\nimport { ISafe } from \"./interfaces/ISafe.sol\";\nimport { ISafe7579 } from \"./ISafe7579.sol\";\nimport {\n    PackedUserOperation,\n    UserOperationLib\n} from \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\nimport { _packValidationData } from \"@ERC4337/account-abstraction/contracts/core/Helpers.sol\";\nimport { IEntryPoint } from \"@ERC4337/account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport { IERC1271 } from \"./interfaces/IERC1271.sol\";\nimport { SupportViewer } from \"./core/SupportViewer.sol\";\n\nuint256 constant MULTITYPE_MODULE = 0;\n\n/**\n * @title ERC7579 Adapter for Safe accounts.\n * creates full ERC7579 compliance to Safe accounts\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n * @dev This contract is a Safe account implementation that supports ERC7579 operations.\n *    In order to facilitate full ERC7579 compliance, the contract implements the IERC7579Account\n *    interface.\n * This contract is an implementation of a Safe account supporting ERC7579 operations and complying\n * with the IERC7579Account interface. It serves as a Safe FallbackHandler and module for Safe\n * accounts, incorporating complex hacks to ensure ERC7579 compliance and requiring interactions and\n * event emissions to be done via the SafeProxy as msg.sender using Safe's\n * \"executeTransactionFromModule\" features.\n */\ncontract Safe7579 is ISafe7579, SafeOp, SupportViewer, AccessControl, Initializer {\n    using ExecutionLib for bytes;\n\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\"SafeMessage(bytes message)\");\n    bytes32 private constant SAFE_MSG_TYPEHASH =\n        0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;\n    // keccak256(\"safeSignature(bytes32,bytes32,bytes,bytes)\");\n    bytes4 private constant SAFE_SIGNATURE_MAGIC_VALUE = 0x5fd7e97d;\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function execute(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        withHook(IERC7579Account.execute.selector)\n        onlyEntryPointOrSelf\n    {\n        CallType callType;\n        ExecType execType;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            callType := mode\n            execType := shl(8, mode)\n        }\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*                   REVERT ON FAILED EXEC                    */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n        ISafe safe = ISafe(msg.sender);\n        if (execType == EXECTYPE_DEFAULT) {\n            // DEFAULT EXEC & BATCH CALL\n            if (callType == CALLTYPE_BATCH) {\n                Execution[] calldata executions = executionCalldata.decodeBatch();\n                _exec(safe, executions);\n            }\n            // DEFAULT EXEC & SINGLE CALL\n            else if (callType == CALLTYPE_SINGLE) {\n                (address target, uint256 value, bytes calldata callData) =\n                    executionCalldata.decodeSingle();\n                _exec(safe, target, value, callData);\n            }\n            // DEFAULT EXEC & DELEGATECALL\n            else if (callType == CALLTYPE_DELEGATECALL) {\n                address target = address(bytes20(executionCalldata[:20]));\n                bytes calldata callData = executionCalldata[20:];\n                _delegatecall(safe, target, callData);\n            }\n            // handle unsupported calltype\n            else {\n                revert UnsupportedCallType(callType);\n            }\n        }\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*                           TRY EXEC                         */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n        else if (execType == EXECTYPE_TRY) {\n            // TRY EXEC & BATCH CALL\n            if (callType == CALLTYPE_BATCH) {\n                Execution[] calldata executions = executionCalldata.decodeBatch();\n                _tryExec(safe, executions);\n            }\n            // TRY EXEC & SINGLE CALL\n            else if (callType == CALLTYPE_SINGLE) {\n                (address target, uint256 value, bytes calldata callData) =\n                    executionCalldata.decodeSingle();\n                _tryExec(safe, target, value, callData);\n            }\n            // TRY EXEC & DELEGATECALL\n            else if (callType == CALLTYPE_DELEGATECALL) {\n                address target = address(bytes20(executionCalldata[:20]));\n                bytes calldata callData = executionCalldata[20:];\n                _tryDelegatecall(safe, target, callData);\n            }\n            // handle unsupported calltype\n            else {\n                revert UnsupportedCallType(callType);\n            }\n        }\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*               HANDLE UNSUPPORTED EXEC TYPE                 */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n        else {\n            revert UnsupportedExecType(execType);\n        }\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        override\n        onlyExecutorModule\n        withHook(IERC7579Account.executeFromExecutor.selector)\n        withRegistry(_msgSender(), MODULE_TYPE_EXECUTOR)\n        returns (bytes[] memory returnDatas)\n    {\n        CallType callType;\n        ExecType execType;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            callType := mode\n            execType := shl(8, mode)\n        }\n        // using JUMPI to avoid stack too deep\n        return _executeReturn(execType, callType, executionCalldata);\n    }\n\n    /**\n     * Internal function that will be solely called by executeFromExecutor. Not super uniform code,\n     * but we need the JUMPI to avoid stack too deep, due to the modifiers in the\n     * executeFromExecutor function\n     */\n    function _executeReturn(\n        ExecType execType,\n        CallType callType,\n        bytes calldata executionCalldata\n    )\n        private\n        returns (bytes[] memory returnDatas)\n    {\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*                   REVERT ON FAILED EXEC                    */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n        if (execType == EXECTYPE_DEFAULT) {\n            // DEFAULT EXEC & BATCH CALL\n            if (callType == CALLTYPE_BATCH) {\n                Execution[] calldata executions = executionCalldata.decodeBatch();\n                returnDatas = _execReturn(ISafe(msg.sender), executions);\n            }\n            // DEFAULT EXEC & SINGLE CALL\n            else if (callType == CALLTYPE_SINGLE) {\n                (address target, uint256 value, bytes calldata callData) =\n                    executionCalldata.decodeSingle();\n                returnDatas = new bytes[](1);\n                returnDatas[0] = _execReturn(ISafe(msg.sender), target, value, callData);\n            }\n            // DEFAULT EXEC & DELEGATECALL\n            else if (callType == CALLTYPE_DELEGATECALL) {\n                address target = address(bytes20(executionCalldata[:20]));\n                bytes calldata callData = executionCalldata[20:];\n                returnDatas = new bytes[](1);\n                returnDatas[0] = _delegatecallReturn(ISafe(msg.sender), target, callData);\n            }\n            // handle unsupported calltype\n            else {\n                revert UnsupportedCallType(callType);\n            }\n        }\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*                           TRY EXEC                         */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n        else if (execType == EXECTYPE_TRY) {\n            // TRY EXEC & BATCH CALL\n            if (callType == CALLTYPE_BATCH) {\n                Execution[] calldata executions = executionCalldata.decodeBatch();\n                (, returnDatas) = _tryExecReturn(ISafe(msg.sender), executions);\n            }\n            // TRY EXEC & SINGLE CALL\n            else if (callType == CALLTYPE_SINGLE) {\n                (address target, uint256 value, bytes calldata callData) =\n                    executionCalldata.decodeSingle();\n                returnDatas = new bytes[](1);\n                returnDatas[0] = _tryExecReturn(ISafe(msg.sender), target, value, callData);\n            }\n            // TRY EXEC & DELEGATECALL\n            else if (callType == CALLTYPE_DELEGATECALL) {\n                address target = address(bytes20(executionCalldata[:20]));\n                bytes calldata callData = executionCalldata[20:];\n                returnDatas = new bytes[](1);\n                returnDatas[0] = _tryDelegatecallReturn(ISafe(msg.sender), target, callData);\n            }\n            // handle unsupported calltype\n            else {\n                revert UnsupportedCallType(callType);\n            }\n        }\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*               HANDLE UNSUPPORTED EXEC TYPE                 */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n        else {\n            revert UnsupportedExecType(execType);\n        }\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        onlyEntryPoint\n        returns (uint256 validSignature)\n    {\n        address validator;\n        uint256 nonce = userOp.nonce;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            validator := shr(96, nonce)\n        }\n\n        // check if validator is enabled. If not, use Safe's checkSignatures()\n        if (validator == address(0) || !_isValidatorInstalled(validator)) {\n            validSignature = _validateSignatures(userOp);\n        } else {\n            // bubble up the return value of the validator module\n            bytes memory retData = _execReturn({\n                safe: ISafe(msg.sender),\n                target: validator,\n                value: 0,\n                callData: abi.encodeCall(IValidator.validateUserOp, (userOp, userOpHash))\n            });\n            validSignature = abi.decode(retData, (uint256));\n        }\n\n        // pay prefund\n        if (missingAccountFunds != 0) {\n            _exec({\n                safe: ISafe(msg.sender),\n                target: entryPoint(),\n                value: missingAccountFunds,\n                callData: \"\"\n            });\n        }\n    }\n\n    /**\n     * Function used as signature check fallback, if no valid validation module was selected.\n     * will use safe's ECDSA multisig. This code was copied of Safe's ERC4337 module\n     */\n    function _validateSignatures(PackedUserOperation calldata userOp)\n        internal\n        view\n        returns (uint256 validationData)\n    {\n        (bytes memory operationData, uint48 validAfter, uint48 validUntil, bytes memory signatures)\n        = getSafeOp(userOp, entryPoint());\n        try ISafe((msg.sender)).checkSignatures(keccak256(operationData), operationData, signatures)\n        {\n            // The timestamps are validated by the entry point,\n            // therefore we will not check them again\n            validationData = _packValidationData({\n                sigFailed: false,\n                validUntil: validUntil,\n                validAfter: validAfter\n            });\n        } catch {\n            validationData = _packValidationData({\n                sigFailed: true,\n                validUntil: validUntil,\n                validAfter: validAfter\n            });\n        }\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function isValidSignature(\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4 magicValue)\n    {\n        ISafe safe = ISafe(msg.sender);\n\n        // check for safe's approved hashes\n        if (data.length == 0) {\n            bytes32 messageHash = keccak256(\n                EIP712.encodeMessageData(\n                    safe.domainSeparator(),\n                    SAFE_MSG_TYPEHASH,\n                    abi.encode(keccak256(abi.encode(hash)))\n                )\n            );\n\n            require(safe.signedMessages(messageHash) != 0, \"Hash not approved\");\n            // return magic value\n            return IERC1271.isValidSignature.selector;\n        }\n        address validationModule = address(bytes20(data[:20]));\n\n        // If validation module with address(0) or no valid validator was provided,\n        // The signature validation mechanism falls back to Safe's checkSignatures() function\n        if (validationModule == address(0) || !_isValidatorInstalled(validationModule)) {\n            bytes memory messageData = EIP712.encodeMessageData(\n                safe.domainSeparator(), SAFE_MSG_TYPEHASH, abi.encode(keccak256(abi.encode(hash)))\n            );\n\n            bytes32 messageHash = keccak256(messageData);\n\n            safe.checkSignatures(messageHash, messageData, data[20:]);\n            return IERC1271.isValidSignature.selector;\n        }\n\n        // if a installed validator module was selected, use 7579 validation module\n        bytes memory ret = _staticcallReturn({\n            safe: ISafe(msg.sender),\n            target: validationModule,\n            callData: abi.encodeCall(\n                IValidator.isValidSignatureWithSender, (_msgSender(), hash, data[20:])\n            )\n        });\n        magicValue = abi.decode(ret, (bytes4));\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function installModule(\n        uint256 moduleType,\n        address module,\n        bytes calldata initData\n    )\n        external\n        override\n        withHook(IERC7579Account.installModule.selector)\n        onlyEntryPointOrSelf\n    {\n        // internal install functions will decode the initData param, and return sanitized\n        // moduleInitData. This is the initData that will be passed to Module.onInstall()\n        bytes memory moduleInitData;\n        if (moduleType == MODULE_TYPE_VALIDATOR) {\n            moduleInitData = _installValidator(module, initData);\n        } else if (moduleType == MODULE_TYPE_EXECUTOR) {\n            moduleInitData = _installExecutor(module, initData);\n        } else if (moduleType == MODULE_TYPE_FALLBACK) {\n            moduleInitData = _installFallbackHandler(module, initData);\n        } else if (moduleType == MODULE_TYPE_HOOK) {\n            moduleInitData = _installHook(module, initData);\n        } else if (moduleType == MULTITYPE_MODULE) {\n            moduleInitData = _multiTypeInstall(module, initData);\n        } else {\n            revert UnsupportedModuleType(moduleType);\n        }\n\n        // Initialize Module via Safe\n        _delegatecall({\n            safe: ISafe(msg.sender),\n            target: UTIL,\n            callData: abi.encodeCall(\n                ModuleInstallUtil.installModule, (moduleType, module, moduleInitData)\n            )\n        });\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function uninstallModule(\n        uint256 moduleType,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        override\n        tryWithHook(module, IERC7579Account.uninstallModule.selector)\n        onlyEntryPointOrSelf\n    {\n        // internal uninstall functions will decode the deInitData param, and return sanitized\n        // moduleDeInitData. This is the initData that will be passed to Module.onUninstall()\n        bytes memory moduleDeInitData;\n        if (moduleType == MODULE_TYPE_VALIDATOR) {\n            moduleDeInitData = _uninstallValidator(module, deInitData);\n        } else if (moduleType == MODULE_TYPE_EXECUTOR) {\n            moduleDeInitData = _uninstallExecutor(module, deInitData);\n        } else if (moduleType == MODULE_TYPE_FALLBACK) {\n            moduleDeInitData = _uninstallFallbackHandler(module, deInitData);\n        } else if (moduleType == MODULE_TYPE_HOOK) {\n            moduleDeInitData = _uninstallHook(module, deInitData);\n        } else if (moduleType == MULTITYPE_MODULE) {\n            moduleDeInitData = _multiTypeUninstall(module, deInitData);\n        } else {\n            revert UnsupportedModuleType(moduleType);\n        }\n\n        // Deinitialize Module via Safe.\n        // We are using \"try\" here, to avoid DoS. A module could revert in 'onUninstall' and prevent\n        // the account from removing the module\n        _tryDelegatecall({\n            safe: ISafe(msg.sender),\n            target: UTIL,\n            callData: abi.encodeCall(\n                ModuleInstallUtil.unInstallModule, (moduleType, module, moduleDeInitData)\n            )\n        });\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function isModuleInstalled(\n        uint256 moduleType,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool)\n    {\n        if (moduleType == MODULE_TYPE_VALIDATOR) {\n            // Safe7579 adapter allows for validator fallback to Safe's checkSignatures().\n            // It can thus be considered a valid validator module\n            if (module == msg.sender) return true;\n            return _isValidatorInstalled(module);\n        } else if (moduleType == MODULE_TYPE_EXECUTOR) {\n            return _isExecutorInstalled(module);\n        } else if (moduleType == MODULE_TYPE_FALLBACK) {\n            return _isFallbackHandlerInstalled(module, additionalContext);\n        } else if (moduleType == MODULE_TYPE_HOOK) {\n            return _isHookInstalled(module, additionalContext);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function getNonce(address safe, address validator) external view returns (uint256 nonce) {\n        uint192 key = uint192(bytes24(bytes20(address(validator))));\n        nonce = IEntryPoint(entryPoint()).getNonce(safe, key);\n    }\n}\n\nlibrary EIP712 {\n    function encodeMessageData(\n        bytes32 domainSeparator,\n        bytes32 typeHash,\n        bytes memory message\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(\n            bytes1(0x19),\n            bytes1(0x01),\n            domainSeparator,\n            keccak256(abi.encodePacked(typeHash, message))\n        );\n    }\n}\n"
    },
    "src/interfaces/IERC7579Account.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { CallType, ExecType, ModeCode } from \"../lib/ModeLib.sol\";\n\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n\ninterface IERC7579AccountEvents {\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n}\n\ninterface IERC7579AccountView {\n    /**\n     * @dev Returns the account id of the smart account\n     * @return accountImplementationId the account id of the smart account\n     * the accountId should be structured like so:\n     *        \"vendorname.accountname.semver\"\n     */\n    function accountId() external view returns (string memory accountImplementationId);\n\n    /**\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\n     * @param encodedMode the encoded mode\n     */\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\n\n    /**\n     * Function to check if the account supports installation of a certain module type Id\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     */\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\n}\n\ninterface IERC7579Account is IERC7579AccountEvents, IERC7579AccountView {\n    // Error thrown when an unsupported ModuleType is requested\n    error UnsupportedModuleType(uint256 moduleTypeId);\n    // Error thrown when an execution with an unsupported CallType was made\n    error UnsupportedCallType(CallType callType);\n    // Error thrown when an execution with an unsupported ExecType was made\n    error UnsupportedExecType(ExecType execType);\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n\n    function execute(ModeCode mode, bytes calldata executionCalldata) external;\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by Executor Modules\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        returns (bytes[] memory returnData);\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(bytes32 hash, bytes calldata data) external returns (bytes4);\n\n    /**\n     * @dev installs a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external;\n\n    /**\n     * @dev uninstalls a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external;\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool);\n}\n"
    },
    "src/lib/ModeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title ModeLib\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n * encoding is used.\n *    Function Signature of execute function:\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n * context.\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n * implement\n * more complex execution modes may use the entire bytes32.\n *\n * |--------------------------------------------------------------------|\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n * |--------------------------------------------------------------------|\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n * |--------------------------------------------------------------------|\n *\n * CALLTYPE: 1 byte\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\n * decoded.\n * It can be either single, batch or delegatecall. In the future different calls could be added.\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n *\n * EXECTYPE: 1 byte\n * ExecType is used to determine how the account should handle the execution.\n * It can indicate if the execution should revert on failure or continue execution.\n * In the future more execution modes may be added.\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n * a batch fails, the entire batch is reverted\n *\n * UNUSED: 4 bytes\n * Unused bytes are reserved for future use.\n *\n * ModeSelector: bytes4\n * The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n * their accounts.\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n * this is to prevent collisions between different vendors, while allowing innovation and the\n * development of new features without coordination between ERC-7579 implementing accounts\n *\n * ModePayload: 22 bytes\n * Mode payload is used to pass additional data to the smart account execution, this may be\n * interpreted depending on the ModeSelector\n *\n * ExecutionCallData: n bytes\n * single, delegatecall or batch exec abi.encoded as bytes\n */\n\n// Custom type for improved developer experience\ntype ModeCode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/**\n * @dev ModeLib is a helper library to encode/decode ModeCodes\n */\nlibrary ModeLib {\n    function decode(ModeCode mode)\n        internal\n        pure\n        returns (\n            CallType _calltype,\n            ExecType _execType,\n            ModeSelector _modeSelector,\n            ModePayload _modePayload\n        )\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function encode(\n        CallType callType,\n        ExecType execType,\n        ModeSelector mode,\n        ModePayload payload\n    )\n        internal\n        pure\n        returns (ModeCode)\n    {\n        return ModeCode.wrap(\n            bytes32(\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\n            )\n        );\n    }\n\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { eqModeSelector as == } for ModeSelector global;\nusing { eqCallType as == } for CallType global;\nusing { neqCallType as != } for CallType global;\nusing { eqExecType as == } for ExecType global;\n\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction neqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n"
    },
    "src/lib/ExecutionLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\n\n/**\n * Helper Library for decoding Execution calldata\n * malloc for memory allocation is bad for gas. use this assembly instead\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\nlibrary ExecutionLib {\n    function decodeBatch(bytes calldata callData)\n        internal\n        pure\n        returns (Execution[] calldata executionBatch)\n    {\n        /*\n         * Batch Call Calldata Layout\n         * Offset (in bytes)    | Length (in bytes) | Contents\n         * 0x0                  | 0x4               | bytes4 function selector\n        *  0x4                  | -                 |\n        abi.encode(IERC7579Execution.Execution[])\n         */\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            let dataPointer := add(callData.offset, calldataload(callData.offset))\n\n            // Extract the ERC7579 Executions\n            executionBatch.offset := add(dataPointer, 32)\n            executionBatch.length := calldataload(dataPointer)\n        }\n    }\n\n    function encodeBatch(Execution[] memory executions)\n        internal\n        pure\n        returns (bytes memory callData)\n    {\n        callData = abi.encode(executions);\n    }\n\n    function decodeSingle(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (address target, uint256 value, bytes calldata callData)\n    {\n        target = address(bytes20(executionCalldata[0:20]));\n        value = uint256(bytes32(executionCalldata[20:52]));\n        callData = executionCalldata[52:];\n    }\n\n    function encodeSingle(\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        pure\n        returns (bytes memory userOpCalldata)\n    {\n        userOpCalldata = abi.encodePacked(target, value, callData);\n    }\n}\n"
    },
    "node_modules/erc7579/src/interfaces/IERC7579Module.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\n\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\n\ninterface IModule {\n    error AlreadyInitialized(address smartAccount);\n    error NotInitialized(address smartAccount);\n\n    /**\n     * @dev This function is called by the smart account during installation of the module\n     * @param data arbitrary data that may be required on the module during `onInstall`\n     * initialization\n     *\n     * MUST revert on error (i.e. if module is already enabled)\n     */\n    function onInstall(bytes calldata data) external;\n\n    /**\n     * @dev This function is called by the smart account during uninstallation of the module\n     * @param data arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization\n     *\n     * MUST revert on error\n     */\n    function onUninstall(bytes calldata data) external;\n\n    /**\n     * @dev Returns boolean value if module is a certain type\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *\n     * MUST return true if the module is of the given type and false otherwise\n     */\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * @dev Returns if the module was already initialized for a provided smartaccount\n     */\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n\ninterface IValidator is IModule {\n    error InvalidTargetAddress(address target);\n\n    /**\n     * @dev Validates a transaction on behalf of the account.\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\n     * The MSA MUST clean up the userOp before sending it to the validator.\n     * @param userOpHash The hash of the user operation to be validated\n     * @return return value according to ERC-4337\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        returns (uint256);\n\n    /**\n     * Validator can be used for ERC-1271 validation\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IExecutor is IModule { }\n\ninterface IHook is IModule {\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        returns (bytes memory hookData);\n\n    function postCheck(bytes calldata hookData) external;\n}\n\ninterface IFallback is IModule { }\n"
    },
    "src/utils/DCUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\nimport { IModule as IERC7579Module } from \"../interfaces/IERC7579Module.sol\";\nimport { IERC7579AccountEvents } from \"../interfaces/IERC7579Account.sol\";\n\ncontract ModuleInstallUtil is IERC7579AccountEvents {\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n    {\n        IERC7579Module(module).onInstall(initData);\n        emit ModuleInstalled(moduleTypeId, address(module));\n    }\n\n    function unInstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n    {\n        IERC7579Module(module).onUninstall(initData);\n        emit ModuleUninstalled(moduleTypeId, address(module));\n    }\n}\n\ncontract BatchedExecUtil {\n    function tryExecute(Execution[] calldata executions) external {\n        uint256 length = executions.length;\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            _tryExecute(_exec.target, _exec.value, _exec.callData);\n        }\n    }\n\n    function execute(Execution[] calldata executions) external {\n        uint256 length = executions.length;\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            _execute(_exec.target, _exec.value, _exec.callData);\n        }\n    }\n\n    function executeReturn(Execution[] calldata executions)\n        external\n        returns (bytes[] memory result)\n    {\n        uint256 length = executions.length;\n        result = new bytes[](length);\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            result[i] = _execute(_exec.target, _exec.value, _exec.callData);\n        }\n    }\n\n    function tryExecuteReturn(Execution[] calldata executions)\n        external\n        returns (bool[] memory success, bytes[] memory result)\n    {\n        uint256 length = executions.length;\n        result = new bytes[](length);\n        success = new bool[](length);\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            (success[i], result[i]) = _tryExecute(_exec.target, _exec.value, _exec.callData);\n        }\n    }\n\n    function _execute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory result)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    function _tryExecute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bool success, bytes memory result)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            success := call(gas(), target, value, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n}\n\ncontract Safe7579DCUtil is ModuleInstallUtil, BatchedExecUtil {\n    function staticCall(address target, bytes memory data) external view {\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            let success := staticcall(gas(), target, add(data, 0x20), mload(data), 0x00, 0x00)\n            returndatacopy(ptr, 0x00, returndatasize())\n            if success { return(ptr, returndatasize()) }\n            revert(ptr, returndatasize())\n        }\n    }\n}\n"
    },
    "src/core/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { HandlerContext } from \"@safe-global/safe-contracts/contracts/handler/HandlerContext.sol\";\nimport { AccountBase } from \"erc7579/core/AccountBase.sol\";\n\n/**\n * Implements AccessControl for Safe7579 adapter.\n * Since Safe7579 Adapter is installed as a fallback handler on the safe account, we are making use\n * of handlercontext (ERC2771)\n * @author zeroknots.eth | rhinestone.wtf\n */\nabstract contract AccessControl is HandlerContext, AccountBase {\n    modifier onlyEntryPointOrSelf() virtual override {\n        if (!(_msgSender() == entryPoint() || msg.sender == _msgSender())) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    modifier onlyEntryPoint() virtual override {\n        if (_msgSender() != entryPoint()) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    function entryPoint() public view virtual override returns (address) {\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n    }\n}\n"
    },
    "src/core/Initializer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ISafe7579 } from \"../ISafe7579.sol\";\nimport { ISafe } from \"../interfaces/ISafe.sol\";\nimport \"../DataTypes.sol\";\nimport { ModuleInstallUtil } from \"../utils/DCUtil.sol\";\nimport { ModuleManager } from \"./ModuleManager.sol\";\n\nimport {\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_HOOK,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_FALLBACK\n} from \"erc7579/interfaces/IERC7579Module.sol\";\nimport { IERC7484 } from \"../interfaces/IERC7484.sol\";\nimport { SentinelList4337Lib } from \"sentinellist/SentinelList4337.sol\";\nimport { SentinelListLib } from \"sentinellist/SentinelList.sol\";\n\n/**\n * Functions that can be used to initialze Safe7579 for a Safe Account\n * @author zeroknots.eth | rhinestone.wtf\n */\nabstract contract Initializer is ISafe7579, ModuleManager {\n    using SentinelList4337Lib for SentinelList4337Lib.SentinelList;\n\n    event Safe7579Initialized(address indexed safe);\n\n    error InvalidInitData(address safe);\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function initializeAccountWithValidators(ModuleInit[] calldata validators)\n        external\n        override\n        onlyEntryPointOrSelf\n    {\n        // this will revert if already initialized\n        $validators.init({ account: msg.sender });\n        uint256 length = validators.length;\n        for (uint256 i; i < length; i++) {\n            ModuleInit calldata validator = validators[i];\n            $validators.push({ account: msg.sender, newEntry: validator.module });\n            // @dev No events emitted here. Launchpad is expected to do this.\n            // at this point, the safeproxy singleton is not yet updated to the SafeSingleton\n            // calling execTransactionFromModule is not available yet.\n        }\n        emit Safe7579Initialized(msg.sender);\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function initializeAccount(\n        ModuleInit[] calldata validators,\n        ModuleInit[] calldata executors,\n        ModuleInit[] calldata fallbacks,\n        ModuleInit[] calldata hooks,\n        RegistryInit calldata registryInit\n    )\n        external\n        onlyEntryPointOrSelf\n    {\n        _configureRegistry(registryInit.registry, registryInit.attesters, registryInit.threshold);\n        // this will revert if already initialized\n        _initModules(validators, executors, fallbacks, hooks);\n    }\n\n    /**\n     * _initModules may be used via launchpad deploymet or directly by already deployed Safe\n     * accounts\n     */\n    function _initModules(\n        ModuleInit[] calldata validators,\n        ModuleInit[] calldata executors,\n        ModuleInit[] calldata fallbacks,\n        ModuleInit[] calldata hooks\n    )\n        internal\n    {\n        bytes memory moduleInitData;\n        uint256 length = validators.length;\n        // if this function is called by the launchpad, validators will be initialized via\n        // launchpadValidators()\n        // to avoid double initialization, we check if the validators are already initialized\n        if (!$validators.alreadyInitialized({ account: msg.sender })) {\n            $validators.init({ account: msg.sender });\n            for (uint256 i; i < length; i++) {\n                ModuleInit calldata validator = validators[i];\n                // enable module on Safe7579,  initialize module via Safe, emit events\n                moduleInitData = _installValidator(validator.module, validator.initData);\n\n                // Initialize Module via Safe\n                _delegatecall({\n                    safe: ISafe(msg.sender),\n                    target: UTIL,\n                    callData: abi.encodeCall(\n                        ModuleInstallUtil.installModule,\n                        (MODULE_TYPE_VALIDATOR, validator.module, moduleInitData)\n                    )\n                });\n            }\n        } else if (length != 0) {\n            revert InvalidInitData(msg.sender);\n        }\n\n        // this will revert if already initialized.\n        $executors.init({ account: msg.sender });\n\n        length = executors.length;\n        for (uint256 i; i < length; i++) {\n            ModuleInit calldata executor = executors[i];\n            // enable module on Safe7579,  initialize module via Safe, emit events\n            moduleInitData = _installExecutor(executor.module, executor.initData);\n\n            // Initialize Module via Safe\n            _delegatecall({\n                safe: ISafe(msg.sender),\n                target: UTIL,\n                callData: abi.encodeCall(\n                    ModuleInstallUtil.installModule,\n                    (MODULE_TYPE_EXECUTOR, executor.module, moduleInitData)\n                )\n            });\n        }\n\n        length = fallbacks.length;\n        for (uint256 i; i < length; i++) {\n            ModuleInit calldata _fallback = fallbacks[i];\n            // enable module on Safe7579,  initialize module via Safe, emit events\n            moduleInitData = _installFallbackHandler(_fallback.module, _fallback.initData);\n\n            // Initialize Module via Safe\n            _delegatecall({\n                safe: ISafe(msg.sender),\n                target: UTIL,\n                callData: abi.encodeCall(\n                    ModuleInstallUtil.installModule,\n                    (MODULE_TYPE_FALLBACK, _fallback.module, moduleInitData)\n                )\n            });\n        }\n\n        length = hooks.length;\n        for (uint256 i; i < length; i++) {\n            ModuleInit calldata hook = hooks[i];\n            // enable module on Safe7579,  initialize module via Safe, emit events\n            moduleInitData = _installHook(hook.module, hook.initData);\n\n            // Initialize Module via Safe\n            _delegatecall({\n                safe: ISafe(msg.sender),\n                target: UTIL,\n                callData: abi.encodeCall(\n                    ModuleInstallUtil.installModule, (MODULE_TYPE_HOOK, hook.module, moduleInitData)\n                )\n            });\n        }\n\n        emit Safe7579Initialized(msg.sender);\n    }\n\n    /**\n     * @inheritdoc ISafe7579\n     */\n    function setRegistry(\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    )\n        external\n        onlyEntryPointOrSelf\n    {\n        _configureRegistry(registry, attesters, threshold);\n    }\n}\n"
    },
    "src/core/SafeOp.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport {\n    PackedUserOperation,\n    UserOperationLib\n} from \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\nimport { SAFE_OP_TYPEHASH, ISafeOp } from \"../interfaces/ISafeOp.sol\";\n\nabstract contract SafeOp is ISafeOp {\n    using UserOperationLib for PackedUserOperation;\n\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    /**\n     * @dev Decodes an ERC-4337 user operation into a Safe operation.\n     * @param userOp The ERC-4337 user operation.\n     * @return operationData Encoded EIP-712 Safe operation data bytes used for signature\n     * verification.\n     * @return validAfter The timestamp the user operation is valid from.\n     * @return validUntil The timestamp the user operation is valid until.\n     * @return signatures The Safe owner signatures extracted from the user operation.\n     */\n    function getSafeOp(\n        PackedUserOperation calldata userOp,\n        address entryPoint\n    )\n        public\n        view\n        returns (\n            bytes memory operationData,\n            uint48 validAfter,\n            uint48 validUntil,\n            bytes memory signatures\n        )\n    {\n        // Extract additional Safe operation fields from the user operation signature which is\n        // encoded as:\n        // `abi.encodePacked(validAfter, validUntil, signatures)`\n        {\n            bytes calldata sig = userOp.signature;\n            validAfter = uint48(bytes6(sig[0:6]));\n            validUntil = uint48(bytes6(sig[6:12]));\n            signatures = sig[12:];\n        }\n\n        // It is important that **all** user operation fields are represented in the `SafeOp` data\n        // somehow, to prevent\n        // user operations from being submitted that do not fully respect the user preferences. The\n        // only exception is\n        // the `signature` bytes. Note that even `initCode` needs to be represented in the operation\n        // data, otherwise\n        // it can be replaced with a more expensive initialization that would charge the user\n        // additional fees.\n        {\n            // In order to work around Solidity \"stack too deep\" errors related to too many stack\n            // variables, manually\n            // encode the `SafeOp` fields into a memory `struct` for computing the EIP-712\n            // struct-hash. This works\n            // because the `EncodedSafeOpStruct` struct has no \"dynamic\" fields so its memory layout\n            // is identical to the\n            // result of `abi.encode`-ing the individual fields.\n            EncodedSafeOpStruct memory encodedSafeOp = EncodedSafeOpStruct({\n                typeHash: SAFE_OP_TYPEHASH,\n                safe: userOp.sender,\n                nonce: userOp.nonce,\n                initCodeHash: keccak256(userOp.initCode),\n                callDataHash: keccak256(userOp.callData),\n                verificationGasLimit: uint128(userOp.unpackVerificationGasLimit()),\n                callGasLimit: uint128(userOp.unpackCallGasLimit()),\n                preVerificationGas: userOp.preVerificationGas,\n                maxPriorityFeePerGas: uint128(userOp.unpackMaxPriorityFeePerGas()),\n                maxFeePerGas: uint128(userOp.unpackMaxFeePerGas()),\n                paymasterAndDataHash: keccak256(userOp.paymasterAndData),\n                validAfter: validAfter,\n                validUntil: validUntil,\n                entryPoint: entryPoint\n            });\n\n            bytes32 safeOpStructHash;\n            // solhint-disable-next-line no-inline-assembly\n            assembly (\"memory-safe\") {\n                // Since the `encodedSafeOp` value's memory layout is identical to the result of\n                // `abi.encode`-ing the\n                // individual `SafeOp` fields, we can pass it directly to `keccak256`. Additionally,\n                // there are 14\n                // 32-byte fields to hash, for a length of `14 * 32 = 448` bytes.\n                safeOpStructHash := keccak256(encodedSafeOp, 448)\n            }\n\n            operationData =\n                abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeOpStructHash);\n        }\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, block.chainid, this));\n    }\n}\n"
    },
    "src/interfaces/ISafe.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface ISafe {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    )\n        external;\n\n    /**\n     * @dev Allows a Module to execute a Safe transaction without any further confirmations.\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     */\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    )\n        external\n        returns (bool success);\n\n    /**\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)\n     * and return data\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     * @return success Boolean flag indicating if the call succeeded.\n     * @return returnData Data returned by the call.\n     */\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    )\n        external\n        returns (bool success, bytes memory returnData);\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert\n     * otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract\n     * signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    )\n        external\n        view;\n\n    function signedMessages(bytes32) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\n     * @return bytes32 The domain separator hash.\n     */\n    function domainSeparator() external view returns (bytes32);\n\n    function VERSION() external pure returns (string memory);\n\n    function getStorageAt(uint256 offset, uint256 length) external view returns (bytes memory);\n\n    /**\n     * @dev Returns array of modules.\n     * @param start Start of the page.\n     * @param pageSize Maximum number of modules that should be returned.\n     * @return array Array of modules.\n     * @return next Start of the next page.\n     */\n    function getModulesPaginated(\n        address start,\n        uint256 pageSize\n    )\n        external\n        view\n        returns (address[] memory array, address next);\n\n    /**\n     * @notice Enables the module `module` for the Safe.\n     * @dev This can only be done via a Safe transaction.\n     * @param module Module to be enabled.\n     */\n    function enableModule(address module) external;\n\n    function setFallbackHandler(address handler) external;\n\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external;\n}\n"
    },
    "src/ISafe7579.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./DataTypes.sol\";\nimport { IERC7579Account } from \"./interfaces/IERC7579Account.sol\";\nimport { ModeCode } from \"./lib/ModeLib.sol\";\nimport { PackedUserOperation } from\n    \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\nimport { ISafeOp } from \"./interfaces/ISafeOp.sol\";\n\n/**\n * @title ERC7579 Adapter for Safe accounts.\n * creates full ERC7579 compliance to Safe accounts\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\ninterface ISafe7579 is IERC7579Account, ISafeOp {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         Validation                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * ERC4337 v0.7 validation function\n     * @dev expects that a ERC7579 validator module is encoded within the UserOp nonce.\n     *         if no validator module is provided, it will fallback to validate the transaction with\n     *         Safe's signers\n     */\n    function validateUserOp(\n        PackedUserOperation memory userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        returns (uint256 packedValidSig);\n\n    /**\n     * Will use Safe's signed messages or checkSignatures features or ERC7579 validation modules\n     * if no signature is provided, it makes use of Safe's signedMessages\n     * if address(0) or a non-installed validator module is provided, it will use Safe's\n     * checkSignatures\n     * if a valid validator module is provided, it will use the module's validateUserOp function\n     *    @param hash message hash of ERC1271 request\n     *    @param data abi.encodePacked(address validationModule, bytes signatures)\n     */\n    function isValidSignature(\n        bytes32 hash,\n        bytes memory data\n    )\n        external\n        view\n        returns (bytes4 magicValue);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         Executions                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Executes a transaction on behalf of the Safe account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @dev AccessControl: only Self of Entrypoint can install modules\n     * Safe7579 supports the following feature set:\n     *    CallTypes:\n     *             - CALLTYPE_SINGLE\n     *             - CALLTYPE_BATCH\n     *             - CALLTYPE_DELEGATECALL\n     *    ExecTypes:\n     *             - EXECTYPE_DEFAULT (revert if not successful)\n     *             - EXECTYPE_TRY\n     *    If a different mode is selected, this function will revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function execute(ModeCode mode, bytes memory executionCalldata) external;\n\n    /**\n     * @dev Executes a transaction on behalf of the Safe account.\n     *         This function is intended to be called by executor modules\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @dev AccessControl: only enabled executor modules\n     * Safe7579 supports the following feature set:\n     *    CallTypes:\n     *             - CALLTYPE_SINGLE\n     *             - CALLTYPE_BATCH\n     *             - CALLTYPE_DELEGATECALL\n     *    ExecTypes:\n     *             - EXECTYPE_DEFAULT (revert if not successful)\n     *             - EXECTYPE_TRY\n     *    If a different mode is selected, this function will revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes memory executionCalldata\n    )\n        external\n        returns (bytes[] memory returnDatas);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      Manage Modules                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Installs a 7579 Module of a certain type on the smart account\n     * @dev The module has to be initialized from msg.sender == SafeProxy, we thus use a\n     *    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579\n     *    module and emits the ModuleInstall/ModuleUnintall events\n     * @dev AccessControl: only Self of Entrypoint can install modules\n     * @dev If the safe set a registry, ERC7484 registry will be queried before installing\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @param moduleType the module type ID according the ERC-7579 spec\n     *                   Note: MULTITYPE_MODULE (uint(0)) is a special type to install a module with\n     *                         multiple types\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(uint256 moduleType, address module, bytes memory initData) external;\n\n    /**\n     * Uninstalls a Module of a certain type on the smart account.\n     * @dev The module has to be initialized from msg.sender == SafeProxy, we thus use a\n     *    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579\n     *    module and emits the ModuleInstall/ModuleUnintall events\n     * @dev AccessControl: only Self of Entrypoint can install modules\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @param moduleType the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleType,\n        address module,\n        bytes memory deInitData\n    )\n        external;\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleType the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleType,\n        address module,\n        bytes memory additionalContext\n    )\n        external\n        view\n        returns (bool);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   Initialize Safe7579                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * This function can be called by the Launchpad.initSafe7579() or by already existing Safes that\n     * want to use Safe7579\n     * if this is called by the Launchpad, it is expected that launchpadValidators() was called\n     * previously, and the param validators is empty\n     * @param validators validator modules and initData\n     * @param executors executor modules and initData\n     * @param executors executor modules and initData\n     * @param fallbacks fallback modules and initData\n     * @param hooks hook module and initData\n     * @param registryInit (OPTIONAL) registry, attesters and threshold for IERC7484 Registry\n     *                    If not provided, the registry will be set to the zero address, and no\n     *                    registry checks will be performed\n     */\n    function initializeAccount(\n        ModuleInit[] memory validators,\n        ModuleInit[] memory executors,\n        ModuleInit[] memory fallbacks,\n        ModuleInit[] memory hooks,\n        RegistryInit memory registryInit\n    )\n        external;\n\n    /**\n     * This function is intended to be called by Launchpad.validateUserOp()\n     * @dev it will initialize the SentinelList4337 list for validators, and sstore all\n     * validators\n     * @dev Since this function has to be 4337 compliant (storage access), only validator storage is  acccess\n     * @dev Note: this function DOES NOT call onInstall() on the validator modules or emit\n     * ModuleInstalled events. this has to be done by the launchpad\n     */\n    function initializeAccountWithValidators(ModuleInit[] memory validators) external;\n\n    /**\n     * Configure the Safe7579 with a IERC7484 registry\n     * @param registry IERC7484 registry\n     * @param attesters list of attesters\n     * @param threshold number of attesters required\n     */\n    function setRegistry(IERC7484 registry, address[] memory attesters, uint8 threshold) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   Query Account Details                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    function getValidatorsPaginated(\n        address cursor,\n        uint256 pageSize\n    )\n        external\n        view\n        returns (address[] memory array, address next);\n\n    /**\n     * Get the current active global hook\n     */\n    function getActiveHook() external view returns (address hook);\n\n    /**\n     * Get the current active selector hook\n     */\n    function getActiveHook(bytes4 selector) external view returns (address hook);\n\n    function getExecutorsPaginated(\n        address cursor,\n        uint256 size\n    )\n        external\n        view\n        returns (address[] memory array, address next);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        Query Misc                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Safe7579 is using validator selection encoding in the userop nonce.\n     * to make it easier for SDKs / devs to integrate, this function can be\n     * called to get the next nonce for a specific validator\n     * @param safe address of safe account\n     * @param validator ERC7579 validator to encode\n     */\n    function getNonce(address safe, address validator) external view returns (uint256 nonce);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       Custom Errors                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    error InvalidModule(address module);\n    error InvalidModuleType(address module, uint256 moduleType);\n\n    // fallback handlers\n    error InvalidInput();\n    error InvalidCallType(CallType callType);\n    error NoFallbackHandler(bytes4 msgSig);\n    error InvalidFallbackHandler(bytes4 msgSig);\n    error FallbackInstalled(bytes4 msgSig);\n\n    // Hooks\n    error HookAlreadyInstalled(address currentHook);\n    error InvalidHookType();\n\n    // Registry Adapter\n    event ERC7484RegistryConfigured(address indexed smartAccount, IERC7484 indexed registry);\n}\n"
    },
    "node_modules/@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/PackedUserOperation.sol\";\nimport {calldataKeccak, min} from \"./Helpers.sol\";\n\n/**\n * Utility functions helpful when working with UserOperation structs.\n */\nlibrary UserOperationLib {\n\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\n    /**\n     * Get sender from user operation data.\n     * @param userOp - The user operation data.\n     */\n    function getSender(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {\n            data := calldataload(userOp)\n        }\n        return address(uint160(data));\n    }\n\n    /**\n     * Relayer/block builder might submit the TX with higher priorityFee,\n     * but the user should not pay above what he signed for.\n     * @param userOp - The user operation data.\n     */\n    function gasPrice(\n        PackedUserOperation calldata userOp\n    ) internal view returns (uint256) {\n        unchecked {\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    /**\n     * Pack the user operation data into bytes for hashing.\n     * @param userOp - The user operation data.\n     */\n    function encode(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes memory ret) {\n        address sender = getSender(userOp);\n        uint256 nonce = userOp.nonce;\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\n        bytes32 accountGasLimits = userOp.accountGasLimits;\n        uint256 preVerificationGas = userOp.preVerificationGas;\n        bytes32 gasFees = userOp.gasFees;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\n\n        return abi.encode(\n            sender, nonce,\n            hashInitCode, hashCallData,\n            accountGasLimits, preVerificationGas, gasFees,\n            hashPaymasterAndData\n        );\n    }\n\n    function unpackUints(\n        bytes32 packed\n    ) internal pure returns (uint256 high128, uint256 low128) {\n        return (uint128(bytes16(packed)), uint128(uint256(packed)));\n    }\n\n    //unpack just the high 128-bits from a packed value\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\n        return uint256(packed) >> 128;\n    }\n\n    // unpack just the low 128-bits from a packed value\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\n        return uint128(uint256(packed));\n    }\n\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.gasFees);\n    }\n\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.gasFees);\n    }\n\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.accountGasLimits);\n    }\n\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.accountGasLimits);\n    }\n\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\n    }\n\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\n    }\n\n    function unpackPaymasterStaticFields(\n        bytes calldata paymasterAndData\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\n        return (\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\n        );\n    }\n\n    /**\n     * Hash the user operation data.\n     * @param userOp - The user operation data.\n     */\n    function hash(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes32) {\n        return keccak256(encode(userOp));\n    }\n}\n"
    },
    "node_modules/@ERC4337/account-abstraction/contracts/core/Helpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\n\n /*\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n  * must return this value in case of signature failure, instead of revert.\n  */\nuint256 constant SIG_VALIDATION_FAILED = 1;\n\n\n/*\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n * return this value on success.\n */\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\n\n\n/**\n * Returned data from validateUserOp.\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\n * parsed by `_parseValidationData`.\n * @param aggregator  - address(0) - The account validated the signature by itself.\n *                      address(1) - The account failed to validate the signature.\n *                      otherwise - This is an address of a signature aggregator that must\n *                                  be used to validate the signature.\n * @param validAfter  - This UserOp is valid only after this timestamp.\n * @param validaUntil - This UserOp is valid only up to this timestamp.\n */\nstruct ValidationData {\n    address aggregator;\n    uint48 validAfter;\n    uint48 validUntil;\n}\n\n/**\n * Extract sigFailed, validAfter, validUntil.\n * Also convert zero validUntil to type(uint48).max.\n * @param validationData - The packed validation data.\n */\nfunction _parseValidationData(\n    uint256 validationData\n) pure returns (ValidationData memory data) {\n    address aggregator = address(uint160(validationData));\n    uint48 validUntil = uint48(validationData >> 160);\n    if (validUntil == 0) {\n        validUntil = type(uint48).max;\n    }\n    uint48 validAfter = uint48(validationData >> (48 + 160));\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * Helper to pack the return value for validateUserOp.\n * @param data - The ValidationData to pack.\n */\nfunction _packValidationData(\n    ValidationData memory data\n) pure returns (uint256) {\n    return\n        uint160(data.aggregator) |\n        (uint256(data.validUntil) << 160) |\n        (uint256(data.validAfter) << (160 + 48));\n}\n\n/**\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\n * @param sigFailed  - True for signature failure, false for success.\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\n * @param validAfter - First timestamp this UserOperation is valid.\n */\nfunction _packValidationData(\n    bool sigFailed,\n    uint48 validUntil,\n    uint48 validAfter\n) pure returns (uint256) {\n    return\n        (sigFailed ? 1 : 0) |\n        (uint256(validUntil) << 160) |\n        (uint256(validAfter) << (160 + 48));\n}\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n */\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let mem := mload(0x40)\n            let len := data.length\n            calldatacopy(mem, data.offset, len)\n            ret := keccak256(mem, len)\n        }\n    }\n\n\n/**\n * The minimum of two numbers.\n * @param a - First number.\n * @param b - Second number.\n */\n    function min(uint256 a, uint256 b) pure returns (uint256) {\n        return a < b ? a : b;\n    }\n"
    },
    "node_modules/@ERC4337/account-abstraction/contracts/interfaces/IEntryPoint.sol": {
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request.\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\n     * @param sender        - The account that generates this request.\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\n     * @param nonce         - The nonce value from the request.\n     * @param success       - True if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\n     *                        validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * Account \"sender\" was deployed.\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender     - The account that is deployed\n     * @param factory    - The factory used to deploy this account (in the initCode)\n     * @param paymaster  - The paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * An event emitted if the UserOperation Paymaster's \"postOp\" call reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event PostOpRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     */\n    event UserOperationPrefundTooLow(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce\n    );\n\n    /**\n     * An event emitted by handleOps(), before starting the execution loop.\n     * Any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * A custom revert error of handleOps, to identify the offending op.\n     * Should be caught in off-chain handleOps simulation and not happen on-chain.\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. The string starts with a unique code \"AAmn\",\n     *                  where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *                  so a failure can be attributed to the correct entity.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * A custom revert error of handleOps, to report a revert by account or paymaster.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\n     * @param inner   - data from inner cought revert reason\n     * @dev note that inner is truncated to 2048 bytes\n     */\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\n\n    error PostOpReverted(bytes returnData);\n\n    /**\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\n     * @param aggregator The aggregator that failed to verify the signature\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    // Return value of getSenderAddress.\n    error SenderAddressResult(address sender);\n\n    // UserOps handled, per aggregator.\n    struct UserOpsPerAggregator {\n        PackedUserOperation[] userOps;\n        // Aggregator address\n        IAggregator aggregator;\n        // Aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * No signature aggregator is used.\n     * If any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops         - The operations to execute.\n     * @param beneficiary - The address to receive the fees.\n     */\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\n     * @param beneficiary      - The address to receive the fees.\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Generate a request Id - unique identifier for this request.\n     * The request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     * @param userOp - The user operation to generate the request ID for.\n     * @return hash the hash of this UserOperation\n     */\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Gas and return values during simulation.\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\n     * @param prefund          - The required prefund for this operation\n     * @param accountValidationData   - returned validationData from account.\n     * @param paymasterValidationData - return validationData from paymaster.\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bytes paymasterContext;\n    }\n\n    /**\n     * Returned aggregated signature info:\n     * The aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * This method always revert, and returns the address in SenderAddressResult error\n     * @param initCode - The constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    error DelegateAndRevert(bool success, bytes ret);\n\n    /**\n     * Helper method for dry-run testing.\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\n     *  actual EntryPoint code is less convenient.\n     * @param target a target contract to make a delegatecall from entrypoint\n     * @param data data to pass to target in a delegatecall\n     */\n    function delegateAndRevert(address target, bytes calldata data) external;\n}\n"
    },
    "src/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.20;\n\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _dataHash Arbitrary length data signed on behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc >\n     * 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(\n        bytes32 _dataHash,\n        bytes calldata _signature\n    )\n        external\n        view\n        returns (bytes4);\n}\n"
    },
    "src/core/SupportViewer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport {\n    CallType,\n    ExecType,\n    ModeCode,\n    EXECTYPE_DEFAULT,\n    EXECTYPE_TRY,\n    CALLTYPE_SINGLE,\n    CALLTYPE_BATCH,\n    CALLTYPE_DELEGATECALL\n} from \"../lib/ModeLib.sol\";\nimport {\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_HOOK,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_FALLBACK\n} from \"erc7579/interfaces/IERC7579Module.sol\";\nimport { IERC7579AccountView } from \"../interfaces/IERC7579Account.sol\";\n\nabstract contract SupportViewer is IERC7579AccountView {\n    function accountId() external pure returns (string memory accountImplementationId) {\n        return \"rhinestone.safe7579.v1.0.0\";\n    }\n\n    function supportsExecutionMode(ModeCode encodedMode) external pure returns (bool supported) {\n        CallType callType;\n        ExecType execType;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            callType := encodedMode\n            execType := shl(8, encodedMode)\n        }\n        if (callType == CALLTYPE_BATCH) supported = true;\n        else if (callType == CALLTYPE_SINGLE) supported = true;\n        else if (callType == CALLTYPE_DELEGATECALL) supported = true;\n        else return false;\n\n        if (supported && execType == EXECTYPE_DEFAULT) return supported;\n        else if (supported && execType == EXECTYPE_TRY) return supported;\n        else return false;\n    }\n\n    function supportsModule(uint256 moduleTypeId) external pure returns (bool) {\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) return true;\n        else if (moduleTypeId == MODULE_TYPE_EXECUTOR) return true;\n        else if (moduleTypeId == MODULE_TYPE_FALLBACK) return true;\n        else if (moduleTypeId == MODULE_TYPE_HOOK) return true;\n        else return false;\n    }\n}\n"
    },
    "node_modules/@ERC4337/account-abstraction/contracts/interfaces/PackedUserOperation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"
    },
    "src/interfaces/IERC7579Module.sol": {
      "content": "pragma solidity ^0.8.20;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\n\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\n\ninterface IModule {\n    /**\n     * @dev This function is called by the smart account during installation of the module\n     * @param data arbitrary data that may be required on the module during `onInstall`\n     * initialization\n     *\n     * MUST revert on error (i.e. if module is already enabled)\n     */\n    function onInstall(bytes calldata data) external;\n\n    /**\n     * @dev This function is called by the smart account during uninstallation of the module\n     * @param data arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization\n     *\n     * MUST revert on error\n     */\n    function onUninstall(bytes calldata data) external;\n\n    /**\n     * @dev Returns boolean value if module is a certain type\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *\n     * MUST return true if the module is of the given type and false otherwise\n     */\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * @dev Returns if the module was already initialized for a provided smartaccount\n     */\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n\ninterface IValidator is IModule {\n    /**\n     * @dev Validates a transaction on behalf of the account.\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\n     * The MSA MUST clean up the userOp before sending it to the validator.\n     * @param userOpHash The hash of the user operation to be validated\n     * @return return value according to ERC-4337\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        returns (uint256);\n\n    /**\n     * Validator can be used for ERC-1271 validation\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IExecutor is IModule { }\n\ninterface IHook is IModule {\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        returns (bytes memory hookData);\n\n    function postCheck(bytes calldata hookData) external;\n}\n\ninterface IFallback is IModule { }\n"
    },
    "node_modules/@safe-global/safe-contracts/contracts/handler/HandlerContext.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Handler Context - Allows the fallback handler to extract addition context from the calldata\n * @dev The fallback manager appends the following context to the calldata:\n *      1. Fallback manager caller address (non-padded)\n * based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f8cc8b844a9f92f63dc55aa581f7d643a1bc5ac1/contracts/metatx/ERC2771Context.sol\n * @author Richard Meissner - @rmeissner\n */\nabstract contract HandlerContext {\n    /**\n     * @notice Allows fetching the original caller address.\n     * @dev This is only reliable in combination with a FallbackManager that supports this (e.g. Safe contract >=1.3.0).\n     *      When using this functionality make sure that the linked _manager (aka msg.sender) supports this.\n     *      This function does not rely on a trusted forwarder. Use the returned value only to\n     *      check information against the calling manager.\n     * @return sender Original caller address.\n     */\n    function _msgSender() internal pure returns (address sender) {\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\n        }\n    }\n\n    /**\n     * @notice Returns the FallbackManager address\n     * @return Fallback manager address\n     */\n    function _manager() internal view returns (address) {\n        return msg.sender;\n    }\n}\n"
    },
    "node_modules/erc7579/src/core/AccountBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/**\n * @title reference implementation of the minimal modular smart account with Hook Extension\n * @author zeroknots.eth | rhinestone.wtf\n */\ncontract AccountBase {\n    error AccountAccessUnauthorized();\n\n    /////////////////////////////////////////////////////\n    // Access Control\n    ////////////////////////////////////////////////////\n\n    modifier onlyEntryPointOrSelf() virtual {\n        if (!(msg.sender == entryPoint() || msg.sender == address(this))) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    modifier onlyEntryPoint() virtual {\n        if (msg.sender != entryPoint()) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    function entryPoint() public view virtual returns (address) {\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n    }\n\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\n    /// Subclass MAY override this modifier for better funds management.\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\n    /// it will not be required to send again)\n    ///\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if missingAccountFunds {\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\n            }\n        }\n    }\n}\n"
    },
    "src/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25;\n\nimport { IERC7484 } from \"./interfaces/IERC7484.sol\";\nimport { CallType } from \"./lib/ModeLib.sol\";\n\nstruct FallbackHandler {\n    address handler;\n    CallType calltype;\n}\n\nenum HookType {\n    GLOBAL,\n    SIG\n}\n\nstruct ModuleInit {\n    address module;\n    bytes initData;\n}\n\nstruct RegistryInit {\n    IERC7484 registry;\n    address[] attesters;\n    uint8 threshold;\n}\n"
    },
    "src/core/ModuleManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { SentinelListLib } from \"sentinellist/SentinelList.sol\";\nimport { SentinelList4337Lib } from \"sentinellist/SentinelList4337.sol\";\nimport { IModule, IHook } from \"../interfaces/IERC7579Module.sol\";\nimport { ISafe } from \"../interfaces/ISafe.sol\";\nimport { ISafe7579 } from \"../ISafe7579.sol\";\nimport \"../DataTypes.sol\";\n\nimport { RegistryAdapter } from \"./RegistryAdapter.sol\";\nimport { Receiver } from \"erc7579/core/Receiver.sol\";\nimport { AccessControl } from \"./AccessControl.sol\";\nimport { CallType, CALLTYPE_STATIC, CALLTYPE_SINGLE } from \"../lib/ModeLib.sol\";\nimport {\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_FALLBACK,\n    MODULE_TYPE_HOOK\n} from \"erc7579/interfaces/IERC7579Module.sol\";\n\n/**\n * @title ModuleManager\n * Contract that implements ERC7579 Module compatibility for Safe accounts\n * @author zeroknots.eth | rhinestone.wtf\n * @dev All Module types  are handled within this\n * contract. To make it a bit easier to read, the contract is split into different sections:\n * - Validator Modules\n * - Executor Modules\n * - Fallback Modules\n * - Hook Modules\n * Note: the Storage mappings for each section, are not listed on the very top, but in the\n * respective section\n */\nabstract contract ModuleManager is ISafe7579, AccessControl, Receiver, RegistryAdapter {\n    using SentinelList4337Lib for SentinelList4337Lib.SentinelList;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     VALIDATOR MODULES                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    // No mapping account => list necessary. this sentinellist flavour handles associated storage to\n    // smart account itself to comply with 4337 storage restrictions\n    SentinelList4337Lib.SentinelList internal $validators;\n\n    /**\n     * install and initialize validator module\n     * @dev This function will install a validator module and return the moduleInitData\n     * @param validator address of the validator module\n     * @param data initialization data for the validator module\n     */\n    function _installValidator(\n        address validator,\n        bytes calldata data\n    )\n        internal\n        withRegistry(validator, MODULE_TYPE_VALIDATOR)\n        returns (bytes memory moduleInitData)\n    {\n        $validators.push({ account: msg.sender, newEntry: validator });\n        return data;\n    }\n\n    /**\n     * Uninstall validator module\n     * @dev This function does not prevent the user from uninstalling all validator modules.\n     * Since the Safe7579 signature validation can fallback to Safe's checkSignature()\n     * function, it is okay, if all validator modules are removed.\n     * This does not brick the account\n     */\n    function _uninstallValidator(\n        address validator,\n        bytes calldata data\n    )\n        internal\n        returns (bytes memory moduleInitData)\n    {\n        address prev;\n        (prev, moduleInitData) = abi.decode(data, (address, bytes));\n        $validators.pop({ account: msg.sender, prevEntry: prev, popEntry: validator });\n    }\n\n    /**\n     * Helper function that will calculate storage slot for\n     * validator address within the linked list in ValidatorStorageHelper\n     * and use Safe's getStorageAt() to read 32bytes from Safe's storage\n     */\n    function _isValidatorInstalled(address validator)\n        internal\n        view\n        virtual\n        returns (bool isInstalled)\n    {\n        isInstalled = $validators.contains({ account: msg.sender, entry: validator });\n    }\n\n    /**\n     * Get paginated list of installed validators\n     */\n    function getValidatorsPaginated(\n        address cursor,\n        uint256 pageSize\n    )\n        external\n        view\n        virtual\n        returns (address[] memory array, address next)\n    {\n        return $validators.getEntriesPaginated({\n            account: msg.sender,\n            start: cursor,\n            pageSize: pageSize\n        });\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      EXECUTOR MODULES                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    SentinelList4337Lib.SentinelList internal $executors;\n\n    modifier onlyExecutorModule() {\n        if (!_isExecutorInstalled(_msgSender())) revert InvalidModule(_msgSender());\n        _;\n    }\n\n    /**\n     * Install and initialize executor module\n     * @dev This function will install an executor module and return the moduleInitData\n     * @param executor address of the executor module\n     * @param data initialization data for the executor module\n     */\n    function _installExecutor(\n        address executor,\n        bytes calldata data\n    )\n        internal\n        withRegistry(executor, MODULE_TYPE_EXECUTOR)\n        returns (bytes memory moduleInitData)\n    {\n        $executors.push({ account: msg.sender, newEntry: executor });\n        return data;\n    }\n\n    /**\n     * Uninstall executor module\n     * @dev This function will uninstall an executor module\n     * @param executor address of executor module to be uninstalled\n     * @param data abi encoded previous address and deinit data\n     */\n    function _uninstallExecutor(\n        address executor,\n        bytes calldata data\n    )\n        internal\n        returns (bytes memory moduleDeInitData)\n    {\n        address prev;\n        (prev, moduleDeInitData) = abi.decode(data, (address, bytes));\n        $executors.pop({ account: msg.sender, prevEntry: prev, popEntry: executor });\n    }\n\n    function _isExecutorInstalled(address executor)\n        internal\n        view\n        virtual\n        returns (bool isInstalled)\n    {\n        isInstalled = $executors.contains({ account: msg.sender, entry: executor });\n    }\n\n    /**\n     * Get paginated list of installed executors\n     */\n    function getExecutorsPaginated(\n        address cursor,\n        uint256 pageSize\n    )\n        external\n        view\n        virtual\n        returns (address[] memory array, address next)\n    {\n        return $executors.getEntriesPaginated({\n            account: msg.sender,\n            start: cursor,\n            pageSize: pageSize\n        });\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      FALLBACK MODULES                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    mapping(bytes4 selector => mapping(address smartAccount => FallbackHandler handlerConfig))\n        internal $fallbackStorage;\n\n    function _installFallbackHandler(\n        address handler,\n        bytes calldata params\n    )\n        internal\n        virtual\n        withRegistry(handler, MODULE_TYPE_FALLBACK)\n        returns (bytes memory moduleInitData)\n    {\n        (bytes4 functionSig, CallType calltype, bytes memory initData) =\n            abi.decode(params, (bytes4, CallType, bytes));\n\n        // disallow calls to onInstall or onUninstall.\n        // this could create a security issue\n        if (\n            functionSig == IModule.onInstall.selector || functionSig == IModule.onUninstall.selector\n        ) revert InvalidFallbackHandler(functionSig);\n\n        // disallow unsupported calltypes\n        if (calltype != CALLTYPE_SINGLE && calltype != CALLTYPE_STATIC) {\n            revert InvalidCallType(calltype);\n        }\n\n        if (_isFallbackHandlerInstalled(functionSig)) revert FallbackInstalled(functionSig);\n\n        FallbackHandler storage $fallbacks = $fallbackStorage[functionSig][msg.sender];\n        $fallbacks.calltype = calltype;\n        $fallbacks.handler = handler;\n\n        return initData;\n    }\n\n    function _isFallbackHandlerInstalled(bytes4 functionSig) internal view virtual returns (bool) {\n        FallbackHandler storage $fallbacks = $fallbackStorage[functionSig][msg.sender];\n        return $fallbacks.handler != address(0);\n    }\n\n    function _uninstallFallbackHandler(\n        address, /*handler*/\n        bytes calldata context\n    )\n        internal\n        virtual\n        returns (bytes memory moduleDeInitData)\n    {\n        bytes4 functionSig;\n        (functionSig, moduleDeInitData) = abi.decode(context, (bytes4, bytes));\n\n        FallbackHandler storage $fallbacks = $fallbackStorage[functionSig][msg.sender];\n        delete $fallbacks.handler;\n    }\n\n    function _isFallbackHandlerInstalled(\n        address _handler,\n        bytes calldata additionalContext\n    )\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        bytes4 functionSig = abi.decode(additionalContext, (bytes4));\n\n        FallbackHandler storage $fallbacks = $fallbackStorage[functionSig][msg.sender];\n        return $fallbacks.handler == _handler;\n    }\n\n    /**\n     * @dev AccessControl: any external contract / EOA may call this function\n     * Safe7579 Fallback supports the following feature set:\n     *    CallTypes:\n     *             - CALLTYPE_SINGLE\n     *             - CALLTYPE_BATCH\n     * @dev If a global hook and/or selector hook is set, it will be called\n     */\n    // solhint-disable-next-line no-complex-fallback\n    fallback(bytes calldata callData)\n        external\n        payable\n        virtual\n        override(Receiver)\n        receiverFallback\n        withHook(msg.sig)\n        returns (bytes memory fallbackRet)\n    {\n        // using JUMPI to avoid stack too deep\n        return _callFallbackHandler(callData);\n    }\n\n    function _callFallbackHandler(bytes calldata callData)\n        private\n        returns (bytes memory fallbackRet)\n    {\n        // get handler for specific function selector\n        FallbackHandler storage $fallbacks = $fallbackStorage[msg.sig][msg.sender];\n        address handler = $fallbacks.handler;\n        CallType calltype = $fallbacks.calltype;\n        // if no handler is set for the msg.sig, revert\n        if (handler == address(0)) revert NoFallbackHandler(msg.sig);\n\n        // according to ERC7579, when calling to fallback modules, ERC2771 msg.sender has to be\n        // appended to the calldata, this allows fallback modules to implement\n        // authorization control\n        if (calltype == CALLTYPE_STATIC) {\n            return _staticcallReturn({\n                safe: ISafe(msg.sender),\n                target: handler,\n                callData: abi.encodePacked(callData, _msgSender()) // append ERC2771\n             });\n        }\n        if (calltype == CALLTYPE_SINGLE) {\n            return _execReturn({\n                safe: ISafe(msg.sender),\n                target: handler,\n                value: 0,\n                callData: abi.encodePacked(callData, _msgSender()) // append ERC2771\n             });\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        HOOK MODULES                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    mapping(address smartAccount => address globalHook) internal $globalHook;\n    mapping(bytes4 selector => mapping(address smartAccount => address hook)) internal $hookManager;\n\n    /**\n     * Run precheck hook for global and function selector specific\n     */\n    function _preHooks(\n        address globalHook,\n        address sigHook\n    )\n        internal\n        returns (bytes memory global, bytes memory sig)\n    {\n        if (globalHook != address(0)) {\n            global = _execReturn({\n                safe: ISafe(msg.sender),\n                target: globalHook,\n                value: 0,\n                callData: abi.encodeCall(IHook.preCheck, (_msgSender(), msg.value, msg.data))\n            });\n            global = abi.decode(global, (bytes));\n        }\n        if (sigHook != address(0)) {\n            sig = _execReturn({\n                safe: ISafe(msg.sender),\n                target: sigHook,\n                value: 0,\n                callData: abi.encodeCall(IHook.preCheck, (_msgSender(), msg.value, msg.data))\n            });\n            sig = abi.decode(sig, (bytes));\n        }\n    }\n\n    /**\n     * Run post hooks (global and function sig)\n     */\n    function _postHooks(\n        address globalHook,\n        address sigHook,\n        bytes memory global,\n        bytes memory sig\n    )\n        internal\n    {\n        if (globalHook != address(0)) {\n            _exec({\n                safe: ISafe(msg.sender),\n                target: globalHook,\n                value: 0,\n                callData: abi.encodeCall(IHook.postCheck, (global))\n            });\n        }\n        if (sigHook != address(0)) {\n            _exec({\n                safe: ISafe(msg.sender),\n                target: sigHook,\n                value: 0,\n                callData: abi.encodeCall(IHook.postCheck, (sig))\n            });\n        }\n    }\n\n    /**\n     * modifier that executes global hook, and function signature specific hook if enabled\n     */\n    modifier withHook(bytes4 selector) {\n        address globalHook = $globalHook[msg.sender];\n        address sigHook = $hookManager[selector][msg.sender];\n        (bytes memory global, bytes memory sig) = _preHooks(globalHook, sigHook);\n        _;\n        _postHooks(globalHook, sigHook, global, sig);\n    }\n\n    modifier tryWithHook(address module, bytes4 selector) {\n        address globalHook = $globalHook[msg.sender];\n        address sigHook = $hookManager[selector][msg.sender];\n\n        if (module != globalHook && module != sigHook) {\n            (bytes memory global, bytes memory sig) = _preHooks(globalHook, sigHook);\n            _;\n            _postHooks(globalHook, sigHook, global, sig);\n        } else {\n            _;\n        }\n    }\n\n    /**\n     * Install and initialize hook module\n     * @dev This function will install a hook module and return the moduleInitData\n     * @param hook address of the hook module\n     * @param data initialization data for the hook module\n     */\n    function _installHook(\n        address hook,\n        bytes calldata data\n    )\n        internal\n        virtual\n        withRegistry(hook, MODULE_TYPE_HOOK)\n        returns (bytes memory moduleInitData)\n    {\n        (HookType hookType, bytes4 selector, bytes memory initData) =\n            abi.decode(data, (HookType, bytes4, bytes));\n        address currentHook;\n\n        // handle global hooks\n        if (hookType == HookType.GLOBAL && selector == 0x0) {\n            currentHook = $globalHook[msg.sender];\n            // Dont allow hooks to be overwritten. If a hook is currently installed, it must be\n            // uninstalled first\n            if (currentHook != address(0)) {\n                revert HookAlreadyInstalled(currentHook);\n            }\n            $globalHook[msg.sender] = hook;\n        } else if (hookType == HookType.SIG) {\n            currentHook = $hookManager[selector][msg.sender];\n            // Dont allow hooks to be overwritten. If a hook is currently installed, it must be\n            // uninstalled first\n            if (currentHook != address(0)) {\n                revert HookAlreadyInstalled(currentHook);\n            }\n            $hookManager[selector][msg.sender] = hook;\n        } else {\n            revert InvalidHookType();\n        }\n\n        return initData;\n    }\n\n    function _uninstallHook(\n        address, /*hook*/\n        bytes calldata data\n    )\n        internal\n        virtual\n        returns (bytes memory moduleDeInitData)\n    {\n        HookType hookType;\n        bytes4 selector;\n        (hookType, selector, moduleDeInitData) = abi.decode(data, (HookType, bytes4, bytes));\n        if (hookType == HookType.GLOBAL && selector == 0x0) {\n            delete $globalHook[msg.sender];\n        } else if (hookType == HookType.SIG) {\n            delete $hookManager[selector][msg.sender];\n        } else {\n            revert InvalidHookType();\n        }\n    }\n\n    function _getCurrentHook(\n        HookType hookType,\n        bytes4 selector\n    )\n        internal\n        view\n        returns (address hook)\n    {\n        // handle global hooks\n        if (hookType == HookType.GLOBAL && selector == 0x0) {\n            hook = $globalHook[msg.sender];\n        }\n        if (hookType == HookType.SIG) {\n            hook = $hookManager[selector][msg.sender];\n        }\n    }\n\n    function _isHookInstalled(\n        address module,\n        bytes calldata context\n    )\n        internal\n        view\n        returns (bool)\n    {\n        (HookType hookType, bytes4 selector) = abi.decode(context, (HookType, bytes4));\n        address hook = _getCurrentHook({ hookType: hookType, selector: selector });\n        return hook == module;\n    }\n\n    function getActiveHook(bytes4 selector) public view returns (address hook) {\n        return $hookManager[selector][msg.sender];\n    }\n\n    function getActiveHook() public view returns (address hook) {\n        return $globalHook[msg.sender];\n    }\n\n    // solhint-disable-next-line code-complexity\n    /**\n     * To make it easier to install multiple modules at once, this function will\n     * install multiple modules at once. The init data is expected to be a abi encoded tuple\n     * of (uint[] types, bytes[] contexts, bytes moduleInitData)\n     * @dev Install multiple modules at once\n     * @param module address of the module\n     * @param initData initialization data for the module\n     */\n    function _multiTypeInstall(\n        address module,\n        bytes calldata initData\n    )\n        internal\n        returns (bytes memory _moduleInitData)\n    {\n        uint256[] calldata types;\n        bytes[] calldata contexts;\n        bytes calldata moduleInitData;\n\n        // equivalent of:\n        // (types, contexs, moduleInitData) = abi.decode(initData,(uint[],bytes[],bytes)\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            let offset := initData.offset\n            let baseOffset := offset\n            let dataPointer := add(baseOffset, calldataload(offset))\n\n            types.offset := add(dataPointer, 32)\n            types.length := calldataload(dataPointer)\n            offset := add(offset, 32)\n\n            dataPointer := add(baseOffset, calldataload(offset))\n            contexts.offset := add(dataPointer, 32)\n            contexts.length := calldataload(dataPointer)\n            offset := add(offset, 32)\n\n            dataPointer := add(baseOffset, calldataload(offset))\n            moduleInitData.offset := add(dataPointer, 32)\n            moduleInitData.length := calldataload(dataPointer)\n        }\n\n        uint256 length = types.length;\n        if (contexts.length != length) revert InvalidInput();\n\n        // iterate over all module types and install the module as a type accordingly\n        for (uint256 i; i < length; i++) {\n            uint256 _type = types[i];\n\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                      INSTALL VALIDATORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            if (_type == MODULE_TYPE_VALIDATOR) {\n                _installValidator(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL EXECUTORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (_type == MODULE_TYPE_EXECUTOR) {\n                _installExecutor(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL FALLBACK                     */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (_type == MODULE_TYPE_FALLBACK) {\n                _installFallbackHandler(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*          INSTALL HOOK (global or sig specific)             */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (_type == MODULE_TYPE_HOOK) {\n                _installHook(module, contexts[i]);\n            } else {\n                revert InvalidModuleType(module, _type);\n            }\n        }\n        // memory allocate the moduleInitData to return. This data should be used by the caller to\n        // initialize the module\n        _moduleInitData = moduleInitData;\n    }\n\n    function _multiTypeUninstall(\n        address module,\n        bytes calldata initData\n    )\n        internal\n        returns (bytes memory _moduleDeInitData)\n    {\n        uint256[] calldata types;\n        bytes[] calldata contexts;\n        bytes calldata moduleDeInitData;\n\n        // equivalent of:\n        // (types, contexs, moduleInitData) = abi.decode(initData,(uint[],bytes[],bytes)\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            let offset := initData.offset\n            let baseOffset := offset\n            let dataPointer := add(baseOffset, calldataload(offset))\n\n            types.offset := add(dataPointer, 32)\n            types.length := calldataload(dataPointer)\n            offset := add(offset, 32)\n\n            dataPointer := add(baseOffset, calldataload(offset))\n            contexts.offset := add(dataPointer, 32)\n            contexts.length := calldataload(dataPointer)\n            offset := add(offset, 32)\n\n            dataPointer := add(baseOffset, calldataload(offset))\n            moduleDeInitData.offset := add(dataPointer, 32)\n            moduleDeInitData.length := calldataload(dataPointer)\n        }\n\n        uint256 length = types.length;\n        if (contexts.length != length) revert InvalidInput();\n\n        // iterate over all module types and install the module as a type accordingly\n        for (uint256 i; i < length; i++) {\n            uint256 _type = types[i];\n\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                      INSTALL VALIDATORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            if (_type == MODULE_TYPE_VALIDATOR) {\n                _uninstallValidator(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL EXECUTORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (_type == MODULE_TYPE_EXECUTOR) {\n                _uninstallExecutor(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL FALLBACK                     */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (_type == MODULE_TYPE_FALLBACK) {\n                _uninstallFallbackHandler(module, contexts[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*          INSTALL HOOK (global or sig specific)             */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (_type == MODULE_TYPE_HOOK) {\n                _uninstallHook(module, contexts[i]);\n            } else {\n                revert InvalidModuleType(module, _type);\n            }\n        }\n        // memory allocate the moduleInitData to return. This data should be used by the caller to\n        // initialize the module\n        _moduleDeInitData = moduleDeInitData;\n    }\n}\n"
    },
    "src/interfaces/IERC7484.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC7484 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, uint256 moduleType) external view;\n\n    function checkForAccount(\n        address smartAccount,\n        address module,\n        uint256 moduleType\n    )\n        external\n        view;\n\n    /**\n     * Allows Smart Accounts - the end users of the registry - to appoint\n     * one or many attesters as trusted.\n     * @dev this function reverts, if address(0), or duplicates are provided in attesters[]\n     *\n     * @param threshold The minimum number of attestations required for a module\n     *                  to be considered secure.\n     * @param attesters The addresses of the attesters to be trusted.\n     */\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              Check with external attester(s)               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module, address[] calldata attesters, uint256 threshold) external view;\n\n    function check(\n        address module,\n        uint256 moduleType,\n        address[] calldata attesters,\n        uint256 threshold\n    )\n        external\n        view;\n}\n"
    },
    "node_modules/@rhinestone/sentinellist/src/SentinelList4337.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\naddress constant SENTINEL = address(0x1);\naddress constant ZERO_ADDRESS = address(0x0);\n\n/**\n * Implements a linked list, but adheres to ERC-4337 storage restrictions.\n * Intended use: validator modules for modular ERC-4337 smart accounts\n * @author kopy-kat | rhinestone.wtf\n */\nlibrary SentinelList4337Lib {\n    struct SentinelList {\n        mapping(address key => mapping(address account => address entry)) entries;\n    }\n\n    error LinkedList_AlreadyInitialized();\n    error LinkedList_InvalidPage();\n    error LinkedList_InvalidEntry(address entry);\n    error LinkedList_EntryAlreadyInList(address entry);\n\n    function init(SentinelList storage self, address account) internal {\n        if (alreadyInitialized(self, account)) revert LinkedList_AlreadyInitialized();\n        self.entries[SENTINEL][account] = SENTINEL;\n    }\n\n    function alreadyInitialized(\n        SentinelList storage self,\n        address account\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return self.entries[SENTINEL][account] != ZERO_ADDRESS;\n    }\n\n    function getNext(\n        SentinelList storage self,\n        address account,\n        address entry\n    )\n        internal\n        view\n        returns (address)\n    {\n        if (entry == ZERO_ADDRESS) {\n            revert LinkedList_InvalidEntry(entry);\n        }\n        return self.entries[entry][account];\n    }\n\n    function push(SentinelList storage self, address account, address newEntry) internal {\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(newEntry);\n        }\n        if (self.entries[newEntry][account] != ZERO_ADDRESS) {\n            revert LinkedList_EntryAlreadyInList(newEntry);\n        }\n        self.entries[newEntry][account] = self.entries[SENTINEL][account];\n        self.entries[SENTINEL][account] = newEntry;\n    }\n\n    function pop(\n        SentinelList storage self,\n        address account,\n        address prevEntry,\n        address popEntry\n    )\n        internal\n    {\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(prevEntry);\n        }\n        if (self.entries[prevEntry][account] != popEntry) {\n            revert LinkedList_InvalidEntry(popEntry);\n        }\n        self.entries[prevEntry][account] = self.entries[popEntry][account];\n        self.entries[popEntry][account] = ZERO_ADDRESS;\n    }\n\n    function popAll(SentinelList storage self, address account) internal {\n        address next = self.entries[SENTINEL][account];\n        while (next != ZERO_ADDRESS) {\n            address current = next;\n            next = self.entries[next][account];\n            self.entries[current][account] = ZERO_ADDRESS;\n        }\n        self.entries[SENTINEL][account] = ZERO_ADDRESS;\n    }\n\n    function contains(\n        SentinelList storage self,\n        address account,\n        address entry\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return SENTINEL != entry && self.entries[entry][account] != ZERO_ADDRESS;\n    }\n\n    function getEntriesPaginated(\n        SentinelList storage self,\n        address account,\n        address start,\n        uint256 pageSize\n    )\n        internal\n        view\n        returns (address[] memory array, address next)\n    {\n        if (start != SENTINEL && !contains(self, account, start)) {\n            revert LinkedList_InvalidEntry(start);\n        }\n        if (pageSize == 0) revert LinkedList_InvalidPage();\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 entryCount = 0;\n        next = self.entries[start][account];\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\n            array[entryCount] = next;\n            next = self.entries[next][account];\n            entryCount++;\n        }\n\n        /**\n         * Because of the argument validation, we can assume that the loop will always iterate over\n         * the valid entry list values\n         *       and the `next` variable will either be an enabled entry or a sentinel address\n         * (signalling the end).\n         *\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\n         * the last element of the entry array\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\n         * start of the next page is neither\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\n         * start.\n         */\n        if (next != SENTINEL && entryCount > 0) {\n            next = array[entryCount - 1];\n        }\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, entryCount)\n        }\n    }\n}\n"
    },
    "node_modules/@rhinestone/sentinellist/src/SentinelList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\naddress constant SENTINEL = address(0x1);\naddress constant ZERO_ADDRESS = address(0x0);\n\nlibrary SentinelListLib {\n    struct SentinelList {\n        mapping(address => address) entries;\n    }\n\n    error LinkedList_AlreadyInitialized();\n    error LinkedList_InvalidPage();\n    error LinkedList_InvalidEntry(address entry);\n    error LinkedList_EntryAlreadyInList(address entry);\n\n    function init(SentinelList storage self) internal {\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\n        self.entries[SENTINEL] = SENTINEL;\n    }\n\n    function alreadyInitialized(SentinelList storage self) internal view returns (bool) {\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\n    }\n\n    function getNext(SentinelList storage self, address entry) internal view returns (address) {\n        if (entry == ZERO_ADDRESS) {\n            revert LinkedList_InvalidEntry(entry);\n        }\n        return self.entries[entry];\n    }\n\n    function push(SentinelList storage self, address newEntry) internal {\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(newEntry);\n        }\n        if (self.entries[newEntry] != ZERO_ADDRESS) revert LinkedList_EntryAlreadyInList(newEntry);\n        self.entries[newEntry] = self.entries[SENTINEL];\n        self.entries[SENTINEL] = newEntry;\n    }\n\n    function pop(SentinelList storage self, address prevEntry, address popEntry) internal {\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(prevEntry);\n        }\n        if (self.entries[prevEntry] != popEntry) revert LinkedList_InvalidEntry(popEntry);\n        self.entries[prevEntry] = self.entries[popEntry];\n        self.entries[popEntry] = ZERO_ADDRESS;\n    }\n\n    function popAll(SentinelList storage self) internal {\n        address next = self.entries[SENTINEL];\n        while (next != ZERO_ADDRESS) {\n            address current = next;\n            next = self.entries[next];\n            self.entries[current] = ZERO_ADDRESS;\n        }\n        self.entries[SENTINEL] = ZERO_ADDRESS;\n    }\n\n    function contains(SentinelList storage self, address entry) internal view returns (bool) {\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\n    }\n\n    function getEntriesPaginated(\n        SentinelList storage self,\n        address start,\n        uint256 pageSize\n    )\n        internal\n        view\n        returns (address[] memory array, address next)\n    {\n        if (start != SENTINEL && !contains(self, start)) revert LinkedList_InvalidEntry(start);\n        if (pageSize == 0) revert LinkedList_InvalidPage();\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 entryCount = 0;\n        next = self.entries[start];\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\n            array[entryCount] = next;\n            next = self.entries[next];\n            entryCount++;\n        }\n\n        /**\n         * Because of the argument validation, we can assume that the loop will always iterate over\n         * the valid entry list values\n         *       and the `next` variable will either be an enabled entry or a sentinel address\n         * (signalling the end).\n         *\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\n         * the last element of the entry array\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\n         * start of the next page is neither\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\n         * start.\n         */\n        if (next != SENTINEL && entryCount > 0) {\n            next = array[entryCount - 1];\n        }\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, entryCount)\n        }\n    }\n}\n"
    },
    "src/interfaces/ISafeOp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nbytes32 constant SAFE_OP_TYPEHASH =\n    0xc03dfc11d8b10bf9cf703d558958c8c42777f785d998c62060d85a4f0ef6ea7f;\n\ninterface ISafeOp {\n    /**\n     * @notice The EIP-712 type-hash for a SafeOp, representing the structure of a User Operation\n     * for\n     * the Safe.\n     *  {address} safe - The address of the safe on which the operation is performed.\n     *  {uint256} nonce - A unique number associated with the user operation, preventing replay\n     * attacks\n     * by ensuring each operation is unique.\n     *  {bytes} initCode - The packed encoding of a factory address and its factory-specific data\n     * for\n     * creating a new Safe account.\n     *  {bytes} callData - The bytes representing the data of the function call to be executed.\n     *  {uint128} verificationGasLimit - The maximum amount of gas allowed for the verification\n     * process.\n     *  {uint128} callGasLimit - The maximum amount of gas allowed for executing the function call.\n     *  {uint256} preVerificationGas - The amount of gas allocated for pre-verification steps before\n     * executing the main operation.\n     *  {uint128} maxPriorityFeePerGas - The maximum priority fee per gas that the user is willing\n     * to\n     * pay for the transaction.\n     *  {uint128} maxFeePerGas - The maximum fee per gas that the user is willing to pay for the\n     * transaction.\n     *  {bytes} paymasterAndData - The packed encoding of a paymaster address and its\n     * paymaster-specific\n     * data for sponsoring the user operation.\n     *  {uint48} validAfter - A timestamp representing from when the user operation is valid.\n     *  {uint48} validUntil - A timestamp representing until when the user operation is valid, or 0\n     * to\n     * indicated \"forever\".\n     *  {address} entryPoint - The address of the entry point that will execute the user operation.\n     * @dev When validating the user operation, the signature timestamps are pre-pended to the\n     * signature\n     * bytes. Equal to:\n     * keccak256(\n     *     \"SafeOp(address safe,uint256 nonce,bytes initCode,bytes callData,uint128\n     * verificationGasLimit,uint128 callGasLimit,uint256 preVerificationGas,uint128\n     * maxPriorityFeePerGas,uint128 maxFeePerGas,bytes paymasterAndData,uint48 validAfter,uint48\n     * validUntil,address entryPoint)\"\n     * ) = 0xc03dfc11d8b10bf9cf703d558958c8c42777f785d998c62060d85a4f0ef6ea7f\n     */\n    struct EncodedSafeOpStruct {\n        bytes32 typeHash;\n        address safe;\n        uint256 nonce;\n        bytes32 initCodeHash;\n        bytes32 callDataHash;\n        uint128 verificationGasLimit;\n        uint128 callGasLimit;\n        uint256 preVerificationGas;\n        uint128 maxPriorityFeePerGas;\n        uint128 maxFeePerGas;\n        bytes32 paymasterAndDataHash;\n        uint48 validAfter;\n        uint48 validUntil;\n        address entryPoint;\n    }\n\n    function domainSeparator() external view returns (bytes32);\n\n    function getSafeOp(\n        PackedUserOperation calldata userOp,\n        address entryPoint\n    )\n        external\n        view\n        returns (\n            bytes memory operationData,\n            uint48 validAfter,\n            uint48 validUntil,\n            bytes calldata signatures\n        );\n}\n"
    },
    "node_modules/@ERC4337/account-abstraction/contracts/interfaces/IStakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.5;\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    // Emitted when stake or unstake delay are modified.\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    // Emitted once a stake is scheduled for withdrawal.\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit         - The entity's deposit.\n     * @param staked          - True if this entity is staked.\n     * @param stake           - Actual amount of ether staked for this entity.\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\n     *      - 112 bit allows for 10^15 eth\n     *      - 48 bit for full timestamp\n     *      - 32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint256 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    // API struct used by getStakeInfo and simulateValidation.\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /**\n     * Get deposit info.\n     * @param account - The account to query.\n     * @return info   - Full deposit information of given account.\n     */\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /**\n     * Get account balance.\n     * @param account - The account to query.\n     * @return        - The deposit (for gas payment) of the account.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"
    },
    "node_modules/@ERC4337/account-abstraction/contracts/interfaces/IAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * Validate aggregated signature.\n     * Revert if the aggregated signature does not match the given list of operations.\n     * @param userOps   - Array of UserOperations to validate the signature for.\n     * @param signature - The aggregated signature.\n     */\n    function validateSignatures(\n        PackedUserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * Validate signature of a single userOp.\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\n     * the aggregator this account uses.\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp        - The userOperation received from the user.\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * Aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation.\n     * @param userOps              - Array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature - The aggregated signature.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"
    },
    "node_modules/@ERC4337/account-abstraction/contracts/interfaces/INonceManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\ninterface INonceManager {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"
    },
    "src/core/RegistryAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC7484 } from \"../interfaces/IERC7484.sol\";\nimport { ExecutionHelper } from \"./ExecutionHelper.sol\";\nimport { ISafe } from \"../interfaces/ISafe.sol\";\nimport { ISafe7579 } from \"../ISafe7579.sol\";\n\n/**\n * IERC7484 Registry adapter.\n * this feature is opt-in. The smart account owner can choose to use the registry and which\n * attesters to trust.\n * @author zeroknots.eth | rhinestone.wtf\n */\nabstract contract RegistryAdapter is ISafe7579, ExecutionHelper {\n    mapping(address smartAccount => IERC7484 registry) internal $registry;\n\n    modifier withRegistry(address module, uint256 moduleType) {\n        _checkRegistry(module, moduleType);\n        _;\n    }\n\n    /**\n     * Check on ERC7484 Registry, if suffcient attestations were made\n     * This will revert, if not succicient valid attestations are on the registry\n     */\n    function _checkRegistry(address module, uint256 moduleType) internal view {\n        IERC7484 registry = $registry[msg.sender];\n        if (address(registry) != address(0)) {\n            // this will revert if attestations / threshold are not met\n            registry.checkForAccount(msg.sender, module, moduleType);\n        }\n    }\n\n    /**\n     * Configure ERC7484 Registry for Safe\n     */\n    function _configureRegistry(\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    )\n        internal\n    {\n        // sstore value in any case, as this function may be used to disable the use of registry\n        $registry[msg.sender] = registry;\n        // registry is an opt in feature for Safe7579. if set, configure trusted attesters\n        if (registry != IERC7484(address(0))) {\n            _exec({\n                safe: ISafe(msg.sender),\n                target: address(registry),\n                value: 0,\n                callData: abi.encodeCall(IERC7484.trustAttesters, (threshold, attesters))\n            });\n        }\n        emit ERC7484RegistryConfigured(msg.sender, registry);\n    }\n}\n"
    },
    "node_modules/erc7579/src/core/Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title Receiver\n * @dev This contract receives safe-transferred ERC721 and ERC1155 tokens.\n * @author Modified from Solady\n * (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol)\n */\nabstract contract Receiver {\n    /// @dev For receiving ETH.\n    receive() external payable virtual { }\n\n    /// @dev Fallback function with the `receiverFallback` modifier.\n    fallback() external payable virtual receiverFallback { }\n\n    /// @dev Modifier for the fallback function to handle token callbacks.\n    modifier receiverFallback() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, calldataload(0))\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\n                mstore(0x20, s) // Store `msg.sig`.\n                return(0x3c, 0x20) // Return `msg.sig`.\n            }\n        }\n        _;\n    }\n}\n"
    },
    "src/core/ExecutionHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { Safe7579DCUtil, Safe7579DCUtilSetup } from \"./SetupDCUtil.sol\";\nimport { BatchedExecUtil } from \"../utils/DCUtil.sol\";\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\nimport { ISafe } from \"../interfaces/ISafe.sol\";\n\n/**\n * Abstraction layer for executions.\n * @dev All interactions with modules must originate from msg.sender == SafeProxy. This entails\n * avoiding direct calls by the Safe7579 Adapter for actions like onInstall on modules or\n * validateUserOp on validator modules, and utilizing the Safe's execTransactionFromModule feature\n * instead.\n * @dev Since Safe7579 offers features like TryExecute for batched executions, rewriting and\n * verifying execution success across the codebase can be challenging and error-prone. These\n * functions serve to interact with modules and external contracts.\n */\nabstract contract ExecutionHelper is Safe7579DCUtilSetup {\n    event TryExecutionFailed(ISafe safe, uint256 numberInBatch);\n    event TryExecutionsFailed(ISafe safe, bool[] success);\n\n    error ExecutionFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EXEC - REVERT ON FAIL                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    function _exec(ISafe safe, Execution[] calldata executions) internal {\n        _delegatecall({\n            safe: safe,\n            target: UTIL,\n            callData: abi.encodeCall(BatchedExecUtil.execute, executions)\n        });\n    }\n\n    function _exec(ISafe safe, address target, uint256 value, bytes memory callData) internal {\n        bool success = safe.execTransactionFromModule(target, value, callData, ISafe.Operation.Call);\n        if (!success) revert ExecutionFailed();\n    }\n\n    function _delegatecall(ISafe safe, address target, bytes memory callData) internal {\n        bool success =\n            safe.execTransactionFromModule(target, 0, callData, ISafe.Operation.DelegateCall);\n        if (!success) revert ExecutionFailed();\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*             EXEC - REVERT ON FAIL & Return Values          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    /**\n     * Helper function to facilitate batched executions. Since Safe accounts do not support batched\n     * executions natively, we nudge the safe to delegatecall to ./utils/DCUTIL.sol, which then\n     * makes a multicall. This is to save on gas\n     */\n    function _execReturn(\n        ISafe safe,\n        Execution[] calldata executions\n    )\n        internal\n        returns (bytes[] memory retDatas)\n    {\n        retDatas = abi.decode(\n            _delegatecallReturn({\n                safe: safe,\n                target: UTIL,\n                callData: abi.encodeCall(BatchedExecUtil.executeReturn, executions)\n            }),\n            (bytes[])\n        );\n    }\n\n    function _execReturn(\n        ISafe safe,\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        returns (bytes memory retData)\n    {\n        bool success;\n        (success, retData) =\n            safe.execTransactionFromModuleReturnData(target, value, callData, ISafe.Operation.Call);\n        if (!success) revert ExecutionFailed();\n    }\n\n    function _delegatecallReturn(\n        ISafe safe,\n        address target,\n        bytes memory callData\n    )\n        internal\n        returns (bytes memory retData)\n    {\n        bool success;\n        (success, retData) = safe.execTransactionFromModuleReturnData(\n            target, 0, callData, ISafe.Operation.DelegateCall\n        );\n        if (!success) revert ExecutionFailed();\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        EXEC - TRY                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    /**\n     * Helper function to facilitate batched executions. Since Safe accounts do not support batched\n     * executions natively, we nudge the safe to delegatecall to ./utils/DCUTIL.sol, which then\n     * makes a multicall. This is to save on gas\n     */\n    function _tryExec(ISafe safe, Execution[] calldata executions) internal {\n        _tryDelegatecall({\n            safe: safe,\n            target: UTIL,\n            callData: abi.encodeCall(BatchedExecUtil.tryExecute, executions)\n        });\n    }\n\n    function _tryExec(ISafe safe, address target, uint256 value, bytes memory callData) internal {\n        bool success = safe.execTransactionFromModule(target, value, callData, ISafe.Operation.Call);\n        if (!success) emit TryExecutionFailed(safe, 0);\n    }\n\n    function _tryDelegatecall(ISafe safe, address target, bytes memory callData) internal {\n        bool success =\n            safe.execTransactionFromModule(target, 0, callData, ISafe.Operation.DelegateCall);\n        if (!success) emit TryExecutionFailed(safe, 0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              EXEC - TRY & Return Values                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Helper function to facilitate batched executions. Since Safe accounts do not support batched\n     * executions natively, we nudge the safe to delegatecall to ./utils/DCUTIL.sol, which then\n     * makes a multicall. This is to save on gas\n     */\n    function _tryExecReturn(\n        ISafe safe,\n        Execution[] calldata executions\n    )\n        internal\n        returns (bool[] memory success, bytes[] memory retDatas)\n    {\n        bytes memory tmp = _tryDelegatecallReturn({\n            safe: safe,\n            target: UTIL,\n            callData: abi.encodeCall(BatchedExecUtil.tryExecuteReturn, executions)\n        });\n        (success, retDatas) = abi.decode(tmp, (bool[], bytes[]));\n\n        uint256 length = success.length;\n        for (uint256 i; i < length; i++) {\n            if (!success[i]) emit TryExecutionFailed(safe, i);\n        }\n    }\n\n    function _tryExecReturn(\n        ISafe safe,\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        returns (bytes memory retData)\n    {\n        bool success;\n        (success, retData) =\n            safe.execTransactionFromModuleReturnData(target, value, callData, ISafe.Operation.Call);\n        if (!success) emit TryExecutionFailed(safe, 0);\n    }\n\n    function _tryDelegatecallReturn(\n        ISafe safe,\n        address target,\n        bytes memory callData\n    )\n        internal\n        returns (bytes memory retData)\n    {\n        bool success;\n        (success, retData) = safe.execTransactionFromModuleReturnData(\n            target, 0, callData, ISafe.Operation.DelegateCall\n        );\n\n        if (!success) emit TryExecutionFailed(safe, 0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     STATICCALL TRICK                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Safe account does not natively implement Enum.Operation.StaticCall,\n     * using a trick with simulateAndRevert to execute a staticcall.\n     * @param safe Safe account to execute the staticcall\n     * @param target Target contract to staticcall\n     * @param callData Data to be passed to the target contract\n     */\n    function _staticcallReturn(\n        ISafe safe,\n        address target,\n        bytes memory callData\n    )\n        internal\n        view\n        returns (bytes memory result)\n    {\n        bytes memory staticCallData = abi.encodeCall(Safe7579DCUtil.staticCall, (target, callData));\n        bytes memory simulationCallData =\n            abi.encodeCall(ISafe.simulateAndRevert, (address(UTIL), staticCallData));\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            pop(\n                staticcall(\n                    gas(),\n                    safe,\n                    add(simulationCallData, 0x20),\n                    mload(simulationCallData),\n                    0x00,\n                    0x20\n                )\n            )\n\n            let responseSize := sub(returndatasize(), 0x20)\n            result := mload(0x40)\n            mstore(0x40, add(result, responseSize))\n            returndatacopy(result, 0x20, responseSize)\n\n            if iszero(mload(0x00)) { revert(add(result, 0x20), mload(result)) }\n        }\n    }\n}\n"
    },
    "src/core/SetupDCUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { Safe7579DCUtil } from \"../utils/DCUtil.sol\";\n\n/**\n * Deployes Safe7579DCUtil\n */\nabstract contract Safe7579DCUtilSetup {\n    address internal immutable UTIL;\n\n    constructor() {\n        UTIL = address(new Safe7579DCUtil());\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@rhinestone/=node_modules/@rhinestone/",
      "sentinellist/=node_modules/@rhinestone/sentinellist/src/",
      "erc4337-validation/=node_modules/@rhinestone/erc4337-validation/src/",
      "modulekit/=node_modules/@rhinestone/modulekit/src/",
      "module-bases/=node_modules/@rhinestone/module-bases/src/",
      "@ERC4337/=node_modules/@ERC4337/",
      "account-abstraction/=node_modules/@ERC4337/account-abstraction/contracts/",
      "account-abstraction-v0.6/=node_modules/@ERC4337/account-abstraction-v0.6/contracts/",
      "@openzeppelin/=node_modules/@openzeppelin/",
      "@safe-global/=node_modules/@safe-global/",
      "ds-test/=node_modules/ds-test/src/",
      "erc7579/=node_modules/erc7579/src/",
      "forge-std/=node_modules/forge-std/src/",
      "solady/=node_modules/solady/src/",
      "solarray/=node_modules/solarray/src/",
      "@prb/math/=node_modules/@prb/math/src/",
      "@gnosis.pm/=node_modules/@gnosis.pm/",
      "hardhat-deploy/=node_modules/hardhat-deploy/",
      "hardhat/=node_modules/hardhat/"
    ],
    "optimizer": { "enabled": true, "runs": 200 },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode.object",
          "evm.bytecode.sourceMap",
          "evm.bytecode.linkReferences",
          "evm.deployedBytecode.object",
          "evm.deployedBytecode.sourceMap",
          "evm.deployedBytecode.linkReferences",
          "evm.deployedBytecode.immutableReferences",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "evmVersion": "paris",
    "viaIR": false,
    "libraries": {}
  }
}
