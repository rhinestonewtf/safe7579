{"language":"Solidity","sources":{"src/Safe7579Launchpad.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport { _packValidationData } from \"@ERC4337/account-abstraction/contracts/core/Helpers.sol\";\nimport { SafeOp } from \"./core/SafeOp.sol\";\n\nimport {\n    IAccount,\n    PackedUserOperation\n} from \"@ERC4337/account-abstraction/contracts/interfaces/IAccount.sol\";\nimport { ISafe } from \"./interfaces/ISafe.sol\";\nimport { ISafeOp } from \"./interfaces/ISafeOp.sol\";\nimport { ISafe7579 } from \"./ISafe7579.sol\";\nimport { IERC7484 } from \"./interfaces/IERC7484.sol\";\nimport \"./DataTypes.sol\";\n\nimport { UserOperationLib } from \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\n\nimport { IValidator } from \"erc7579/interfaces/IERC7579Module.sol\";\n\nimport { SafeStorage } from \"@safe-global/safe-contracts/contracts/libraries/SafeStorage.sol\";\n\nimport { MODULE_TYPE_VALIDATOR } from \"erc7579/interfaces/IERC7579Module.sol\";\nimport { CheckSignatures } from \"@rhinestone/checknsignatures/src/CheckNSignatures.sol\";\nimport { LibSort } from \"solady/utils/LibSort.sol\";\nimport { SupportViewer } from \"./core/SupportViewer.sol\";\nimport { IERC7579AccountEvents } from \"./interfaces/IERC7579Account.sol\";\n\n/**\n * Launchpad to deploy a Safe account and connect the Safe7579 adapter.\n * Check Readme.md for more information.\n * Note that (unlike some other smart accounts) the Safe7579 will only finish initializing the\n * account during the execution phase of the first UserOperation in order to comply with ERC-4337.\n * This means that if the exection of the first UserOperation fails, the account could be\n * permanently bricked. To avoid this, make sure that all the initialization and call data are\n * correctly set up and do not cause a revert on any chain that the account should be deployed on.\n * Special thanks to [nlordell (Safe)](https://github.com/nlordell), who came up with [this\n * technique](https://github.com/safe-global/safe-modules/pull/184)\n * @author rhinestone | zeroknots.eth\n */\ncontract Safe7579Launchpad is\n    IAccount,\n    SafeStorage,\n    SafeOp,\n    SupportViewer,\n    IERC7579AccountEvents\n{\n    using LibSort for address[];\n    using CheckSignatures for bytes32;\n\n    // keccak256(\"Safe7579Launchpad.initHash\") - 1\n    uint256 private constant INIT_HASH_SLOT =\n        0x982e06ee6a56dfc0f1ac189a5d23506361ca0a3ce45a9c7b8d33d65d43746a24;\n\n    /**\n     * @notice The keccak256 hash of the EIP-712 InitData struct, representing the structure\n     */\n    struct InitData {\n        address singleton;\n        address[] owners;\n        uint256 threshold;\n        address setupTo;\n        bytes setupData;\n        ISafe7579 safe7579;\n        ModuleInit[] validators;\n        bytes callData;\n    }\n\n    address private immutable SELF;\n    address public immutable SUPPORTED_ENTRYPOINT;\n    IERC7484 public immutable REGISTRY;\n\n    error InvalidEntryPoint();\n    error InvalidSetup();\n    error Safe7579LaunchpadAlreadyInitialized();\n    error OnlyDelegatecall();\n    error OnlyProxy();\n    error PreValidationSetupFailed();\n    error InvalidUserOperationData();\n    error InvalidInitHash();\n\n    constructor(address entryPoint, IERC7484 registry) {\n        if (entryPoint == address(0)) revert InvalidEntryPoint();\n\n        SELF = address(this);\n        SUPPORTED_ENTRYPOINT = entryPoint;\n        REGISTRY = registry;\n    }\n\n    modifier onlySelfDelegatecall() {\n        if (msg.sender != address(this)) revert OnlyDelegatecall();\n        _;\n    }\n\n    modifier onlyProxy() {\n        if (singleton != SELF) revert OnlyProxy();\n        _;\n    }\n\n    modifier onlySupportedEntryPoint() {\n        if (msg.sender != SUPPORTED_ENTRYPOINT) revert InvalidEntryPoint();\n        _;\n    }\n\n    receive() external payable onlyProxy { }\n\n    /**\n     * This function is intended to be delegatecalled by the ISafe.setup function. It configures the\n     * Safe7579 for the user for all module types except validators, which were initialized in the\n     * validateUserOp function.\n     */\n    function initSafe7579(\n        address safe7579,\n        ModuleInit[] calldata modules,\n        address[] calldata attesters,\n        uint8 threshold\n    )\n        public\n        onlySelfDelegatecall\n    {\n        ISafe(address(this)).enableModule(safe7579);\n        ISafe7579(payable(this)).initializeAccount({\n            modules: modules,\n            registryInit: RegistryInit({ registry: REGISTRY, attesters: attesters, threshold: threshold })\n        });\n    }\n\n    /**\n     * This function allows existing safe accounts to add the Safe7579 adapter to their account\n     */\n    function addSafe7579(\n        address safe7579,\n        ModuleInit[] calldata modules,\n        address[] calldata attesters,\n        uint8 threshold\n    )\n        external\n    {\n        ISafe(address(this)).enableModule(safe7579);\n        ISafe(address(this)).setFallbackHandler(safe7579);\n        ISafe7579(payable(this)).initializeAccount({\n            modules: modules,\n            registryInit: RegistryInit({ registry: REGISTRY, attesters: attesters, threshold: threshold })\n        });\n    }\n\n    /**\n     * SafeProxyFactory will create a SafeProxy and using this contract as the singleton\n     * implementation and call this function to initialize the account.\n     * will write initHash into SafeProxy storage\n     * @param initHash will be calculated offchain using this.hash(InitData)\n     * @param to optional parameter for a delegatecall\n     * @param preInit optional parameter for a delegatecall\n     */\n    function preValidationSetup(\n        bytes32 initHash,\n        address to,\n        bytes calldata preInit\n    )\n        external\n        onlyProxy\n    {\n        if (getInitHash() != bytes32(0)) revert Safe7579LaunchpadAlreadyInitialized();\n\n        // sstore inithash\n        _setInitHash(initHash);\n\n        // if a delegatecall target is provided, SafeProxy will execute a delegatecall\n        if (to != address(0)) {\n            (bool success,) = to.delegatecall(preInit);\n            if (!success) revert PreValidationSetupFailed();\n        }\n    }\n\n    /**\n     * Upon creation of SafeProxy by SafeProxyFactory, EntryPoint invokes this function to verify\n     * the transaction. It ensures that only this.setupSafe() can be called by EntryPoint during\n     * execution. The function validates the hash of InitData in userOp.callData against the hash\n     * stored in preValidationSetup. This function abides by ERC4337 storage restrictions, allowing\n     * Safe7579 adapter initialization only in Validation Modules compliant with 4337. It installs\n     * validators from InitData onto the Safe7579 adapter for the account. When called by EP, the\n     * SafeProxy singleton address remains unupgraded to SafeSingleton, preventing\n     * execTransactionFromModule by Safe7579 Adapter. Initialization of Validator Modules is\n     * achieved through a direct call to onInstall(). This delegatecalled function initializes the\n     * Validator Module with the correct msg.sender. Once all validator modules are set up, they can\n     * be used to validate the userOp. Parameters include userOp (EntryPoint v0.7 userOp),\n     * userOpHash, and missingAccountFunds representing the gas payment required.\n     *\n     * @param userOp EntryPoint v0.7 userOp.\n     * @param userOpHash hash of userOp\n     * @param missingAccountFunds amount of gas that has to be paid\n     * @return validationData 4337 packed validation data returned by the validator module\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        onlyProxy // ensure SafeProxy called this\n        onlySupportedEntryPoint\n        returns (uint256 validationData)\n    {\n        if (this.setupSafe.selector != bytes4(userOp.callData[:4])) {\n            revert InvalidUserOperationData();\n        }\n\n        InitData memory initData = abi.decode(userOp.callData[4:], (InitData));\n        // read stored initHash from SafeProxy storage. only proceed if the InitData hash matches\n        if (hash(initData) != getInitHash()) revert InvalidInitHash();\n\n        // get validator from nonce encoding\n        address validator;\n        uint256 nonce = userOp.nonce;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            validator := shr(96, nonce)\n        }\n\n        // initialize validator on behalf of the safe account\n        // the call below is equivalent to:\n        // ISafe7579(initData.safe7579).initializeAccountWithValidators(initData.validators);\n        // but we need to append msg.sender (entrypoint) to ERC2771 style access control, to protect\n        // the launchpadValidator function\n        (bool success,) = address(initData.safe7579).call(\n            abi.encodePacked(\n                abi.encodeCall(ISafe7579.initializeAccountWithValidators, (initData.validators)), // validators\n                msg.sender // ERC2771 access control\n            )\n        );\n\n        // ensure that the call was successful\n        if (!success) revert InvalidUserOperationData();\n\n        // Call onInstall on each validator module to set up the validators.\n        // Since this function is delegatecalled by the SafeProxy, the Validator Module is\n        // called\n        // with msg.sender == SafeProxy.\n        bool userOpValidatorInstalled;\n        uint256 validatorsLength = initData.validators.length;\n        for (uint256 i; i < validatorsLength; i++) {\n            address validatorModule = initData.validators[i].module;\n            IValidator(validatorModule).onInstall(initData.validators[i].initData);\n            emit ModuleInstalled(MODULE_TYPE_VALIDATOR, validatorModule);\n\n            if (validatorModule == validator) userOpValidatorInstalled = true;\n        }\n\n        // Ensure that the validator module selected in the userOp was\n        // part of the validators in InitData\n        if (userOpValidatorInstalled) {\n            // validate userOp with selected validation module.\n            validationData = IValidator(validator).validateUserOp(userOp, userOpHash);\n        } else {\n            // otherwise we fall back to safe-style validation, like in the safe7579\n            (bool validSig, uint48 validUntil, uint48 validAfter) =\n                _isValidSafeSigners(initData, userOp);\n\n            validationData = _packValidationData({\n                sigFailed: !validSig,\n                validUntil: validUntil,\n                validAfter: validAfter\n            });\n        }\n\n        // pay back gas to EntryPoint\n        if (missingAccountFunds > 0) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly (\"memory-safe\") {\n                pop(call(gas(), caller(), missingAccountFunds, 0, 0, 0, 0))\n            }\n        }\n    }\n\n    function _isValidSafeSigners(\n        InitData memory safeSetupCallData,\n        PackedUserOperation calldata userOp\n    )\n        internal\n        view\n        returns (bool validSig, uint48 validUntil, uint48 validAfter)\n    {\n        bytes memory operationData;\n        bytes memory signatures;\n        // decode ERC4337 userOp into Safe operation.\n        (operationData, validAfter, validUntil, signatures) =\n            ISafeOp(safeSetupCallData.safe7579).getSafeOp(userOp, SUPPORTED_ENTRYPOINT);\n        bytes32 _hash = keccak256(operationData);\n\n        address[] memory signers = _hash.recoverNSignatures(signatures, safeSetupCallData.threshold);\n        signers.insertionSort();\n\n        address[] memory owners = safeSetupCallData.owners;\n\n        // sorting owners here instead of requiring sorted list for improved UX\n        owners.insertionSort();\n        owners.uniquifySorted();\n\n        uint256 ownersLength = owners.length;\n\n        uint256 validSigs;\n        for (uint256 i; i < ownersLength; i++) {\n            (bool found,) = signers.searchSorted(owners[i]);\n            if (found) {\n                validSigs++;\n                if (validSigs >= safeSetupCallData.threshold) {\n                    return (true, validUntil, validAfter);\n                }\n            }\n        }\n        return (false, validUntil, validAfter);\n    }\n\n    /**\n     * During the execution phase of ERC4337, this function upgrades the SafeProxy to the actual\n     * SafeSingleton implementation. Subsequently, it invokes the ISafe.setup() function to\n     * initialize the Safe Account. The setup() function should ensure the completion of Safe7579\n     * Adapter initialization with InitData.setupTo as address(this) and InitData.setupData encoding\n     * the call to this.initSafe7579(). SafeProxy.setup() delegatecalls this function to install\n     * executors, fallbacks, hooks, and registry configurations on the Safe7579 adapter. As this\n     * occurs in the ERC4337 execution phase, storage restrictions are not applicable.\n     *\n     * @param initData initData to initialize the Safe and Safe7579 Adapter\n     */\n    function setupSafe(InitData calldata initData) external onlySupportedEntryPoint {\n        // update singleton to Safe account implementation\n        // from now on, ISafe can be used to interact with the SafeProxy\n        SafeStorage.singleton = initData.singleton;\n\n        // setupTo should be this launchpad\n        if (initData.setupTo != SELF) revert InvalidSetup();\n        // // setupData should be a call to this.initSafe7579()\n        if (bytes4(initData.setupData[:4]) != this.initSafe7579.selector) revert InvalidSetup();\n        // setup SafeAccount\n        ISafe(address(this)).setup({\n            _owners: initData.owners,\n            _threshold: initData.threshold,\n            to: initData.setupTo,\n            data: initData.setupData,\n            fallbackHandler: address(initData.safe7579),\n            paymentToken: address(0),\n            payment: 0,\n            paymentReceiver: payable(address(0))\n        });\n\n        // reset initHash\n        _setInitHash(0);\n        // in order to allow launchpad users to perform 7579 account operations like execute(), in\n        // the safe transaction context of the launchpad setup, any call can be encoded in\n        // initData.callData\n        (bool success, bytes memory returnData) = address(initData.safe7579).call(\n            abi.encodePacked(\n                initData.callData, // encode arbitrary execution here. i.e. IERC7579.execute()\n                address(this) // ERC2771 access control\n            )\n        );\n        if (!success) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly (\"memory-safe\") {\n                revert(add(returnData, 0x20), mload(returnData))\n            }\n        }\n    }\n\n    // sload inithash from SafeProxy storage\n    function getInitHash() public view returns (bytes32 value) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            value := sload(INIT_HASH_SLOT)\n        }\n    }\n\n    // store inithash in SafeProxy storage\n    function _setInitHash(bytes32 value) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            sstore(INIT_HASH_SLOT, value)\n        }\n    }\n\n    /**\n     * Helper function that can be used offchain to predict the counterfactual Safe address.\n     * @dev factoryInitializer is expected to be:\n     * abi.encodeCall(Safe7579Launchpad.preValidationSetup, (initHash, to, callData));\n     */\n    function predictSafeAddress(\n        address singleton,\n        address safeProxyFactory,\n        bytes memory creationCode,\n        bytes32 salt,\n        bytes memory factoryInitializer\n    )\n        external\n        pure\n        returns (address safeProxy)\n    {\n        salt = keccak256(abi.encodePacked(keccak256(factoryInitializer), salt));\n\n        safeProxy = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xff),\n                            address(safeProxyFactory),\n                            salt,\n                            keccak256(\n                                abi.encodePacked(creationCode, uint256(uint160(address(singleton))))\n                            )\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * Create unique InitData hash. Using all params but excluding data.callData from hash\n     */\n    function hash(InitData memory data) public pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                data.singleton,\n                data.owners,\n                data.threshold,\n                data.setupTo,\n                data.setupData,\n                data.safe7579,\n                data.validators\n            )\n        );\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/Helpers.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\n\n /*\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n  * must return this value in case of signature failure, instead of revert.\n  */\nuint256 constant SIG_VALIDATION_FAILED = 1;\n\n\n/*\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n * return this value on success.\n */\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\n\n\n/**\n * Returned data from validateUserOp.\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\n * parsed by `_parseValidationData`.\n * @param aggregator  - address(0) - The account validated the signature by itself.\n *                      address(1) - The account failed to validate the signature.\n *                      otherwise - This is an address of a signature aggregator that must\n *                                  be used to validate the signature.\n * @param validAfter  - This UserOp is valid only after this timestamp.\n * @param validaUntil - This UserOp is valid only up to this timestamp.\n */\nstruct ValidationData {\n    address aggregator;\n    uint48 validAfter;\n    uint48 validUntil;\n}\n\n/**\n * Extract sigFailed, validAfter, validUntil.\n * Also convert zero validUntil to type(uint48).max.\n * @param validationData - The packed validation data.\n */\nfunction _parseValidationData(\n    uint256 validationData\n) pure returns (ValidationData memory data) {\n    address aggregator = address(uint160(validationData));\n    uint48 validUntil = uint48(validationData >> 160);\n    if (validUntil == 0) {\n        validUntil = type(uint48).max;\n    }\n    uint48 validAfter = uint48(validationData >> (48 + 160));\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * Helper to pack the return value for validateUserOp.\n * @param data - The ValidationData to pack.\n */\nfunction _packValidationData(\n    ValidationData memory data\n) pure returns (uint256) {\n    return\n        uint160(data.aggregator) |\n        (uint256(data.validUntil) << 160) |\n        (uint256(data.validAfter) << (160 + 48));\n}\n\n/**\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\n * @param sigFailed  - True for signature failure, false for success.\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\n * @param validAfter - First timestamp this UserOperation is valid.\n */\nfunction _packValidationData(\n    bool sigFailed,\n    uint48 validUntil,\n    uint48 validAfter\n) pure returns (uint256) {\n    return\n        (sigFailed ? 1 : 0) |\n        (uint256(validUntil) << 160) |\n        (uint256(validAfter) << (160 + 48));\n}\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n */\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let mem := mload(0x40)\n            let len := data.length\n            calldatacopy(mem, data.offset, len)\n            ret := keccak256(mem, len)\n        }\n    }\n\n\n/**\n * The minimum of two numbers.\n * @param a - First number.\n * @param b - Second number.\n */\n    function min(uint256 a, uint256 b) pure returns (uint256) {\n        return a < b ? a : b;\n    }\n"},"src/core/SafeOp.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport {\n    PackedUserOperation,\n    UserOperationLib\n} from \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\nimport { SAFE_OP_TYPEHASH, ISafeOp } from \"../interfaces/ISafeOp.sol\";\nimport { LibBytes } from \"solady/utils/LibBytes.sol\";\n\nabstract contract SafeOp is ISafeOp {\n    using UserOperationLib for PackedUserOperation;\n    using LibBytes for bytes;\n\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    /**\n     * @dev Decodes an ERC-4337 user operation into a Safe operation.\n     * @param userOp The ERC-4337 user operation.\n     * @return operationData Encoded EIP-712 Safe operation data bytes used for signature\n     * verification.\n     * @return validAfter The timestamp the user operation is valid from.\n     * @return validUntil The timestamp the user operation is valid until.\n     * @return signatures The Safe owner signatures extracted from the user operation.\n     */\n    function getSafeOp(\n        PackedUserOperation memory userOp,\n        address entryPoint\n    )\n        public\n        view\n        returns (\n            bytes memory operationData,\n            uint48 validAfter,\n            uint48 validUntil,\n            bytes memory signatures\n        )\n    {\n        // Extract additional Safe operation fields from the user operation signature which is\n        // encoded as:\n        // `abi.encodePacked(validAfter, validUntil, signatures)`\n        // This is how we can extract signature components from memory\n        {\n            bytes memory sig = userOp.signature;\n            validAfter = uint48(bytes6(sig.slice(0, 6)));\n            validUntil = uint48(bytes6(sig.slice(6, 12)));\n            signatures = sig.slice(12);\n        }\n\n        // It is important that **all** user operation fields are represented in the `SafeOp` data\n        // somehow, to prevent\n        // user operations from being submitted that do not fully respect the user preferences. The\n        // only exception is\n        // the `signature` bytes. Note that even `initCode` needs to be represented in the operation\n        // data, otherwise\n        // it can be replaced with a more expensive initialization that would charge the user\n        // additional fees.\n        {\n            // In order to work around Solidity \"stack too deep\" errors related to too many stack\n            // variables, manually\n            // encode the `SafeOp` fields into a memory `struct` for computing the EIP-712\n            // struct-hash. This works\n            // because the `EncodedSafeOpStruct` struct has no \"dynamic\" fields so its memory layout\n            // is identical to the\n            // result of `abi.encode`-ing the individual fields.\n            EncodedSafeOpStruct memory encodedSafeOp = EncodedSafeOpStruct({\n                typeHash: SAFE_OP_TYPEHASH,\n                safe: userOp.sender,\n                nonce: userOp.nonce,\n                initCodeHash: keccak256(userOp.initCode),\n                callDataHash: keccak256(userOp.callData),\n                verificationGasLimit: uint128(unpackVerificationGasLimit(userOp)),\n                callGasLimit: uint128(unpackCallGasLimit(userOp)),\n                preVerificationGas: userOp.preVerificationGas,\n                maxPriorityFeePerGas: uint128(unpackMaxPriorityFeePerGas(userOp)),\n                maxFeePerGas: uint128(unpackMaxFeePerGas(userOp)),\n                paymasterAndDataHash: keccak256(userOp.paymasterAndData),\n                validAfter: validAfter,\n                validUntil: validUntil,\n                entryPoint: entryPoint\n            });\n\n            bytes32 safeOpStructHash;\n            // solhint-disable-next-line no-inline-assembly\n            assembly (\"memory-safe\") {\n                // Since the `encodedSafeOp` value's memory layout is identical to the result of\n                // `abi.encode`-ing the\n                // individual `SafeOp` fields, we can pass it directly to `keccak256`. Additionally,\n                // there are 14\n                // 32-byte fields to hash, for a length of `14 * 32 = 448` bytes.\n                safeOpStructHash := keccak256(encodedSafeOp, 448)\n            }\n\n            operationData =\n                abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeOpStructHash);\n        }\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, block.chainid, this));\n    }\n\n    function unpackVerificationGasLimit(PackedUserOperation memory userOp)\n        private\n        pure\n        returns (uint256)\n    {\n        return UserOperationLib.unpackHigh128(userOp.accountGasLimits);\n    }\n\n    function unpackCallGasLimit(PackedUserOperation memory userOp) private pure returns (uint256) {\n        return UserOperationLib.unpackLow128(userOp.accountGasLimits);\n    }\n\n    function unpackMaxPriorityFeePerGas(PackedUserOperation memory userOp)\n        private\n        pure\n        returns (uint256)\n    {\n        return UserOperationLib.unpackHigh128(userOp.gasFees);\n    }\n\n    function unpackMaxFeePerGas(PackedUserOperation memory userOp) private pure returns (uint256) {\n        return UserOperationLib.unpackLow128(userOp.gasFees);\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IAccount.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccount {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp              - The operation that is about to be executed.\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\n     *                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                 otherwise, an address of an \"authorizer\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \"indefinite\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\n"},"src/interfaces/ISafe.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface ISafe {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    )\n        external;\n\n    /**\n     * @dev Allows a Module to execute a Safe transaction without any further confirmations.\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     */\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    )\n        external\n        returns (bool success);\n\n    /**\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)\n     * and return data\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     * @return success Boolean flag indicating if the call succeeded.\n     * @return returnData Data returned by the call.\n     */\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    )\n        external\n        returns (bool success, bytes memory returnData);\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert\n     * otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract\n     * signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    )\n        external\n        view;\n\n    function signedMessages(bytes32) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\n     * @return bytes32 The domain separator hash.\n     */\n    function domainSeparator() external view returns (bytes32);\n\n    function VERSION() external pure returns (string memory);\n\n    function getStorageAt(uint256 offset, uint256 length) external view returns (bytes memory);\n\n    /**\n     * @dev Returns array of modules.\n     * @param start Start of the page.\n     * @param pageSize Maximum number of modules that should be returned.\n     * @return array Array of modules.\n     * @return next Start of the next page.\n     */\n    function getModulesPaginated(\n        address start,\n        uint256 pageSize\n    )\n        external\n        view\n        returns (address[] memory array, address next);\n\n    /**\n     * @notice Enables the module `module` for the Safe.\n     * @dev This can only be done via a Safe transaction.\n     * @param module Module to be enabled.\n     */\n    function enableModule(address module) external;\n\n    function setFallbackHandler(address handler) external;\n\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external;\n}\n"},"src/interfaces/ISafeOp.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nbytes32 constant SAFE_OP_TYPEHASH =\n    0xc03dfc11d8b10bf9cf703d558958c8c42777f785d998c62060d85a4f0ef6ea7f;\n\ninterface ISafeOp {\n    /**\n     * @notice The EIP-712 type-hash for a SafeOp, representing the structure of a User Operation\n     * for\n     * the Safe.\n     *  {address} safe - The address of the safe on which the operation is performed.\n     *  {uint256} nonce - A unique number associated with the user operation, preventing replay\n     * attacks\n     * by ensuring each operation is unique.\n     *  {bytes} initCode - The packed encoding of a factory address and its factory-specific data\n     * for\n     * creating a new Safe account.\n     *  {bytes} callData - The bytes representing the data of the function call to be executed.\n     *  {uint128} verificationGasLimit - The maximum amount of gas allowed for the verification\n     * process.\n     *  {uint128} callGasLimit - The maximum amount of gas allowed for executing the function call.\n     *  {uint256} preVerificationGas - The amount of gas allocated for pre-verification steps before\n     * executing the main operation.\n     *  {uint128} maxPriorityFeePerGas - The maximum priority fee per gas that the user is willing\n     * to\n     * pay for the transaction.\n     *  {uint128} maxFeePerGas - The maximum fee per gas that the user is willing to pay for the\n     * transaction.\n     *  {bytes} paymasterAndData - The packed encoding of a paymaster address and its\n     * paymaster-specific\n     * data for sponsoring the user operation.\n     *  {uint48} validAfter - A timestamp representing from when the user operation is valid.\n     *  {uint48} validUntil - A timestamp representing until when the user operation is valid, or 0\n     * to\n     * indicated \"forever\".\n     *  {address} entryPoint - The address of the entry point that will execute the user operation.\n     * @dev When validating the user operation, the signature timestamps are pre-pended to the\n     * signature\n     * bytes. Equal to:\n     * keccak256(\n     *     \"SafeOp(address safe,uint256 nonce,bytes initCode,bytes callData,uint128\n     * verificationGasLimit,uint128 callGasLimit,uint256 preVerificationGas,uint128\n     * maxPriorityFeePerGas,uint128 maxFeePerGas,bytes paymasterAndData,uint48 validAfter,uint48\n     * validUntil,address entryPoint)\"\n     * ) = 0xc03dfc11d8b10bf9cf703d558958c8c42777f785d998c62060d85a4f0ef6ea7f\n     */\n    struct EncodedSafeOpStruct {\n        bytes32 typeHash;\n        address safe;\n        uint256 nonce;\n        bytes32 initCodeHash;\n        bytes32 callDataHash;\n        uint128 verificationGasLimit;\n        uint128 callGasLimit;\n        uint256 preVerificationGas;\n        uint128 maxPriorityFeePerGas;\n        uint128 maxFeePerGas;\n        bytes32 paymasterAndDataHash;\n        uint48 validAfter;\n        uint48 validUntil;\n        address entryPoint;\n    }\n\n    function domainSeparator() external view returns (bytes32);\n\n    function getSafeOp(\n        PackedUserOperation calldata userOp,\n        address entryPoint\n    )\n        external\n        view\n        returns (\n            bytes memory operationData,\n            uint48 validAfter,\n            uint48 validUntil,\n            bytes calldata signatures\n        );\n}\n"},"src/ISafe7579.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./DataTypes.sol\";\nimport { IERC7579Account } from \"./interfaces/IERC7579Account.sol\";\nimport { ModeCode } from \"./lib/ModeLib.sol\";\nimport { PackedUserOperation } from\n    \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\nimport { ISafeOp } from \"./interfaces/ISafeOp.sol\";\n\n/**\n * @title ERC7579 Adapter for Safe accounts.\n * creates full ERC7579 compliance to Safe accounts\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\ninterface ISafe7579 is IERC7579Account, ISafeOp {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         Validation                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * ERC4337 v0.7 validation function\n     * @dev expects that a ERC7579 validator module is encoded within the UserOp nonce.\n     *         if no validator module is provided, it will fallback to validate the transaction with\n     *         Safe's signers\n     */\n    function validateUserOp(\n        PackedUserOperation memory userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        returns (uint256 packedValidSig);\n\n    /**\n     * Will use Safe's signed messages or checkSignatures features or ERC7579 validation modules\n     * if no signature is provided, it makes use of Safe's signedMessages\n     * if address(0) or a non-installed validator module is provided, it will use Safe's\n     * checkSignatures\n     * if a valid validator module is provided, it will use the module's validateUserOp function\n     *    @param hash message hash of ERC1271 request\n     *    @param data abi.encodePacked(address validationModule, bytes signatures)\n     */\n    function isValidSignature(\n        bytes32 hash,\n        bytes memory data\n    )\n        external\n        view\n        returns (bytes4 magicValue);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         Executions                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Executes a transaction on behalf of the Safe account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @dev AccessControl: only Self of Entrypoint can install modules\n     * Safe7579 supports the following feature set:\n     *    CallTypes:\n     *             - CALLTYPE_SINGLE\n     *             - CALLTYPE_BATCH\n     *             - CALLTYPE_DELEGATECALL\n     *    ExecTypes:\n     *             - EXECTYPE_DEFAULT (revert if not successful)\n     *             - EXECTYPE_TRY\n     *    If a different mode is selected, this function will revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function execute(ModeCode mode, bytes memory executionCalldata) external;\n\n    /**\n     * @dev Executes a transaction on behalf of the Safe account.\n     *         This function is intended to be called by executor modules\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @dev AccessControl: only enabled executor modules\n     * Safe7579 supports the following feature set:\n     *    CallTypes:\n     *             - CALLTYPE_SINGLE\n     *             - CALLTYPE_BATCH\n     *             - CALLTYPE_DELEGATECALL\n     *    ExecTypes:\n     *             - EXECTYPE_DEFAULT (revert if not successful)\n     *             - EXECTYPE_TRY\n     *    If a different mode is selected, this function will revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes memory executionCalldata\n    )\n        external\n        returns (bytes[] memory returnDatas);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      Manage Modules                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Installs a 7579 Module of a certain type on the smart account\n     * @dev The module has to be initialized from msg.sender == SafeProxy, we thus use a\n     *    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579\n     *    module and emits the ModuleInstall/ModuleUnintall events\n     * @dev AccessControl: only Self of Entrypoint can install modules\n     * @dev If the safe set a registry, ERC7484 registry will be queried before installing\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @param moduleType the module type ID according the ERC-7579 spec\n     *                   Note: MULTITYPE_MODULE (uint(0)) is a special type to install a module with\n     *                         multiple types\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(uint256 moduleType, address module, bytes memory initData) external;\n\n    /**\n     * Uninstalls a Module of a certain type on the smart account.\n     * @dev The module has to be initialized from msg.sender == SafeProxy, we thus use a\n     *    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579\n     *    module and emits the ModuleInstall/ModuleUnintall events\n     * @dev AccessControl: only Self of Entrypoint can install modules\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @param moduleType the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleType,\n        address module,\n        bytes memory deInitData\n    )\n        external;\n\n    /**\n     * Emergency uninstall a hook module\n     * @dev Allows uninstalling hooks without triggering hooks during the uninstall process,\n     *      secured by a timelock. Usable on regular hooks and prevalidation hooks\n     * @param data EmergencyUninstall struct\n     * @param signature signature of the data, to be validated on a validator module or by\n     *      safe.checkSignatures if no validator module is supplied/installed\n     */\n    function emergencyUninstallHook(\n        EmergencyUninstall calldata data,\n        bytes calldata signature\n    )\n        external;\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleType the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleType,\n        address module,\n        bytes memory additionalContext\n    )\n        external\n        view\n        returns (bool);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   Initialize Safe7579                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * This function can be called by the Launchpad.initSafe7579() or by already existing Safes that\n     * want to use Safe7579\n     * if this is called by the Launchpad, it is expected that launchpadValidators() was called\n     * previously, and the param validators is empty\n     * @param modules Array of modules to initialize with their respective types\n     * @param registryInit (OPTIONAL) registry, attesters and threshold for IERC7484 Registry\n     *                    If not provided, the registry will be set to the zero address, and no\n     *                    registry checks will be performed\n     */\n    function initializeAccount(\n        ModuleInit[] calldata modules,\n        RegistryInit calldata registryInit\n    )\n        external;\n\n    /**\n     * This function is intended to be called by Launchpad.validateUserOp()\n     * @dev it will initialize the SentinelList4337 list for validators, and sstore all\n     * validators\n     * @dev Since this function has to be 4337 compliant (storage access), only validator storage is  acccess\n     * @dev Note: this function DOES NOT call onInstall() on the validator modules or emit\n     * ModuleInstalled events. this has to be done by the launchpad\n     */\n    function initializeAccountWithValidators(ModuleInit[] memory validators) external;\n\n    /**\n     * Configure the Safe7579 with a IERC7484 registry\n     * @param registry IERC7484 registry\n     * @param attesters list of attesters\n     * @param threshold number of attesters required\n     */\n    function setRegistry(IERC7484 registry, address[] memory attesters, uint8 threshold) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   Query Account Details                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    function getValidatorsPaginated(\n        address cursor,\n        uint256 pageSize\n    )\n        external\n        view\n        returns (address[] memory array, address next);\n\n    /**\n     * Get the current active global hook\n     */\n    function getActiveHook() external view returns (address hook);\n\n    function getExecutorsPaginated(\n        address cursor,\n        uint256 size\n    )\n        external\n        view\n        returns (address[] memory array, address next);\n\n    /**\n     * Get the current active prevalidation hook for the given module type\n     * @param moduleType the prevalidation hook type\n     */\n    function getPrevalidationHook(uint256 moduleType) external view returns (address hook);\n\n    /**\n     * Get the current active fallback handler and call type for the given selector\n     * @param selector the function selector\n     */\n    function getFallbackHandlerBySelector(bytes4 selector)\n        external\n        view\n        returns (CallType, address);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        Query Misc                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Safe7579 is using validator selection encoding in the userop nonce.\n     * to make it easier for SDKs / devs to integrate, this function can be\n     * called to get the next nonce for a specific validator\n     * @param safe address of safe account\n     * @param validator ERC7579 validator to encode\n     */\n    function getNonce(address safe, address validator) external view returns (uint256 nonce);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       Custom Errors                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    error InvalidModule(address module);\n    error InvalidModuleType(address module, uint256 moduleType);\n    error ModuleNotInstalled(address module, uint256 moduleType);\n    error InvalidNonce();\n\n    // fallback handlers\n    error InvalidInput();\n    error InvalidCallType(CallType callType);\n    error NoFallbackHandler(bytes4 msgSig);\n    error InvalidFallbackHandler(bytes4 msgSig);\n    error FallbackInstalled(bytes4 msgSig);\n\n    // Hooks\n    error HookAlreadyInstalled(address currentHook);\n    error InvalidHookType();\n    error EmergencyTimeLockNotExpired();\n    error EmergencyUninstallSigError();\n\n    event EmergencyHookUninstallRequest(address hook, uint256 time);\n    event EmergencyHookUninstallRequestReset(address hook, uint256 time);\n\n    // PreValidation Hooks=\n    error PreValidationHookAlreadyInstalled(address currentHook, uint256 moduleType);\n\n    // Registry Adapter\n    event ERC7484RegistryConfigured(address indexed smartAccount, IERC7484 indexed registry);\n}\n"},"src/interfaces/IERC7484.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC7484 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, uint256 moduleType) external view;\n\n    function checkForAccount(\n        address smartAccount,\n        address module,\n        uint256 moduleType\n    )\n        external\n        view;\n\n    /**\n     * Allows Smart Accounts - the end users of the registry - to appoint\n     * one or many attesters as trusted.\n     * @dev this function reverts, if address(0), or duplicates are provided in attesters[]\n     *\n     * @param threshold The minimum number of attestations required for a module\n     *                  to be considered secure.\n     * @param attesters The addresses of the attesters to be trusted.\n     */\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              Check with external attester(s)               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module, address[] calldata attesters, uint256 threshold) external view;\n\n    function check(\n        address module,\n        uint256 moduleType,\n        address[] calldata attesters,\n        uint256 threshold\n    )\n        external\n        view;\n}\n"},"src/DataTypes.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\nimport { IERC7484 } from \"./interfaces/IERC7484.sol\";\nimport { CallType } from \"./lib/ModeLib.sol\";\n\nstruct FallbackHandler {\n    address handler;\n    CallType calltype;\n}\n\nstruct ModuleInit {\n    address module;\n    bytes initData;\n    uint256 moduleType;\n}\n\nstruct RegistryInit {\n    IERC7484 registry;\n    address[] attesters;\n    uint8 threshold;\n}\n\nstruct EmergencyUninstall {\n    address hook;\n    uint256 hookType;\n    bytes deInitData;\n    uint256 nonce;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/PackedUserOperation.sol\";\nimport {calldataKeccak, min} from \"./Helpers.sol\";\n\n/**\n * Utility functions helpful when working with UserOperation structs.\n */\nlibrary UserOperationLib {\n\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\n    /**\n     * Get sender from user operation data.\n     * @param userOp - The user operation data.\n     */\n    function getSender(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {\n            data := calldataload(userOp)\n        }\n        return address(uint160(data));\n    }\n\n    /**\n     * Relayer/block builder might submit the TX with higher priorityFee,\n     * but the user should not pay above what he signed for.\n     * @param userOp - The user operation data.\n     */\n    function gasPrice(\n        PackedUserOperation calldata userOp\n    ) internal view returns (uint256) {\n        unchecked {\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    /**\n     * Pack the user operation data into bytes for hashing.\n     * @param userOp - The user operation data.\n     */\n    function encode(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes memory ret) {\n        address sender = getSender(userOp);\n        uint256 nonce = userOp.nonce;\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\n        bytes32 accountGasLimits = userOp.accountGasLimits;\n        uint256 preVerificationGas = userOp.preVerificationGas;\n        bytes32 gasFees = userOp.gasFees;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\n\n        return abi.encode(\n            sender, nonce,\n            hashInitCode, hashCallData,\n            accountGasLimits, preVerificationGas, gasFees,\n            hashPaymasterAndData\n        );\n    }\n\n    function unpackUints(\n        bytes32 packed\n    ) internal pure returns (uint256 high128, uint256 low128) {\n        return (uint128(bytes16(packed)), uint128(uint256(packed)));\n    }\n\n    //unpack just the high 128-bits from a packed value\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\n        return uint256(packed) >> 128;\n    }\n\n    // unpack just the low 128-bits from a packed value\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\n        return uint128(uint256(packed));\n    }\n\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.gasFees);\n    }\n\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.gasFees);\n    }\n\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.accountGasLimits);\n    }\n\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.accountGasLimits);\n    }\n\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\n    }\n\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\n    }\n\n    function unpackPaymasterStaticFields(\n        bytes calldata paymasterAndData\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\n        return (\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\n        );\n    }\n\n    /**\n     * Hash the user operation data.\n     * @param userOp - The user operation data.\n     */\n    function hash(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes32) {\n        return keccak256(encode(userOp));\n    }\n}\n"},"node_modules/erc7579/src/interfaces/IERC7579Module.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\n\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC1271 = 8;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC4337 = 9;\n\ninterface IModule {\n    error AlreadyInitialized(address smartAccount);\n    error NotInitialized(address smartAccount);\n\n    /**\n     * @dev This function is called by the smart account during installation of the module\n     * @param data arbitrary data that may be required on the module during `onInstall`\n     * initialization\n     *\n     * MUST revert on error (i.e. if module is already enabled)\n     */\n    function onInstall(bytes calldata data) external;\n\n    /**\n     * @dev This function is called by the smart account during uninstallation of the module\n     * @param data arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization\n     *\n     * MUST revert on error\n     */\n    function onUninstall(bytes calldata data) external;\n\n    /**\n     * @dev Returns boolean value if module is a certain type\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *\n     * MUST return true if the module is of the given type and false otherwise\n     */\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * @dev Returns if the module was already initialized for a provided smartaccount\n     */\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n\ninterface IValidator is IModule {\n    error InvalidTargetAddress(address target);\n\n    /**\n     * @dev Validates a transaction on behalf of the account.\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\n     * The MSA MUST clean up the userOp before sending it to the validator.\n     * @param userOpHash The hash of the user operation to be validated\n     * @return return value according to ERC-4337\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        returns (uint256);\n\n    /**\n     * Validator can be used for ERC-1271 validation\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IExecutor is IModule { }\n\ninterface IHook is IModule {\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        returns (bytes memory hookData);\n\n    function postCheck(bytes calldata hookData) external;\n}\n\ninterface IFallback is IModule { }\n\ninterface IPreValidationHookERC1271 is IModule {\n    function preValidationHookERC1271(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes32 hookHash, bytes memory hookSignature);\n}\n\ninterface IPreValidationHookERC4337 is IModule {\n    function preValidationHookERC4337(\n        PackedUserOperation calldata userOp,\n        uint256 missingAccountFunds,\n        bytes32 userOpHash\n    )\n        external\n        returns (bytes32 hookHash, bytes memory hookSignature);\n}\n"},"node_modules/@safe-global/safe-contracts/contracts/libraries/SafeStorage.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title SafeStorage - Storage layout of the Safe contracts to be used in libraries.\n * @dev Should be always the first base contract of a library that is used with a Safe.\n * @author Richard Meissner - @rmeissner\n */\ncontract SafeStorage {\n    // From /common/Singleton.sol\n    address internal singleton;\n    // From /common/ModuleManager.sol\n    mapping(address => address) internal modules;\n    // From /common/OwnerManager.sol\n    mapping(address => address) internal owners;\n    uint256 internal ownerCount;\n    uint256 internal threshold;\n\n    // From /Safe.sol\n    uint256 internal nonce;\n    bytes32 internal _deprecatedDomainSeparator;\n    mapping(bytes32 => uint256) internal signedMessages;\n    mapping(address => mapping(bytes32 => uint256)) internal approvedHashes;\n}\n"},"node_modules/@rhinestone/checknsignatures/src/CheckNSignatures.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { ECDSA } from \"solady/utils/ECDSA.sol\";\n\n// EIP1271 magic value\nbytes4 constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\nerror InvalidSignature();\nerror WrongContractSignatureFormat(uint256 s, uint256 contractSignatureLen, uint256 signaturesLen);\nerror WrongContractSignature(bytes contractSignature);\nerror WrongSignature(bytes signature);\n\n/**\n * @title CheckSignatures\n * @dev Library for recovering n signatures\n * @author Rhinestone\n * @notice This library is based on the Gnosis Safe signature recovery library\n */\nlibrary CheckSignatures {\n    /**\n     * Recover n signatures from a data hash\n     *\n     * @param dataHash The hash of the data\n     * @param signatures The concatenated signatures\n     * @param requiredSignatures The number of signatures required\n     *\n     * @return recoveredSigners The recovered signers\n     */\n    function recoverNSignatures(\n        bytes32 dataHash,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    )\n        internal\n        view\n        returns (address[] memory recoveredSigners)\n    {\n        uint256 signaturesLength = signatures.length;\n        uint256 totalSignatures = signaturesLength / 65;\n        recoveredSigners = new address[](totalSignatures);\n        if (totalSignatures < requiredSignatures) revert InvalidSignature();\n        uint256 validSigCount;\n        for (uint256 i; i < totalSignatures; i++) {\n            // split v,r,s from signatures\n            address _signer;\n            (uint8 v, bytes32 r, bytes32 s) = signatureSplit({ signatures: signatures, pos: i });\n\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                _signer = isValidContractSignature(dataHash, signatures, r, s, signaturesLength);\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the\n                // Ethereum message prefix before applying ecrecover\n                _signer = ECDSA.tryRecover({\n                    hash: ECDSA.toEthSignedMessageHash(dataHash),\n                    v: v - 4,\n                    r: r,\n                    s: s\n                });\n            } else {\n                _signer = ECDSA.tryRecover({ hash: dataHash, v: v, r: r, s: s });\n            }\n            if (_signer != address(0)) {\n                validSigCount++;\n            }\n            recoveredSigners[i] = _signer;\n        }\n        if (validSigCount < requiredSignatures) revert InvalidSignature();\n    }\n\n    /**\n     * @notice Validates a contract signature following the ERC-1271 standard\n     * @param dataHash Hash of the data that has been signed\n     * @param signatures The concatenated signatures\n     * @param r Signature r value\n     * @param s Signature s value\n     * @param signaturesLength The length of the signatures\n     */\n    function isValidContractSignature(\n        bytes32 dataHash,\n        bytes memory signatures,\n        bytes32 r,\n        bytes32 s,\n        uint256 signaturesLength\n    )\n        internal\n        view\n        returns (address _signer)\n    {\n        // When handling contract signatures the address of the signer contract is encoded\n        // into r\n        _signer = address(uint160(uint256(r)));\n\n        // Check if the contract signature is in bounds: start of data is s + 32 and end is\n        // start + signature length\n        uint256 contractSignatureLen;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            contractSignatureLen := mload(add(add(signatures, s), 0x20))\n        }\n\n        // Check if the contract signature is in bounds\n        if (contractSignatureLen + uint256(s) + 32 > signaturesLength) {\n            return address(0);\n        }\n\n        // Check signature\n        bytes memory contractSignature;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // The signature data for contract signatures is appended to the concatenated\n            // signatures and the offset is stored in s\n            contractSignature := add(add(signatures, s), 0x20)\n        }\n        if (\n            ISignatureValidator(_signer).isValidSignature(dataHash, contractSignature)\n                != EIP1271_MAGIC_VALUE\n        ) return address(0);\n    }\n\n    /**\n     * @notice Splits signature bytes into `uint8 v, bytes32 r, bytes32 s`.\n     * @dev Make sure to perform a bounds check for @param pos, to avoid out of bounds access on\n     * @param signatures The signature format is a compact form of {bytes32 r}{bytes32 s}{uint8 v}\n     * Compact means uint8 is not padded to 32 bytes.\n     * @param pos Which signature to read. A prior bounds check of this parameter should be\n     * performed, to avoid out of bounds access.\n     * @param signatures Concatenated {r, s, v} signatures.\n     * @return v Recovery ID or Safe signature type.\n     * @return r Output value r of the signature.\n     * @return s Output value s of the signature.\n     *\n     * @ author Gnosis Team /rmeissner\n     */\n    function signatureSplit(\n        bytes memory signatures,\n        uint256 pos\n    )\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            v := byte(0, mload(add(signatures, add(signaturePos, 0x60))))\n        }\n    }\n}\n\nabstract contract ISignatureValidator {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _dataHash Arbitrary length data signed on behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(\n        bytes32 _dataHash,\n        bytes memory _signature\n    )\n        public\n        view\n        virtual\n        returns (bytes4);\n}\n"},"node_modules/solady/src/utils/LibSort.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Optimized sorts and operations for sorted arrays.\n/// @author Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibSort.sol)\nlibrary LibSort {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      INSERTION SORT                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // - Faster on small arrays (32 or lesser elements).\n    // - Faster on almost sorted arrays.\n    // - Smaller bytecode (about 300 bytes smaller than sort, which uses intro-quicksort).\n    // - May be suitable for view functions intended for off-chain querying.\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a) // Length of `a`.\n            mstore(a, 0) // For insertion sort's inner loop to terminate.\n            let h := add(a, shl(5, n)) // High slot.\n            let w := not(0x1f)\n            for { let i := add(a, 0x20) } 1 {} {\n                i := add(i, 0x20)\n                if gt(i, h) { break }\n                let k := mload(i) // Key.\n                let j := add(i, w) // The slot before the current slot.\n                let v := mload(j) // The value of `j`.\n                if iszero(gt(v, k)) { continue }\n                for {} 1 {} {\n                    mstore(add(j, 0x20), v)\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    v := mload(j)\n                    if iszero(gt(v, k)) { break }\n                }\n                mstore(add(j, 0x20), k)\n            }\n            mstore(a, n) // Restore the length of `a`.\n        }\n    }\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(int256[] memory a) internal pure {\n        _flipSign(a);\n        insertionSort(_toUints(a));\n        _flipSign(a);\n    }\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(address[] memory a) internal pure {\n        insertionSort(_toUints(a));\n    }\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(bytes32[] memory a) internal pure {\n        insertionSort(_toUints(a));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      INTRO-QUICKSORT                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // - Faster on larger arrays (more than 32 elements).\n    // - Robust performance.\n    // - Larger bytecode.\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function swap(a_, b_) -> _a, _b {\n                _b := a_\n                _a := b_\n            }\n            function mswap(i_, j_) {\n                let t_ := mload(i_)\n                mstore(i_, mload(j_))\n                mstore(j_, t_)\n            }\n            function sortInner(w_, l_, h_) {\n                // Do insertion sort if `h_ - l_ <= 0x20 * 12`.\n                // Threshold is fine-tuned via trial and error.\n                if iszero(gt(sub(h_, l_), 0x180)) {\n                    // Hardcode sort the first 2 elements.\n                    let i_ := add(l_, 0x20)\n                    if iszero(lt(mload(l_), mload(i_))) { mswap(i_, l_) }\n                    for {} 1 {} {\n                        i_ := add(i_, 0x20)\n                        if gt(i_, h_) { break }\n                        let k_ := mload(i_) // Key.\n                        let j_ := add(i_, w_) // The slot before the current slot.\n                        let v_ := mload(j_) // The value of `j_`.\n                        if iszero(gt(v_, k_)) { continue }\n                        for {} 1 {} {\n                            mstore(add(j_, 0x20), v_)\n                            j_ := add(j_, w_)\n                            v_ := mload(j_)\n                            if iszero(gt(v_, k_)) { break }\n                        }\n                        mstore(add(j_, 0x20), k_)\n                    }\n                    leave\n                }\n                // Pivot slot is the average of `l_` and `h_`.\n                let p_ := add(shl(5, shr(6, add(l_, h_))), and(31, l_))\n                // Median of 3 with sorting.\n                {\n                    let e0_ := mload(l_)\n                    let e1_ := mload(p_)\n                    if iszero(lt(e0_, e1_)) { e0_, e1_ := swap(e0_, e1_) }\n                    let e2_ := mload(h_)\n                    if iszero(lt(e1_, e2_)) {\n                        e1_, e2_ := swap(e1_, e2_)\n                        if iszero(lt(e0_, e1_)) { e0_, e1_ := swap(e0_, e1_) }\n                    }\n                    mstore(h_, e2_)\n                    mstore(p_, e1_)\n                    mstore(l_, e0_)\n                }\n                // Hoare's partition.\n                {\n                    // The value of the pivot slot.\n                    let x_ := mload(p_)\n                    p_ := h_\n                    for { let i_ := l_ } 1 {} {\n                        for {} 1 {} {\n                            i_ := add(0x20, i_)\n                            if iszero(gt(x_, mload(i_))) { break }\n                        }\n                        let j_ := p_\n                        for {} 1 {} {\n                            j_ := add(w_, j_)\n                            if iszero(lt(x_, mload(j_))) { break }\n                        }\n                        p_ := j_\n                        if iszero(lt(i_, p_)) { break }\n                        mswap(i_, p_)\n                    }\n                }\n                if iszero(eq(add(p_, 0x20), h_)) { sortInner(w_, add(p_, 0x20), h_) }\n                if iszero(eq(p_, l_)) { sortInner(w_, l_, p_) }\n            }\n\n            for { let n := mload(a) } iszero(lt(n, 2)) {} {\n                let w := not(0x1f) // `-0x20`.\n                let l := add(a, 0x20) // Low slot.\n                let h := add(a, shl(5, n)) // High slot.\n                let j := h\n                // While `mload(j - 0x20) <= mload(j): j -= 0x20`.\n                for {} iszero(gt(mload(add(w, j)), mload(j))) {} { j := add(w, j) }\n                // If the array is already sorted, break.\n                if iszero(gt(j, l)) { break }\n                // While `mload(j - 0x20) >= mload(j): j -= 0x20`.\n                for { j := h } iszero(lt(mload(add(w, j)), mload(j))) {} { j := add(w, j) }\n                // If the array is reversed sorted.\n                if iszero(gt(j, l)) {\n                    for {} 1 {} {\n                        let t := mload(l)\n                        mstore(l, mload(h))\n                        mstore(h, t)\n                        h := add(w, h)\n                        l := add(l, 0x20)\n                        if iszero(lt(l, h)) { break }\n                    }\n                    break\n                }\n                mstore(a, 0) // For insertion sort's inner loop to terminate.\n                sortInner(w, l, h)\n                mstore(a, n) // Restore the length of `a`.\n                break\n            }\n        }\n    }\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(int256[] memory a) internal pure {\n        _flipSign(a);\n        sort(_toUints(a));\n        _flipSign(a);\n    }\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(address[] memory a) internal pure {\n        sort(_toUints(a));\n    }\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(bytes32[] memory a) internal pure {\n        sort(_toUints(a));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  OTHER USEFUL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance, the `uniquifySorted` methods will not revert if the\n    // array is not sorted -- it will simply remove consecutive duplicate elements.\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the length of `a` is greater than 1.\n            if iszero(lt(mload(a), 2)) {\n                let x := add(a, 0x20)\n                let y := add(a, 0x40)\n                let end := add(a, shl(5, add(mload(a), 1)))\n                for {} 1 {} {\n                    if iszero(eq(mload(x), mload(y))) {\n                        x := add(x, 0x20)\n                        mstore(x, mload(y))\n                    }\n                    y := add(y, 0x20)\n                    if eq(y, end) { break }\n                }\n                mstore(a, shr(5, sub(x, a)))\n            }\n        }\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(int256[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(address[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(bytes32[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(uint256[] memory a, uint256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(a, needle, 0);\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(int256[] memory a, int256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(needle), 1 << 255);\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(address[] memory a, address needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint160(needle), 0);\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(bytes32[] memory a, bytes32 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(needle), 0);\n    }\n\n    /// @dev Returns whether `a` contains `needle`.\n    function inSorted(uint256[] memory a, uint256 needle) internal pure returns (bool found) {\n        (found,) = searchSorted(a, needle);\n    }\n\n    /// @dev Returns whether `a` contains `needle`.\n    function inSorted(int256[] memory a, int256 needle) internal pure returns (bool found) {\n        (found,) = searchSorted(a, needle);\n    }\n\n    /// @dev Returns whether `a` contains `needle`.\n    function inSorted(address[] memory a, address needle) internal pure returns (bool found) {\n        (found,) = searchSorted(a, needle);\n    }\n\n    /// @dev Returns whether `a` contains `needle`.\n    function inSorted(bytes32[] memory a, bytes32 needle) internal pure returns (bool found) {\n        (found,) = searchSorted(a, needle);\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(mload(a), 2)) {\n                let s := 0x20\n                let w := not(0x1f)\n                let h := add(a, shl(5, mload(a)))\n                for { a := add(a, s) } 1 {} {\n                    let t := mload(a)\n                    mstore(a, mload(h))\n                    mstore(h, t)\n                    h := add(h, w)\n                    a := add(a, s)\n                    if iszero(lt(a, h)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(int256[] memory a) internal pure {\n        reverse(_toUints(a));\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(address[] memory a) internal pure {\n        reverse(_toUints(a));\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(bytes32[] memory a) internal pure {\n        reverse(_toUints(a));\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(add(result, 0x20), shl(5, mload(a)))\n            let o := result\n            for { let d := sub(a, result) } 1 {} {\n                mstore(o, mload(add(o, d)))\n                o := add(0x20, o)\n                if eq(o, end) { break }\n            }\n            mstore(0x40, o)\n        }\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(int256[] memory a) internal pure returns (int256[] memory result) {\n        result = _toInts(copy(_toUints(a)));\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(address[] memory a) internal pure returns (address[] memory result) {\n        result = _toAddresses(copy(_toUints(a)));\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(bytes32[] memory a) internal pure returns (bytes32[] memory result) {\n        result = _toBytes32s(copy(_toUints(a)));\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(gt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(sgt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(address[] memory a) internal pure returns (bool result) {\n        result = isSorted(_toUints(a));\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(bytes32[] memory a) internal pure returns (bool result) {\n        result = isSorted(_toUints(a));\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := lt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := slt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(address[] memory a) internal pure returns (bool result) {\n        result = isSortedAndUniquified(_toUints(a));\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(bytes32[] memory a) internal pure returns (bool result) {\n        result = isSortedAndUniquified(_toUints(a));\n    }\n\n    /// @dev Returns the sorted set difference of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _difference(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set difference between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_difference(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set difference between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_difference(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set difference between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(bytes32[] memory a, bytes32[] memory b)\n        internal\n        pure\n        returns (bytes32[] memory c)\n    {\n        c = _toBytes32s(_difference(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _intersection(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_intersection(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_intersection(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(bytes32[] memory a, bytes32[] memory b)\n        internal\n        pure\n        returns (bytes32[] memory c)\n    {\n        c = _toBytes32s(_intersection(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _union(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_union(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set union between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_union(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set union between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(bytes32[] memory a, bytes32[] memory b)\n        internal\n        pure\n        returns (bytes32[] memory c)\n    {\n        c = _toBytes32s(_union(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Cleans the upper 96 bits of the addresses.\n    /// In case `a` is produced via assembly and might have dirty upper bits.\n    function clean(address[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let addressMask := shr(96, not(0))\n            for { let end := add(a, shl(5, mload(a))) } iszero(eq(a, end)) {} {\n                a := add(a, 0x20)\n                mstore(a, and(mload(a), addressMask))\n            }\n        }\n    }\n\n    /// @dev Sorts and uniquifies `keys`. Updates `values` with the grouped sums by key.\n    function groupSum(uint256[] memory keys, uint256[] memory values) internal pure {\n        uint256 m;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m := mload(0x40) // Cache the free memory pointer, for freeing the memory.\n            if iszero(eq(mload(keys), mload(values))) {\n                mstore(0x00, 0x4e487b71)\n                mstore(0x20, 0x32) // Array out of bounds panic if the arrays lengths differ.\n                revert(0x1c, 0x24)\n            }\n        }\n        if (keys.length == uint256(0)) return;\n        (uint256[] memory oriKeys, uint256[] memory oriValues) = (copy(keys), copy(values));\n        insertionSort(keys); // Optimize for small `n` and bytecode size.\n        uniquifySorted(keys);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let d := sub(values, keys)\n            let w := not(0x1f)\n            let s := add(keys, 0x20) // Location of `keys[0]`.\n            mstore(values, mload(keys)) // Truncate.\n            calldatacopy(add(s, d), calldatasize(), shl(5, mload(keys))) // Zeroize.\n            for { let i := shl(5, mload(oriKeys)) } 1 {} {\n                let k := mload(add(oriKeys, i))\n                let v := mload(add(oriValues, i))\n                let j := s // Just do a linear scan to optimize for small `n` and bytecode size.\n                for {} iszero(eq(mload(j), k)) {} { j := add(j, 0x20) }\n                j := add(j, d) // Convert `j` to point into `values`.\n                mstore(j, add(mload(j), v))\n                if lt(mload(j), v) {\n                    mstore(0x00, 0x4e487b71)\n                    mstore(0x20, 0x11) // Overflow panic if the addition overflows.\n                    revert(0x1c, 0x24)\n                }\n                i := add(i, w) // `sub(i, 0x20)`.\n                if iszero(i) { break }\n            }\n            mstore(0x40, m) // Frees the memory allocated for the temporary copies.\n        }\n    }\n\n    /// @dev Sorts and uniquifies `keys`. Updates `values` with the grouped sums by key.\n    function groupSum(address[] memory keys, uint256[] memory values) internal pure {\n        groupSum(_toUints(keys), values);\n    }\n\n    /// @dev Sorts and uniquifies `keys`. Updates `values` with the grouped sums by key.\n    function groupSum(bytes32[] memory keys, uint256[] memory values) internal pure {\n        groupSum(_toUints(keys), values);\n    }\n\n    /// @dev Sorts and uniquifies `keys`. Updates `values` with the grouped sums by key.\n    function groupSum(int256[] memory keys, uint256[] memory values) internal pure {\n        groupSum(_toUints(keys), values);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Reinterpret cast to an uint256 array.\n    function _toUints(int256[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an uint256 array.\n    function _toUints(address[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // As any address written to memory will have the upper 96 bits\n            // of the word zeroized (as per Solidity spec), we can directly\n            // compare these addresses as if they are whole uint256 words.\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an uint256 array.\n    function _toUints(bytes32[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an int array.\n    function _toInts(uint256[] memory a) private pure returns (int256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an address array.\n    function _toAddresses(uint256[] memory a) private pure returns (address[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an bytes32 array.\n    function _toBytes32s(uint256[] memory a) private pure returns (bytes32[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Converts an array of signed integers to unsigned\n    /// integers suitable for sorting or vice versa.\n    function _flipSign(int256[] memory a) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := shl(255, 1)\n            for { let end := add(a, shl(5, mload(a))) } iszero(eq(a, end)) {} {\n                a := add(a, 0x20)\n                mstore(a, add(mload(a), w))\n            }\n        }\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function _searchSorted(uint256[] memory a, uint256 needle, uint256 signed)\n        private\n        pure\n        returns (bool found, uint256 index)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0)\n            let l := 1\n            let h := mload(a)\n            let t := 0\n            for { needle := add(signed, needle) } 1 {} {\n                index := shr(1, add(l, h))\n                t := add(signed, mload(add(a, shl(5, index))))\n                if or(gt(l, h), eq(t, needle)) { break }\n                // Decide whether to search the left or right half.\n                if iszero(gt(needle, t)) {\n                    h := add(index, w)\n                    continue\n                }\n                l := add(index, 1)\n            }\n            // `index` will be zero in the case of an empty array,\n            // or when the value is less than the smallest value in the array.\n            found := eq(t, needle)\n            t := iszero(iszero(index))\n            index := mul(add(index, w), t)\n            found := and(found, t)\n        }\n    }\n\n    /// @dev Returns the sorted set difference of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _difference(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _intersection(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _union(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    k := add(k, s)\n                    mstore(k, v)\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            for {} iszero(gt(b, bEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(b))\n                b := add(b, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n}\n"},"src/core/SupportViewer.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport {\n    CallType,\n    ExecType,\n    ModeCode,\n    EXECTYPE_DEFAULT,\n    EXECTYPE_TRY,\n    CALLTYPE_SINGLE,\n    CALLTYPE_BATCH,\n    CALLTYPE_DELEGATECALL\n} from \"../lib/ModeLib.sol\";\nimport {\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_HOOK,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_FALLBACK\n} from \"erc7579/interfaces/IERC7579Module.sol\";\nimport { IERC7579AccountView } from \"../interfaces/IERC7579Account.sol\";\n\nabstract contract SupportViewer is IERC7579AccountView {\n    function accountId() external pure returns (string memory accountImplementationId) {\n        return \"rhinestone.safe7579.v1.0.0\";\n    }\n\n    function supportsExecutionMode(ModeCode encodedMode) external pure returns (bool supported) {\n        CallType callType;\n        ExecType execType;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            callType := encodedMode\n            execType := shl(8, encodedMode)\n        }\n        if (callType == CALLTYPE_BATCH) supported = true;\n        else if (callType == CALLTYPE_SINGLE) supported = true;\n        else if (callType == CALLTYPE_DELEGATECALL) supported = true;\n        else return false;\n\n        if (supported && execType == EXECTYPE_DEFAULT) return supported;\n        else if (supported && execType == EXECTYPE_TRY) return supported;\n        else return false;\n    }\n\n    function supportsModule(uint256 moduleTypeId) external pure returns (bool) {\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) return true;\n        else if (moduleTypeId == MODULE_TYPE_EXECUTOR) return true;\n        else if (moduleTypeId == MODULE_TYPE_FALLBACK) return true;\n        else if (moduleTypeId == MODULE_TYPE_HOOK) return true;\n        else return false;\n    }\n}\n"},"src/interfaces/IERC7579Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { CallType, ExecType, ModeCode } from \"../lib/ModeLib.sol\";\n\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n\ninterface IERC7579AccountEvents {\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n}\n\ninterface IERC7579AccountView {\n    /**\n     * @dev Returns the account id of the smart account\n     * @return accountImplementationId the account id of the smart account\n     * the accountId should be structured like so:\n     *        \"vendorname.accountname.semver\"\n     */\n    function accountId() external view returns (string memory accountImplementationId);\n\n    /**\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\n     * @param encodedMode the encoded mode\n     */\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\n\n    /**\n     * Function to check if the account supports installation of a certain module type Id\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     */\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\n}\n\ninterface IERC7579Account is IERC7579AccountEvents, IERC7579AccountView {\n    // Error thrown when an unsupported ModuleType is requested\n    error UnsupportedModuleType(uint256 moduleTypeId);\n    // Error thrown when an execution with an unsupported CallType was made\n    error UnsupportedCallType(CallType callType);\n    // Error thrown when an execution with an unsupported ExecType was made\n    error UnsupportedExecType(ExecType execType);\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n\n    function execute(ModeCode mode, bytes calldata executionCalldata) external;\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by Executor Modules\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        returns (bytes[] memory returnData);\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(bytes32 hash, bytes calldata data) external returns (bytes4);\n\n    /**\n     * @dev installs a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external;\n\n    /**\n     * @dev uninstalls a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external;\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool);\n}\n"},"node_modules/solady/src/utils/LibBytes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for byte related operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBytes.sol)\nlibrary LibBytes {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Goated bytes storage struct that totally MOGs, no cap, fr.\n    /// Uses less gas and bytecode than Solidity's native bytes storage. It's meta af.\n    /// Packs length with the first 31 bytes if <255 bytes, so it’s mad tight.\n    struct BytesStorage {\n        bytes32 _spacer;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the bytes.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  BYTE STORAGE OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function set(BytesStorage storage $, bytes memory s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let packed := or(0xff, shl(8, n))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(n, 0xfe)) {\n                    i := 0x1f\n                    packed := or(n, shl(8, mload(add(s, i))))\n                    if iszero(gt(n, i)) { break }\n                }\n                let o := add(s, 0x20)\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), mload(add(o, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function setCalldata(BytesStorage storage $, bytes calldata s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := or(0xff, shl(8, s.length))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(s.length, 0xfe)) {\n                    i := 0x1f\n                    packed := or(s.length, shl(8, shr(8, calldataload(s.offset))))\n                    if iszero(gt(s.length, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), calldataload(add(s.offset, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, s.length)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to the empty bytes.\n    function clear(BytesStorage storage $) internal {\n        delete $._spacer;\n    }\n\n    /// @dev Returns whether the value stored is `$` is the empty bytes \"\".\n    function isEmpty(BytesStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }\n\n    /// @dev Returns the length of the value stored in `$`.\n    function length(BytesStorage storage $) internal view returns (uint256 result) {\n        result = uint256($._spacer);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := and(0xff, result)\n            result := or(mul(shr(8, result), eq(0xff, n)), mul(n, iszero(eq(0xff, n))))\n        }\n    }\n\n    /// @dev Returns the value stored in `$`.\n    function get(BytesStorage storage $) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let packed := sload($.slot)\n            let n := shr(8, packed)\n            for { let i := 0 } 1 {} {\n                if iszero(eq(or(packed, 0xff), packed)) {\n                    mstore(o, packed)\n                    n := and(0xff, packed)\n                    i := 0x1f\n                    if iszero(gt(n, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    mstore(add(o, i), sload(add(p, shr(5, i))))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            mstore(result, n) // Store the length of the memory.\n            mstore(add(o, n), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      BYTES OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\n    function replace(bytes memory subject, bytes memory needle, bytes memory replacement)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let needleLen := mload(needle)\n            let replacementLen := mload(replacement)\n            let d := sub(result, subject) // Memory difference.\n            let i := add(subject, 0x20) // Subject bytes pointer.\n            mstore(0x00, add(i, mload(subject))) // End of subject.\n            if iszero(gt(needleLen, mload(subject))) {\n                let subjectSearchEnd := add(sub(mload(0x00), needleLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(needleLen, 0x20)) { h := keccak256(add(needle, 0x20), needleLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(needleLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `needleLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, needleLen), h)) {\n                                mstore(add(i, d), t)\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let j := 0 } 1 {} {\n                            mstore(add(add(i, d), j), mload(add(add(replacement, 0x20), j)))\n                            j := add(j, 0x20)\n                            if iszero(lt(j, replacementLen)) { break }\n                        }\n                        d := sub(add(d, replacementLen), needleLen)\n                        if needleLen {\n                            i := add(i, needleLen)\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(add(i, d), t)\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n            }\n            let end := mload(0x00)\n            let n := add(sub(d, add(result, 0x20)), end)\n            // Copy the rest of the bytes one word at a time.\n            for {} lt(i, end) { i := add(i, 0x20) } { mstore(add(i, d), mload(i)) }\n            let o := add(i, d)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0) // Initialize to `NOT_FOUND`.\n            for { let subjectLen := mload(subject) } 1 {} {\n                if iszero(mload(needle)) {\n                    result := from\n                    if iszero(gt(from, subjectLen)) { break }\n                    result := subjectLen\n                    break\n                }\n                let needleLen := mload(needle)\n                let subjectStart := add(subject, 0x20)\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLen), needleLen), 1)\n                let m := shl(3, sub(0x20, and(needleLen, 0x1f)))\n                let s := mload(add(needle, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLen))) { break }\n\n                if iszero(lt(needleLen, 0x20)) {\n                    for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, needleLen), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle) internal pure returns (uint256) {\n        return indexOf(subject, needle, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let needleLen := mload(needle)\n                if gt(needleLen, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), needleLen)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                    if eq(keccak256(subject, needleLen), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(subject, needle, type(uint256).max);\n    }\n\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\n    function contains(bytes memory subject, bytes memory needle) internal pure returns (bool) {\n        return indexOf(subject, needle) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `needle`.\n    function startsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            // Just using keccak256 directly is actually cheaper.\n            let t := eq(keccak256(add(subject, 0x20), n), keccak256(add(needle, 0x20), n))\n            result := lt(gt(n, mload(subject)), t)\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `needle`.\n    function endsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            let notInRange := gt(n, mload(subject))\n            // `subject + 0x20 + max(subject.length - needle.length, 0)`.\n            let t := add(add(subject, 0x20), mul(iszero(notInRange), sub(mload(subject), n)))\n            // Just using keccak256 directly is actually cheaper.\n            result := gt(eq(keccak256(t, n), keccak256(add(needle, 0x20), n)), notInRange)\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(bytes memory subject, uint256 times)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(or(iszero(times), iszero(l))) {\n                result := mload(0x40)\n                subject := add(subject, 0x20)\n                let o := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let j := 0 } 1 {} {\n                        mstore(add(o, j), mload(add(subject, j)))\n                        j := add(j, 0x20)\n                        if iszero(lt(j, l)) { break }\n                    }\n                    o := add(o, l)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(bytes memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(gt(l, end)) { end := l }\n            if iszero(gt(l, start)) { start := l }\n            if lt(start, end) {\n                result := mload(0x40)\n                let n := sub(end, start)\n                let i := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let j := and(add(n, 0x1f), w) } 1 {} {\n                    mstore(add(result, j), mload(add(i, j)))\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    if iszero(j) { break }\n                }\n                let o := add(add(result, 0x20), n)\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, n) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\n    /// `start` is a byte offset.\n    function slice(bytes memory subject, uint256 start)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        result = slice(subject, start, type(uint256).max);\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets. Faster than Solidity's native slicing.\n    function sliceCalldata(bytes calldata subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, subject.length), lt(subject.length, end)))\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, end), sub(end, start))\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\n    /// `start` is a byte offset. Faster than Solidity's native slicing.\n    function sliceCalldata(bytes calldata subject, uint256 start)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, subject.length), sub(subject.length, start))\n        }\n    }\n\n    /// @dev Reduces the size of `subject` to `n`.\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\n    function truncate(bytes memory subject, uint256 n)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := subject\n            mstore(mul(lt(n, mload(result)), result), n)\n        }\n    }\n\n    /// @dev Returns a copy of `subject`, with the length reduced to `n`.\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\n    function truncatedCalldata(bytes calldata subject, uint256 n)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.offset := subject.offset\n            result.length := xor(n, mul(xor(n, subject.length), lt(subject.length, n)))\n        }\n    }\n\n    /// @dev Returns all the indices of `needle` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLen := mload(needle)\n            if iszero(gt(searchLen, mload(subject))) {\n                result := mload(0x40)\n                let i := add(subject, 0x20)\n                let o := add(result, 0x20)\n                let subjectSearchEnd := add(sub(add(i, mload(subject)), searchLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(searchLen, 0x20)) { h := keccak256(add(needle, 0x20), searchLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(searchLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `searchLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, searchLen), h)) {\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        mstore(o, sub(i, add(subject, 0x20))) // Append to `result`.\n                        o := add(o, 0x20)\n                        i := add(i, searchLen) // Advance `i` by `searchLen`.\n                        if searchLen {\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n                mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store the length of `result`.\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(o, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of bytess based on the `delimiter` inside of the `subject` bytes.\n    function split(bytes memory subject, bytes memory delimiter)\n        internal\n        pure\n        returns (bytes[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            for { let prevIndex := 0 } 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let l := sub(index, prevIndex)\n                    mstore(element, l) // Store the length of the element.\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(l, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    mstore(add(add(element, 0x20), l), 0) // Zeroize the slot after the bytes.\n                    // Allocate memory for the length and the bytes, rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(l, 0x3f), w)))\n                    mstore(indexPtr, element) // Store the `element` into the array.\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated bytes of `a` and `b`.\n    /// Cheaper than `bytes.concat()` and does not de-align the free memory pointer.\n    function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let w := not(0x1f)\n            let aLen := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLen, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLen := mload(b)\n            let output := add(result, aLen)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLen, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLen := add(aLen, bLen)\n            let last := add(add(result, 0x20), totalLen)\n            mstore(last, 0) // Zeroize the slot after the bytes.\n            mstore(result, totalLen) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(bytes memory a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small bytes.\n    function eqs(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Returns 0 if `a == b`, -1 if `a < b`, +1 if `a > b`.\n    /// If `a` == b[:a.length]`, and `a.length < b.length`, returns -1.\n    function cmp(bytes memory a, bytes memory b) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            let bLen := mload(b)\n            let n := and(xor(aLen, mul(xor(aLen, bLen), lt(bLen, aLen))), not(0x1f))\n            if n {\n                for { let i := 0x20 } 1 {} {\n                    let x := mload(add(a, i))\n                    let y := mload(add(b, i))\n                    if iszero(or(xor(x, y), eq(i, n))) {\n                        i := add(i, 0x20)\n                        continue\n                    }\n                    result := sub(gt(x, y), lt(x, y))\n                    break\n                }\n            }\n            // forgefmt: disable-next-item\n            if iszero(result) {\n                let l := 0x201f1e1d1c1b1a191817161514131211100f0e0d0c0b0a090807060504030201\n                let x := and(mload(add(add(a, 0x20), n)), shl(shl(3, byte(sub(aLen, n), l)), not(0)))\n                let y := and(mload(add(add(b, 0x20), n)), shl(shl(3, byte(sub(bLen, n), l)), not(0)))\n                result := sub(gt(x, y), lt(x, y))\n                if iszero(result) { result := sub(gt(aLen, bLen), lt(aLen, bLen)) }\n            }\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(bytes memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Assumes that the bytes does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the bytes is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the bytes.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n\n    /// @dev Directly returns `a` with minimal copying.\n    function directReturn(bytes[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a) // `a.length`.\n            let o := add(a, 0x20) // Start of elements in `a`.\n            let u := a // Highest memory slot.\n            let w := not(0x1f)\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                let c := add(o, shl(5, i)) // Location of pointer to `a[i]`.\n                let s := mload(c) // `a[i]`.\n                let l := mload(s) // `a[i].length`.\n                let r := and(l, 0x1f) // `a[i].length % 32`.\n                let z := add(0x20, and(l, w)) // Offset of last word in `a[i]` from `s`.\n                // If `s` comes before `o`, or `s` is not zero right padded.\n                if iszero(lt(lt(s, o), or(iszero(r), iszero(shl(shl(3, r), mload(add(s, z))))))) {\n                    let m := mload(0x40)\n                    mstore(m, l) // Copy `a[i].length`.\n                    for {} 1 {} {\n                        mstore(add(m, z), mload(add(s, z))) // Copy `a[i]`, backwards.\n                        z := add(z, w) // `sub(z, 0x20)`.\n                        if iszero(z) { break }\n                    }\n                    let e := add(add(m, 0x20), l)\n                    mstore(e, 0) // Zeroize the slot after the copied bytes.\n                    mstore(0x40, add(e, 0x20)) // Allocate memory.\n                    s := m\n                }\n                mstore(c, sub(s, o)) // Convert to calldata offset.\n                let t := add(l, add(s, 0x20))\n                if iszero(lt(t, u)) { u := t }\n            }\n            let retStart := add(a, w) // Assumes `a` doesn't start from scratch space.\n            mstore(retStart, 0x20) // Store the return offset.\n            return(retStart, add(0x40, sub(u, retStart))) // End the transaction.\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    function load(bytes memory a, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), offset))\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    function loadCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := calldataload(add(a.offset, offset))\n        }\n    }\n\n    /// @dev Returns a slice representing a static struct in the calldata. Performs bounds checks.\n    function staticStructInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            result.offset := add(a.offset, offset)\n            result.length := sub(a.length, offset)\n            if or(shr(64, or(l, a.offset)), gt(offset, l)) { revert(l, 0x00) }\n        }\n    }\n\n    /// @dev Returns a slice representing a dynamic struct in the calldata. Performs bounds checks.\n    function dynamicStructInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.\n            result.offset := add(a.offset, s)\n            result.length := sub(a.length, s)\n            if or(shr(64, or(s, or(l, a.offset))), gt(offset, l)) { revert(l, 0x00) }\n        }\n    }\n\n    /// @dev Returns bytes in calldata. Performs bounds checks.\n    function bytesInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.\n            result.offset := add(add(a.offset, s), 0x20)\n            result.length := calldataload(add(a.offset, s))\n            // forgefmt: disable-next-item\n            if or(shr(64, or(result.length, or(s, or(l, a.offset)))),\n                or(gt(add(s, result.length), l), gt(offset, l))) { revert(l, 0x00) }\n        }\n    }\n\n    /// @dev Returns empty calldata bytes. For silencing the compiler.\n    function emptyCalldata() internal pure returns (bytes calldata result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.length := 0\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"src/lib/ModeLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title ModeLib\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n * encoding is used.\n *    Function Signature of execute function:\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n * context.\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n * implement\n * more complex execution modes may use the entire bytes32.\n *\n * |--------------------------------------------------------------------|\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n * |--------------------------------------------------------------------|\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n * |--------------------------------------------------------------------|\n *\n * CALLTYPE: 1 byte\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\n * decoded.\n * It can be either single, batch or delegatecall. In the future different calls could be added.\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n *\n * EXECTYPE: 1 byte\n * ExecType is used to determine how the account should handle the execution.\n * It can indicate if the execution should revert on failure or continue execution.\n * In the future more execution modes may be added.\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n * a batch fails, the entire batch is reverted\n *\n * UNUSED: 4 bytes\n * Unused bytes are reserved for future use.\n *\n * ModeSelector: bytes4\n * The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n * their accounts.\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n * this is to prevent collisions between different vendors, while allowing innovation and the\n * development of new features without coordination between ERC-7579 implementing accounts\n *\n * ModePayload: 22 bytes\n * Mode payload is used to pass additional data to the smart account execution, this may be\n * interpreted depending on the ModeSelector\n *\n * ExecutionCallData: n bytes\n * single, delegatecall or batch exec abi.encoded as bytes\n */\n\n// Custom type for improved developer experience\ntype ModeCode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/**\n * @dev ModeLib is a helper library to encode/decode ModeCodes\n */\nlibrary ModeLib {\n    function decode(ModeCode mode)\n        internal\n        pure\n        returns (\n            CallType _calltype,\n            ExecType _execType,\n            ModeSelector _modeSelector,\n            ModePayload _modePayload\n        )\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function encode(\n        CallType callType,\n        ExecType execType,\n        ModeSelector mode,\n        ModePayload payload\n    )\n        internal\n        pure\n        returns (ModeCode)\n    {\n        return ModeCode.wrap(\n            bytes32(\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\n            )\n        );\n    }\n\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { eqModeSelector as == } for ModeSelector global;\nusing { eqCallType as == } for CallType global;\nusing { neqCallType as != } for CallType global;\nusing { eqExecType as == } for ExecType global;\n\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction neqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) != CallType.unwrap(b);\n}\n\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n"},"node_modules/solady/src/utils/ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized ECDSA wrapper.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\n///\n/// @dev Note:\n/// - The recovery functions use the ecrecover precompile (0x1).\n/// - As of Solady version 0.0.68, the `recover` variants will revert upon recovery failure.\n///   This is for more safety by default.\n///   Use the `tryRecover` variants if you need to get the zero address back\n///   upon recovery failure instead.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT directly use signatures as unique identifiers:\n/// - The recovery operations do NOT check if a signature is non-malleable.\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// - If you need a unique hash from a signature, please use the `canonicalHash` functions.\nlibrary ECDSA {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The order of the secp256k1 elliptic curve.\n    uint256 internal constant N = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141;\n\n    /// @dev `N/2 + 1`. Used for checking the malleability of the signature.\n    uint256 private constant _HALF_N_PLUS_1 =\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The signature is invalid.\n    error InvalidSignature();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    RECOVERY OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            } {\n                switch mload(signature)\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { continue }\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if returndatasize() { break }\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            } {\n                switch signature.length\n                case 64 {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                }\n                default { continue }\n                mstore(0x00, hash)\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if returndatasize() { break }\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   TRY-RECOVER OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // WARNING!\n    // These functions will NOT revert upon recovery failure.\n    // Instead, they will return the zero address upon recovery failure.\n    // It is critical that the returned address is NEVER compared against\n    // a zero address (e.g. an uninitialized address variable).\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {} {\n                switch mload(signature)\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(xor(0x60, returndatasize()))\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {} {\n                switch signature.length\n                case 64 {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(xor(0x60, returndatasize()))\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CANONICAL HASH FUNCTIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // The following functions returns the hash of the signature in it's canonicalized format,\n    // which is the 65-byte `abi.encodePacked(r, s, uint8(v))`, where `v` is either 27 or 28.\n    // If `s` is greater than `N / 2` then it will be converted to `N - s`\n    // and the `v` value will be flipped.\n    // If the signature has an invalid length, or if `v` is invalid,\n    // a uniquely corrupt hash will be returned.\n    // These functions are useful for \"poor-mans-VRF\".\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHash(bytes memory signature) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(signature)\n            for {} 1 {} {\n                mstore(0x00, mload(add(signature, 0x20))) // `r`.\n                let s := mload(add(signature, 0x40))\n                let v := mload(add(signature, 0x41))\n                if eq(l, 64) {\n                    v := add(shr(255, s), 27)\n                    s := shr(1, shl(1, s))\n                }\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\n                    v := xor(v, 7)\n                    s := sub(N, s)\n                }\n                mstore(0x21, v)\n                mstore(0x20, s)\n                result := keccak256(0x00, 0x41)\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n                break\n            }\n\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\n            if iszero(lt(sub(l, 64), 2)) {\n                // `bytes4(keccak256(\"InvalidSignatureLength\"))`.\n                result := xor(keccak256(add(signature, 0x20), l), 0xd62f1ab2)\n            }\n        }\n    }\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHashCalldata(bytes calldata signature)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                mstore(0x00, calldataload(signature.offset)) // `r`.\n                let s := calldataload(add(signature.offset, 0x20))\n                let v := calldataload(add(signature.offset, 0x21))\n                if eq(signature.length, 64) {\n                    v := add(shr(255, s), 27)\n                    s := shr(1, shl(1, s))\n                }\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\n                    v := xor(v, 7)\n                    s := sub(N, s)\n                }\n                mstore(0x21, v)\n                mstore(0x20, s)\n                result := keccak256(0x00, 0x41)\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n                break\n            }\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\n            if iszero(lt(sub(signature.length, 64), 2)) {\n                calldatacopy(mload(0x40), signature.offset, signature.length)\n                // `bytes4(keccak256(\"InvalidSignatureLength\"))`.\n                result := xor(keccak256(mload(0x40), signature.length), 0xd62f1ab2)\n            }\n        }\n    }\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHash(bytes32 r, bytes32 vs) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, r) // `r`.\n            let v := add(shr(255, vs), 27)\n            let s := shr(1, shl(1, vs))\n            mstore(0x21, v)\n            mstore(0x20, s)\n            result := keccak256(0x00, 0x41)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHash(uint8 v, bytes32 r, bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, r) // `r`.\n            if iszero(lt(s, _HALF_N_PLUS_1)) {\n                v := xor(v, 7)\n                s := sub(N, s)\n            }\n            mstore(0x21, v)\n            mstore(0x20, s)\n            result := keccak256(0x00, 0x41)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"}},"settings":{"remappings":["@rhinestone/=node_modules/@rhinestone/","sentinellist/=node_modules/@rhinestone/sentinellist/src/","erc4337-validation/=node_modules/@rhinestone/erc4337-validation/src/","modulekit/=node_modules/@rhinestone/modulekit/src/","module-bases/=node_modules/@rhinestone/module-bases/src/","@ERC4337/=node_modules/@ERC4337/","account-abstraction/=node_modules/@ERC4337/account-abstraction/contracts/","account-abstraction-v0.6/=node_modules/@ERC4337/account-abstraction-v0.6/contracts/","@openzeppelin/=node_modules/@openzeppelin/","@safe-global/=node_modules/@safe-global/","ds-test/=node_modules/ds-test/src/","erc7579/=node_modules/erc7579/src/","forge-std/=node_modules/forge-std/src/","solady/=node_modules/solady/src/","solarray/=node_modules/solarray/src/","@prb/math/=node_modules/@prb/math/src/","@gnosis.pm/=node_modules/@gnosis.pm/","hardhat-deploy/=node_modules/hardhat-deploy/","hardhat/=node_modules/hardhat/"],"optimizer":{"enabled":true,"runs":10000},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
